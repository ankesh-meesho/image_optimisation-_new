"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99,\n            needs\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUk7WUFDRixNQUFNWSxZQUFZLE1BQU01RSx1REFBVUEsQ0FBQ0csTUFBTTZELE9BQU83RCxJQUFJO1lBQ3BELE9BQU87Z0JBQUUsR0FBRzZELE1BQU07Z0JBQUVoRSxZQUFZNEU7WUFBVTtRQUM1QyxFQUFFLE9BQU9qQyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxnQ0FBNkMsT0FBYnFCLE9BQU9ULEtBQUssRUFBQyxNQUFJWjtZQUMvRCxPQUFPO2dCQUFFLEdBQUdxQixNQUFNO2dCQUFFaEUsWUFBWTtZQUFRO1FBQzFDO0lBQ0Y7SUFFQSxNQUFNNkUsZUFBZSxNQUFNekUsUUFBUTBFLEdBQUcsQ0FBQ0g7SUFDdkMsT0FBT0U7QUFDVCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3V0aWxzL2ltYWdlUHJvY2Vzc29yLmpzP2QyNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBpY2EgZnJvbSAncGljYSc7XG5pbXBvcnQgeyBzc2ltUmVzdWx0IH0gZnJvbSAnLi9zc2ltUmVzdWx0JztcblxuY29uc3QgcGljYSA9IG5ldyBQaWNhKCk7XG5cbmNvbnN0IGdldEltYWdlRGltZW5zaW9ucyA9IChmaWxlKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nLndpZHRoLCBoZWlnaHQ6IGltZy5oZWlnaHQgfSk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGltZy5zcmMpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSAoZXJyKSA9PiByZWplY3QoZXJyKTtcbiAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgfSk7XG59O1xuXG5jb25zdCBwcm9jZXNzSW1hZ2UgPSBhc3luYyAoZmlsZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNvdXJjZUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3Qgc291cmNlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICBzb3VyY2VJbWFnZS5zcmMgPSBzb3VyY2VVcmw7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVXJsKTtcblxuICAgIGNvbnN0IGRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBzb3VyY2VJbWFnZS53aWR0aDtcbiAgICBsZXQgdGFyZ2V0SGVpZ2h0ID0gc291cmNlSW1hZ2UuaGVpZ2h0O1xuXG4gICAgaWYgKG9wdGlvbnMubWF4V2lkdGggJiYgc291cmNlSW1hZ2Uud2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gc291cmNlSW1hZ2Uud2lkdGggLyBzb3VyY2VJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHRhcmdldFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aDtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0V2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgXG4gICAgZGVzdENhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgIGRlc3RDYW52YXMuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgIFxuICAgIGF3YWl0IHBpY2EucmVzaXplKHNvdXJjZUltYWdlLCBkZXN0Q2FudmFzLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHVuc2hhcnBBbW91bnQ6IDE2MCxcbiAgICAgIHVuc2hhcnBSYWRpdXM6IDAuNixcbiAgICAgIHVuc2hhcnBUaHJlc2hvbGQ6IDEsXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3Qgb3V0cHV0UXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWFsaXR5IDogMTtcblxuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBwaWNhLnRvQmxvYihkZXN0Q2FudmFzLCBvcHRpb25zLmZpbGVUeXBlLCBvdXRwdXRRdWFsaXR5KTtcblxuICAgIHJldHVybiBuZXcgRmlsZShbYmxvYl0sIGZpbGUubmFtZSwgeyB0eXBlOiBvcHRpb25zLmZpbGVUeXBlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgdG8gJHtvcHRpb25zLmZpbGVUeXBlIHx8ICdvcmlnaW5hbCd9IGZvcm1hdDpgLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCB0byAke29wdGlvbnMuZmlsZVR5cGV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eSA9IGFzeW5jIChmaWxlLCB7IG1heFdpZHRoIH0pID0+IHtcbiAgaWYgKCFmaWxlIHx8ICFmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmlsZSB0eXBlLicpO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxTaXplID0gZmlsZS5zaXplO1xuICBjb25zdCBvcmlnaW5hbEZvcm1hdCA9IGZpbGUudHlwZTtcbiAgY29uc3QgeyB3aWR0aCB9ID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGZpbGUpO1xuICBjb25zdCBuZWVkc1Jlc2l6aW5nID0gd2lkdGggPiBtYXhXaWR0aDtcblxuICBjb25zdCB0YXJnZXRGb3JtYXRzID0gW1xuICAgIHsgZm9ybWF0OiAnaW1hZ2UvanBlZycsIGxhYmVsOiAnSlBFRycgfSxcbiAgICB7IGZvcm1hdDogJ2ltYWdlL3dlYnAnLCBsYWJlbDogJ1dlYlAnIH0sXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS9wbmcnLCBsYWJlbDogJ1BORycgfVxuICBdO1xuXG4gIGNvbnN0IHByb2Nlc3NpbmdQcm9taXNlcyA9IHRhcmdldEZvcm1hdHMubWFwKHRhcmdldCA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZpbGVUeXBlOiB0YXJnZXQuZm9ybWF0LFxuICAgICAgbWF4V2lkdGg6IG5lZWRzUmVzaXppbmcgPyBtYXhXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgIHF1YWxpdHk6IDAuOTksIFxuICAgICAgbmVlZHNcbiAgICB9O1xuICAgIHJldHVybiBwcm9jZXNzSW1hZ2UoZmlsZSwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIGNvbnN0IHNldHRsZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb2Nlc3NpbmdQcm9taXNlcyk7XG5cbiAgY29uc3Qgc3VjY2Vzc2Z1bFJlc3VsdHMgPSBzZXR0bGVkUmVzdWx0c1xuICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKVxuICAgIC5tYXAocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IG5ld0ZpbGUgPSByZXN1bHQudmFsdWU7XG4gICAgICBjb25zdCByZWR1Y3Rpb24gPSAoKG9yaWdpbmFsU2l6ZSAtIG5ld0ZpbGUuc2l6ZSkgLyBvcmlnaW5hbFNpemUpICogMTAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZTogbmV3RmlsZSxcbiAgICAgICAgZm9ybWF0OiBuZXdGaWxlLnR5cGUsXG4gICAgICAgIGxhYmVsOiBgJHt0YXJnZXRGb3JtYXRzLmZpbmQoZiA9PiBmLmZvcm1hdCA9PT0gbmV3RmlsZS50eXBlKT8ubGFiZWx9ICR7bmV3RmlsZS50eXBlID09PSBvcmlnaW5hbEZvcm1hdCA/ICdyZXNpemVkJyA6ICcnfWAgfHwgJ1Vua25vd24nLFxuICAgICAgICBzaXplOiBuZXdGaWxlLnNpemUsXG4gICAgICAgIHJlZHVjdGlvbjogcmVkdWN0aW9uLFxuICAgICAgICBpc09yaWdpbmFsRm9ybWF0OiBuZXdGaWxlLnR5cGUgPT09IG9yaWdpbmFsRm9ybWF0LFxuICAgICAgfTtcbiAgICB9KTtcblxuICBzZXR0bGVkUmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihyZXN1bHQucmVhc29uKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzID0gc3VjY2Vzc2Z1bFJlc3VsdHMubWFwKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3NpbVNjb3JlID0gYXdhaXQgc3NpbVJlc3VsdChmaWxlLCByZXN1bHQuZmlsZSk7XG4gICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHNzaW1SZXN1bHQ6IHNzaW1TY29yZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgY2FsY3VsYXRlIFNTSU0gZm9yICR7cmVzdWx0LmxhYmVsfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHNzaW1SZXN1bHQ6ICdFcnJvcicgfTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGZpbmFsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzKTtcbiAgcmV0dXJuIGZpbmFsUmVzdWx0cztcbn07Il0sIm5hbWVzIjpbIlBpY2EiLCJzc2ltUmVzdWx0IiwicGljYSIsImdldEltYWdlRGltZW5zaW9ucyIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJzcmMiLCJvbmVycm9yIiwiZXJyIiwiY3JlYXRlT2JqZWN0VVJMIiwicHJvY2Vzc0ltYWdlIiwib3B0aW9ucyIsInNvdXJjZUltYWdlIiwic291cmNlVXJsIiwiZGVzdENhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4V2lkdGgiLCJhc3BlY3RSYXRpbyIsInJlc2l6ZSIsImFscGhhIiwidW5zaGFycEFtb3VudCIsInVuc2hhcnBSYWRpdXMiLCJ1bnNoYXJwVGhyZXNob2xkIiwib3V0cHV0UXVhbGl0eSIsInF1YWxpdHkiLCJ1bmRlZmluZWQiLCJibG9iIiwidG9CbG9iIiwiZmlsZVR5cGUiLCJGaWxlIiwibmFtZSIsInR5cGUiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eSIsInN0YXJ0c1dpdGgiLCJvcmlnaW5hbFNpemUiLCJzaXplIiwib3JpZ2luYWxGb3JtYXQiLCJuZWVkc1Jlc2l6aW5nIiwidGFyZ2V0Rm9ybWF0cyIsImZvcm1hdCIsImxhYmVsIiwicHJvY2Vzc2luZ1Byb21pc2VzIiwibWFwIiwidGFyZ2V0IiwibmVlZHMiLCJzZXR0bGVkUmVzdWx0cyIsImFsbFNldHRsZWQiLCJzdWNjZXNzZnVsUmVzdWx0cyIsImZpbHRlciIsInJlc3VsdCIsInN0YXR1cyIsIm5ld0ZpbGUiLCJ2YWx1ZSIsInJlZHVjdGlvbiIsImZpbmQiLCJmIiwiaXNPcmlnaW5hbEZvcm1hdCIsImZvckVhY2giLCJ3YXJuIiwicmVhc29uIiwicmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMiLCJzc2ltU2NvcmUiLCJmaW5hbFJlc3VsdHMiLCJhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ })

});