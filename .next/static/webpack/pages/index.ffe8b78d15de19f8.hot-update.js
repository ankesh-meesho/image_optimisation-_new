"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNWSxZQUFZLE1BQU0zRSx1REFBVUEsQ0FBQ0csTUFBTTRELE9BQU81RCxJQUFJO1lBQ3BELE9BQU87Z0JBQUUsR0FBRzRELE1BQU07Z0JBQUUvRCxZQUFZMkU7WUFBVTtRQUM1QyxFQUFFLE9BQU9oQyxPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQyxnQ0FBNkMsT0FBYm9CLE9BQU9SLEtBQUssRUFBQyxNQUFJWjtZQUMvRCxPQUFPO2dCQUFFLEdBQUdvQixNQUFNO2dCQUFFL0QsWUFBWTtZQUFRO1FBQzFDO0lBQ0Y7SUFFQSxNQUFNNEUsZUFBZSxNQUFNeEUsUUFBUXlFLEdBQUcsQ0FBQ0g7SUFDdkMsT0FBT0U7QUFDVCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3V0aWxzL2ltYWdlUHJvY2Vzc29yLmpzP2QyNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBpY2EgZnJvbSAncGljYSc7XG5pbXBvcnQgeyBzc2ltUmVzdWx0IH0gZnJvbSAnLi9zc2ltUmVzdWx0JztcblxuY29uc3QgcGljYSA9IG5ldyBQaWNhKCk7XG5cbmNvbnN0IGdldEltYWdlRGltZW5zaW9ucyA9IChmaWxlKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIHJlc29sdmUoeyB3aWR0aDogaW1nLndpZHRoLCBoZWlnaHQ6IGltZy5oZWlnaHQgfSk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGltZy5zcmMpO1xuICAgIH07XG4gICAgaW1nLm9uZXJyb3IgPSAoZXJyKSA9PiByZWplY3QoZXJyKTtcbiAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgfSk7XG59O1xuXG5jb25zdCBwcm9jZXNzSW1hZ2UgPSBhc3luYyAoZmlsZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNvdXJjZUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3Qgc291cmNlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICBzb3VyY2VJbWFnZS5zcmMgPSBzb3VyY2VVcmw7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVXJsKTtcblxuICAgIGNvbnN0IGRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBzb3VyY2VJbWFnZS53aWR0aDtcbiAgICBsZXQgdGFyZ2V0SGVpZ2h0ID0gc291cmNlSW1hZ2UuaGVpZ2h0O1xuXG4gICAgaWYgKG9wdGlvbnMubWF4V2lkdGggJiYgc291cmNlSW1hZ2Uud2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gc291cmNlSW1hZ2Uud2lkdGggLyBzb3VyY2VJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHRhcmdldFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aDtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0V2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgXG4gICAgZGVzdENhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgIGRlc3RDYW52YXMuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgIFxuICAgIGF3YWl0IHBpY2EucmVzaXplKHNvdXJjZUltYWdlLCBkZXN0Q2FudmFzLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHVuc2hhcnBBbW91bnQ6IDE2MCxcbiAgICAgIHVuc2hhcnBSYWRpdXM6IDAuNixcbiAgICAgIHVuc2hhcnBUaHJlc2hvbGQ6IDEsXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3Qgb3V0cHV0UXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWFsaXR5IDogMTtcblxuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBwaWNhLnRvQmxvYihkZXN0Q2FudmFzLCBvcHRpb25zLmZpbGVUeXBlLCBvdXRwdXRRdWFsaXR5KTtcblxuICAgIHJldHVybiBuZXcgRmlsZShbYmxvYl0sIGZpbGUubmFtZSwgeyB0eXBlOiBvcHRpb25zLmZpbGVUeXBlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgdG8gJHtvcHRpb25zLmZpbGVUeXBlIHx8ICdvcmlnaW5hbCd9IGZvcm1hdDpgLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCB0byAke29wdGlvbnMuZmlsZVR5cGV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eSA9IGFzeW5jIChmaWxlLCB7IG1heFdpZHRoIH0pID0+IHtcbiAgaWYgKCFmaWxlIHx8ICFmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmlsZSB0eXBlLicpO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxTaXplID0gZmlsZS5zaXplO1xuICBjb25zdCBvcmlnaW5hbEZvcm1hdCA9IGZpbGUudHlwZTtcbiAgY29uc3QgeyB3aWR0aCB9ID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGZpbGUpO1xuICBjb25zdCBuZWVkc1Jlc2l6aW5nID0gd2lkdGggPiBtYXhXaWR0aDtcblxuICBjb25zdCB0YXJnZXRGb3JtYXRzID0gW1xuICAgIHsgZm9ybWF0OiAnaW1hZ2UvanBlZycsIGxhYmVsOiAnSlBFRycgfSxcbiAgICB7IGZvcm1hdDogJ2ltYWdlL3dlYnAnLCBsYWJlbDogJ1dlYlAnIH0sXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS9wbmcnLCBsYWJlbDogJ1BORycgfVxuICBdO1xuXG4gIGNvbnN0IHByb2Nlc3NpbmdQcm9taXNlcyA9IHRhcmdldEZvcm1hdHMubWFwKHRhcmdldCA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZpbGVUeXBlOiB0YXJnZXQuZm9ybWF0LFxuICAgICAgbWF4V2lkdGg6IG5lZWRzUmVzaXppbmcgPyBtYXhXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgIHF1YWxpdHk6IDAuOTksIFxuICAgICAgXG4gICAgfTtcbiAgICByZXR1cm4gcHJvY2Vzc0ltYWdlKGZpbGUsIG9wdGlvbnMpO1xuICB9KTtcblxuICBjb25zdCBzZXR0bGVkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9jZXNzaW5nUHJvbWlzZXMpO1xuXG4gIGNvbnN0IHN1Y2Nlc3NmdWxSZXN1bHRzID0gc2V0dGxlZFJlc3VsdHNcbiAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJylcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBuZXdGaWxlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgY29uc3QgcmVkdWN0aW9uID0gKChvcmlnaW5hbFNpemUgLSBuZXdGaWxlLnNpemUpIC8gb3JpZ2luYWxTaXplKSAqIDEwMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGU6IG5ld0ZpbGUsXG4gICAgICAgIGZvcm1hdDogbmV3RmlsZS50eXBlLFxuICAgICAgICBsYWJlbDogYCR7dGFyZ2V0Rm9ybWF0cy5maW5kKGYgPT4gZi5mb3JtYXQgPT09IG5ld0ZpbGUudHlwZSk/LmxhYmVsfSAke25ld0ZpbGUudHlwZSA9PT0gb3JpZ2luYWxGb3JtYXQgPyAncmVzaXplZCcgOiAnJ31gIHx8ICdVbmtub3duJyxcbiAgICAgICAgc2l6ZTogbmV3RmlsZS5zaXplLFxuICAgICAgICByZWR1Y3Rpb246IHJlZHVjdGlvbixcbiAgICAgICAgaXNPcmlnaW5hbEZvcm1hdDogbmV3RmlsZS50eXBlID09PSBvcmlnaW5hbEZvcm1hdCxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgc2V0dGxlZFJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4ocmVzdWx0LnJlYXNvbik7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCByZXN1bHRzV2l0aFF1YWxpdHlQcm9taXNlcyA9IHN1Y2Nlc3NmdWxSZXN1bHRzLm1hcChhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNzaW1TY29yZSA9IGF3YWl0IHNzaW1SZXN1bHQoZmlsZSwgcmVzdWx0LmZpbGUpO1xuICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCBzc2ltUmVzdWx0OiBzc2ltU2NvcmUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGNhbGN1bGF0ZSBTU0lNIGZvciAke3Jlc3VsdC5sYWJlbH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCBzc2ltUmVzdWx0OiAnRXJyb3InIH07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmaW5hbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzV2l0aFF1YWxpdHlQcm9taXNlcyk7XG4gIHJldHVybiBmaW5hbFJlc3VsdHM7XG59OyJdLCJuYW1lcyI6WyJQaWNhIiwic3NpbVJlc3VsdCIsInBpY2EiLCJnZXRJbWFnZURpbWVuc2lvbnMiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0IiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwic3JjIiwib25lcnJvciIsImVyciIsImNyZWF0ZU9iamVjdFVSTCIsInByb2Nlc3NJbWFnZSIsIm9wdGlvbnMiLCJzb3VyY2VJbWFnZSIsInNvdXJjZVVybCIsImRlc3RDYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm1heFdpZHRoIiwiYXNwZWN0UmF0aW8iLCJyZXNpemUiLCJhbHBoYSIsInVuc2hhcnBBbW91bnQiLCJ1bnNoYXJwUmFkaXVzIiwidW5zaGFycFRocmVzaG9sZCIsIm91dHB1dFF1YWxpdHkiLCJxdWFsaXR5IiwidW5kZWZpbmVkIiwiYmxvYiIsInRvQmxvYiIsImZpbGVUeXBlIiwiRmlsZSIsIm5hbWUiLCJ0eXBlIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2VuZXJhdGVJbWFnZVByZXZpZXdzV2l0aFF1YWxpdHkiLCJzdGFydHNXaXRoIiwib3JpZ2luYWxTaXplIiwic2l6ZSIsIm9yaWdpbmFsRm9ybWF0IiwibmVlZHNSZXNpemluZyIsInRhcmdldEZvcm1hdHMiLCJmb3JtYXQiLCJsYWJlbCIsInByb2Nlc3NpbmdQcm9taXNlcyIsIm1hcCIsInRhcmdldCIsInNldHRsZWRSZXN1bHRzIiwiYWxsU2V0dGxlZCIsInN1Y2Nlc3NmdWxSZXN1bHRzIiwiZmlsdGVyIiwicmVzdWx0Iiwic3RhdHVzIiwibmV3RmlsZSIsInZhbHVlIiwicmVkdWN0aW9uIiwiZmluZCIsImYiLCJpc09yaWdpbmFsRm9ybWF0IiwiZm9yRWFjaCIsIndhcm4iLCJyZWFzb24iLCJyZXN1bHRzV2l0aFF1YWxpdHlQcm9taXNlcyIsInNzaW1TY29yZSIsImZpbmFsUmVzdWx0cyIsImFsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ })

});