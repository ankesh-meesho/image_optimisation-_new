"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99,\n            needsResizing: needsResizing\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy91dGlscy9pbWFnZVByb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdCO0FBQ2tCO0FBRTFDLE1BQU1FLE9BQU8sSUFBSUYsNkNBQUlBO0FBRXJCLE1BQU1HLHFCQUFxQixDQUFDQztJQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsTUFBTUMsTUFBTSxJQUFJQztRQUNoQkQsSUFBSUUsTUFBTSxHQUFHO1lBQ1hKLFFBQVE7Z0JBQUVLLE9BQU9ILElBQUlHLEtBQUs7Z0JBQUVDLFFBQVFKLElBQUlJLE1BQU07WUFBQztZQUMvQ0MsSUFBSUMsZUFBZSxDQUFDTixJQUFJTyxHQUFHO1FBQzdCO1FBQ0FQLElBQUlRLE9BQU8sR0FBRyxDQUFDQyxNQUFRVixPQUFPVTtRQUM5QlQsSUFBSU8sR0FBRyxHQUFHRixJQUFJSyxlQUFlLENBQUNkO0lBQ2hDO0FBQ0Y7QUFFQSxNQUFNZSxlQUFlLE9BQU9mLE1BQU1nQjtJQUNoQyxJQUFJO1FBQ0YsTUFBTUMsY0FBYyxJQUFJWjtRQUN4QixNQUFNYSxZQUFZVCxJQUFJSyxlQUFlLENBQUNkO1FBQ3RDaUIsWUFBWU4sR0FBRyxHQUFHTztRQUNsQixNQUFNLElBQUlqQixRQUFRLENBQUNDLFNBQVNDO1lBQ3hCYyxZQUFZWCxNQUFNLEdBQUdKO1lBQ3JCZSxZQUFZTCxPQUFPLEdBQUdUO1FBQzFCO1FBQ0FNLElBQUlDLGVBQWUsQ0FBQ1E7UUFFcEIsTUFBTUMsYUFBYUMsU0FBU0MsYUFBYSxDQUFDO1FBQzFDLElBQUlDLGNBQWNMLFlBQVlWLEtBQUs7UUFDbkMsSUFBSWdCLGVBQWVOLFlBQVlULE1BQU07UUFFckMsSUFBSVEsUUFBUVEsUUFBUSxJQUFJUCxZQUFZVixLQUFLLEdBQUdTLFFBQVFRLFFBQVEsRUFBRTtZQUMxRCxNQUFNQyxjQUFjUixZQUFZVixLQUFLLEdBQUdVLFlBQVlULE1BQU07WUFDMURjLGNBQWNOLFFBQVFRLFFBQVE7WUFDOUJELGVBQWVELGNBQWNHO1FBQ2pDO1FBRUFOLFdBQVdaLEtBQUssR0FBR2U7UUFDbkJILFdBQVdYLE1BQU0sR0FBR2U7UUFFcEIsTUFBTXpCLEtBQUs0QixNQUFNLENBQUNULGFBQWFFLFlBQVk7WUFDekNRLE9BQU87WUFDUEMsZUFBZTtZQUNmQyxlQUFlO1lBQ2ZDLGtCQUFrQjtRQUNwQjtRQUVBLE1BQU1DLGdCQUFnQmYsUUFBUWdCLE9BQU8sS0FBS0MsWUFBWWpCLFFBQVFnQixPQUFPLEdBQUc7UUFFeEUsTUFBTUUsT0FBTyxNQUFNcEMsS0FBS3FDLE1BQU0sQ0FBQ2hCLFlBQVlILFFBQVFvQixRQUFRLEVBQUVMO1FBRTdELE9BQU8sSUFBSU0sS0FBSztZQUFDSDtTQUFLLEVBQUVsQyxLQUFLc0MsSUFBSSxFQUFFO1lBQUVDLE1BQU12QixRQUFRb0IsUUFBUTtRQUFDO0lBQzlELEVBQUUsT0FBT0ksT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsdUJBQXNELE9BQS9CeEIsUUFBUW9CLFFBQVEsSUFBSSxZQUFXLGFBQVdJO1FBQy9FLE1BQU0sSUFBSUUsTUFBTSx3QkFBNkNGLE9BQXJCeEIsUUFBUW9CLFFBQVEsRUFBQyxNQUFrQixPQUFkSSxNQUFNRyxPQUFPO0lBQzVFO0FBQ0Y7QUFFTyxNQUFNQyxtQ0FBbUMsT0FBTzVDO1FBQU0sRUFBRXdCLFFBQVEsRUFBRTtJQUN2RSxJQUFJLENBQUN4QixRQUFRLENBQUNBLEtBQUt1QyxJQUFJLENBQUNNLFVBQVUsQ0FBQyxXQUFXO1FBQzVDLE1BQU0sSUFBSUgsTUFBTTtJQUNsQjtJQUVBLE1BQU1JLGVBQWU5QyxLQUFLK0MsSUFBSTtJQUM5QixNQUFNQyxpQkFBaUJoRCxLQUFLdUMsSUFBSTtJQUNoQyxNQUFNLEVBQUVoQyxLQUFLLEVBQUUsR0FBRyxNQUFNUixtQkFBbUJDO0lBQzNDLE1BQU1pRCxnQkFBZ0IxQyxRQUFRaUI7SUFFOUIsTUFBTTBCLGdCQUFnQjtRQUNwQjtZQUFFQyxRQUFRO1lBQWNDLE9BQU87UUFBTztRQUN0QztZQUFFRCxRQUFRO1lBQWNDLE9BQU87UUFBTztRQUN0QztZQUFFRCxRQUFRO1lBQWFDLE9BQU87UUFBTTtLQUNyQztJQUVELE1BQU1DLHFCQUFxQkgsY0FBY0ksR0FBRyxDQUFDQyxDQUFBQTtRQUMzQyxNQUFNdkMsVUFBVTtZQUNkb0IsVUFBVW1CLE9BQU9KLE1BQU07WUFDdkIzQixVQUFVeUIsZ0JBQWdCekIsV0FBV1M7WUFDckNELFNBQVM7WUFDVGlCLGVBQWVBO1FBQ2pCO1FBQ0EsT0FBT2xDLGFBQWFmLE1BQU1nQjtJQUM1QjtJQUVBLE1BQU13QyxpQkFBaUIsTUFBTXZELFFBQVF3RCxVQUFVLENBQUNKO0lBRWhELE1BQU1LLG9CQUFvQkYsZUFDdkJHLE1BQU0sQ0FBQ0MsQ0FBQUEsU0FBVUEsT0FBT0MsTUFBTSxLQUFLLGFBQ25DUCxHQUFHLENBQUNNLENBQUFBO1lBTVNWO1FBTFosTUFBTVksVUFBVUYsT0FBT0csS0FBSztRQUM1QixNQUFNQyxZQUFZLENBQUVsQixlQUFlZ0IsUUFBUWYsSUFBSSxJQUFJRCxlQUFnQjtRQUNuRSxPQUFPO1lBQ0w5QyxNQUFNOEQ7WUFDTlgsUUFBUVcsUUFBUXZCLElBQUk7WUFDcEJhLE9BQU8sR0FBZ0VVLFFBQTdEWixzQkFBQUEsY0FBY2UsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFZixNQUFNLEtBQUtXLFFBQVF2QixJQUFJLGVBQWpEVywwQ0FBQUEsb0JBQW9ERSxLQUFLLEVBQUMsS0FBb0QsT0FBakRVLFFBQVF2QixJQUFJLEtBQUtTLGlCQUFpQixZQUFZLE9BQVE7WUFDN0hELE1BQU1lLFFBQVFmLElBQUk7WUFDbEJpQixXQUFXQTtZQUNYRyxrQkFBa0JMLFFBQVF2QixJQUFJLEtBQUtTO1FBQ3JDO0lBQ0Y7SUFFRlEsZUFBZVksT0FBTyxDQUFDUixDQUFBQTtRQUNyQixJQUFJQSxPQUFPQyxNQUFNLEtBQUssWUFBWTtZQUNoQ3BCLFFBQVE0QixJQUFJLENBQUNULE9BQU9VLE1BQU07UUFDNUI7SUFDRjtJQUVBLE1BQU1DLDZCQUE2QmIsa0JBQWtCSixHQUFHLENBQUMsT0FBT007UUFDOUQsSUFBSTtZQUNGLE1BQU1ZLFlBQVksTUFBTTNFLHVEQUFVQSxDQUFDRyxNQUFNNEQsT0FBTzVELElBQUk7WUFDcEQsT0FBTztnQkFBRSxHQUFHNEQsTUFBTTtnQkFBRS9ELFlBQVkyRTtZQUFVO1FBQzVDLEVBQUUsT0FBT2hDLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUE2QyxPQUFib0IsT0FBT1IsS0FBSyxFQUFDLE1BQUlaO1lBQy9ELE9BQU87Z0JBQUUsR0FBR29CLE1BQU07Z0JBQUUvRCxZQUFZO1lBQVE7UUFDMUM7SUFDRjtJQUVBLE1BQU00RSxlQUFlLE1BQU14RSxRQUFReUUsR0FBRyxDQUFDSDtJQUN2QyxPQUFPRTtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvaW1hZ2VQcm9jZXNzb3IuanM/ZDI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGljYSBmcm9tICdwaWNhJztcbmltcG9ydCB7IHNzaW1SZXN1bHQgfSBmcm9tICcuL3NzaW1SZXN1bHQnO1xuXG5jb25zdCBwaWNhID0gbmV3IFBpY2EoKTtcblxuY29uc3QgZ2V0SW1hZ2VEaW1lbnNpb25zID0gKGZpbGUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBpbWcud2lkdGgsIGhlaWdodDogaW1nLmhlaWdodCB9KTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IChlcnIpID0+IHJlamVjdChlcnIpO1xuICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn07XG5cbmNvbnN0IHByb2Nlc3NJbWFnZSA9IGFzeW5jIChmaWxlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc291cmNlSW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBjb25zdCBzb3VyY2VVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgIHNvdXJjZUltYWdlLnNyYyA9IHNvdXJjZVVybDtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHNvdXJjZUltYWdlLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIHNvdXJjZUltYWdlLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTChzb3VyY2VVcmwpO1xuXG4gICAgY29uc3QgZGVzdENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGxldCB0YXJnZXRXaWR0aCA9IHNvdXJjZUltYWdlLndpZHRoO1xuICAgIGxldCB0YXJnZXRIZWlnaHQgPSBzb3VyY2VJbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAob3B0aW9ucy5tYXhXaWR0aCAmJiBzb3VyY2VJbWFnZS53aWR0aCA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBzb3VyY2VJbWFnZS53aWR0aCAvIHNvdXJjZUltYWdlLmhlaWdodDtcbiAgICAgICAgdGFyZ2V0V2lkdGggPSBvcHRpb25zLm1heFdpZHRoO1xuICAgICAgICB0YXJnZXRIZWlnaHQgPSB0YXJnZXRXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBcbiAgICBkZXN0Q2FudmFzLndpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgZGVzdENhbnZhcy5oZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XG4gICAgXG4gICAgYXdhaXQgcGljYS5yZXNpemUoc291cmNlSW1hZ2UsIGRlc3RDYW52YXMsIHtcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgdW5zaGFycEFtb3VudDogMTYwLFxuICAgICAgdW5zaGFycFJhZGl1czogMC42LFxuICAgICAgdW5zaGFycFRocmVzaG9sZDogMSxcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCBvdXRwdXRRdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnF1YWxpdHkgOiAxO1xuXG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHBpY2EudG9CbG9iKGRlc3RDYW52YXMsIG9wdGlvbnMuZmlsZVR5cGUsIG91dHB1dFF1YWxpdHkpO1xuXG4gICAgcmV0dXJuIG5ldyBGaWxlKFtibG9iXSwgZmlsZS5uYW1lLCB7IHR5cGU6IG9wdGlvbnMuZmlsZVR5cGUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyB0byAke29wdGlvbnMuZmlsZVR5cGUgfHwgJ29yaWdpbmFsJ30gZm9ybWF0OmAsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjb252ZXJ0IHRvICR7b3B0aW9ucy5maWxlVHlwZX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlSW1hZ2VQcmV2aWV3c1dpdGhRdWFsaXR5ID0gYXN5bmMgKGZpbGUsIHsgbWF4V2lkdGggfSkgPT4ge1xuICBpZiAoIWZpbGUgfHwgIWZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmaWxlIHR5cGUuJyk7XG4gIH1cblxuICBjb25zdCBvcmlnaW5hbFNpemUgPSBmaWxlLnNpemU7XG4gIGNvbnN0IG9yaWdpbmFsRm9ybWF0ID0gZmlsZS50eXBlO1xuICBjb25zdCB7IHdpZHRoIH0gPSBhd2FpdCBnZXRJbWFnZURpbWVuc2lvbnMoZmlsZSk7XG4gIGNvbnN0IG5lZWRzUmVzaXppbmcgPSB3aWR0aCA+IG1heFdpZHRoO1xuXG4gIGNvbnN0IHRhcmdldEZvcm1hdHMgPSBbXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS9qcGVnJywgbGFiZWw6ICdKUEVHJyB9LFxuICAgIHsgZm9ybWF0OiAnaW1hZ2Uvd2VicCcsIGxhYmVsOiAnV2ViUCcgfSxcbiAgICB7IGZvcm1hdDogJ2ltYWdlL3BuZycsIGxhYmVsOiAnUE5HJyB9XG4gIF07XG5cbiAgY29uc3QgcHJvY2Vzc2luZ1Byb21pc2VzID0gdGFyZ2V0Rm9ybWF0cy5tYXAodGFyZ2V0ID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZmlsZVR5cGU6IHRhcmdldC5mb3JtYXQsXG4gICAgICBtYXhXaWR0aDogbmVlZHNSZXNpemluZyA/IG1heFdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgcXVhbGl0eTogMC45OSwgXG4gICAgICBuZWVkc1Jlc2l6aW5nOiBuZWVkc1Jlc2l6aW5nLFxuICAgIH07XG4gICAgcmV0dXJuIHByb2Nlc3NJbWFnZShmaWxlLCBvcHRpb25zKTtcbiAgfSk7XG5cbiAgY29uc3Qgc2V0dGxlZFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvY2Vzc2luZ1Byb21pc2VzKTtcblxuICBjb25zdCBzdWNjZXNzZnVsUmVzdWx0cyA9IHNldHRsZWRSZXN1bHRzXG4gICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpXG4gICAgLm1hcChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgbmV3RmlsZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIGNvbnN0IHJlZHVjdGlvbiA9ICgob3JpZ2luYWxTaXplIC0gbmV3RmlsZS5zaXplKSAvIG9yaWdpbmFsU2l6ZSkgKiAxMDA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlOiBuZXdGaWxlLFxuICAgICAgICBmb3JtYXQ6IG5ld0ZpbGUudHlwZSxcbiAgICAgICAgbGFiZWw6IGAke3RhcmdldEZvcm1hdHMuZmluZChmID0+IGYuZm9ybWF0ID09PSBuZXdGaWxlLnR5cGUpPy5sYWJlbH0gJHtuZXdGaWxlLnR5cGUgPT09IG9yaWdpbmFsRm9ybWF0ID8gJ3Jlc2l6ZWQnIDogJyd9YCB8fCAnVW5rbm93bicsXG4gICAgICAgIHNpemU6IG5ld0ZpbGUuc2l6ZSxcbiAgICAgICAgcmVkdWN0aW9uOiByZWR1Y3Rpb24sXG4gICAgICAgIGlzT3JpZ2luYWxGb3JtYXQ6IG5ld0ZpbGUudHlwZSA9PT0gb3JpZ2luYWxGb3JtYXQsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gIHNldHRsZWRSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgY29uc29sZS53YXJuKHJlc3VsdC5yZWFzb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMgPSBzdWNjZXNzZnVsUmVzdWx0cy5tYXAoYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzc2ltU2NvcmUgPSBhd2FpdCBzc2ltUmVzdWx0KGZpbGUsIHJlc3VsdC5maWxlKTtcbiAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgc3NpbVJlc3VsdDogc3NpbVNjb3JlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBjYWxjdWxhdGUgU1NJTSBmb3IgJHtyZXN1bHQubGFiZWx9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgc3NpbVJlc3VsdDogJ0Vycm9yJyB9O1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZmluYWxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMpO1xuICByZXR1cm4gZmluYWxSZXN1bHRzO1xufTsiXSwibmFtZXMiOlsiUGljYSIsInNzaW1SZXN1bHQiLCJwaWNhIiwiZ2V0SW1hZ2VEaW1lbnNpb25zIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsInNyYyIsIm9uZXJyb3IiLCJlcnIiLCJjcmVhdGVPYmplY3RVUkwiLCJwcm9jZXNzSW1hZ2UiLCJvcHRpb25zIiwic291cmNlSW1hZ2UiLCJzb3VyY2VVcmwiLCJkZXN0Q2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJtYXhXaWR0aCIsImFzcGVjdFJhdGlvIiwicmVzaXplIiwiYWxwaGEiLCJ1bnNoYXJwQW1vdW50IiwidW5zaGFycFJhZGl1cyIsInVuc2hhcnBUaHJlc2hvbGQiLCJvdXRwdXRRdWFsaXR5IiwicXVhbGl0eSIsInVuZGVmaW5lZCIsImJsb2IiLCJ0b0Jsb2IiLCJmaWxlVHlwZSIsIkZpbGUiLCJuYW1lIiwidHlwZSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsImdlbmVyYXRlSW1hZ2VQcmV2aWV3c1dpdGhRdWFsaXR5Iiwic3RhcnRzV2l0aCIsIm9yaWdpbmFsU2l6ZSIsInNpemUiLCJvcmlnaW5hbEZvcm1hdCIsIm5lZWRzUmVzaXppbmciLCJ0YXJnZXRGb3JtYXRzIiwiZm9ybWF0IiwibGFiZWwiLCJwcm9jZXNzaW5nUHJvbWlzZXMiLCJtYXAiLCJ0YXJnZXQiLCJzZXR0bGVkUmVzdWx0cyIsImFsbFNldHRsZWQiLCJzdWNjZXNzZnVsUmVzdWx0cyIsImZpbHRlciIsInJlc3VsdCIsInN0YXR1cyIsIm5ld0ZpbGUiLCJ2YWx1ZSIsInJlZHVjdGlvbiIsImZpbmQiLCJmIiwiaXNPcmlnaW5hbEZvcm1hdCIsImZvckVhY2giLCJ3YXJuIiwicmVhc29uIiwicmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMiLCJzc2ltU2NvcmUiLCJmaW5hbFJlc3VsdHMiLCJhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ })

});