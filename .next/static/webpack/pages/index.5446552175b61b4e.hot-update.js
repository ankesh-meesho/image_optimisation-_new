"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        if (!options.needsResizing && options.fileType === file.type) {\n            return file;\n        }\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99,\n            needsResizing: needsResizing\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q2hDbkIsUUFBUTJCLElBQUksQ0FBQ1QsT0FBT1UsTUFBTTtRQUM1QjtJQUNGO0lBRUEsTUFBTUMsNkJBQTZCYixrQkFBa0JKLEdBQUcsQ0FBQyxPQUFPTTtRQUM5RCxJQUFJO1lBQ0YsTUFBTVksWUFBWSxNQUFNM0UsdURBQVVBLENBQUNHLE1BQU00RCxPQUFPNUQsSUFBSTtZQUNwRCxPQUFPO2dCQUFFLEdBQUc0RCxNQUFNO2dCQUFFL0QsWUFBWTJFO1lBQVU7UUFDNUMsRUFBRSxPQUFPL0IsT0FBTztZQUNkQyxRQUFRRCxLQUFLLENBQUMsZ0NBQTZDLE9BQWJtQixPQUFPUixLQUFLLEVBQUMsTUFBSVg7WUFDL0QsT0FBTztnQkFBRSxHQUFHbUIsTUFBTTtnQkFBRS9ELFlBQVk7WUFBUTtRQUMxQztJQUNGO0lBRUEsTUFBTTRFLGVBQWUsTUFBTXhFLFFBQVF5RSxHQUFHLENBQUNIO0lBQ3ZDLE9BQU9FO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91dGlscy9pbWFnZVByb2Nlc3Nvci5qcz9kMjRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQaWNhIGZyb20gJ3BpY2EnO1xuaW1wb3J0IHsgc3NpbVJlc3VsdCB9IGZyb20gJy4vc3NpbVJlc3VsdCc7XG5cbmNvbnN0IHBpY2EgPSBuZXcgUGljYSgpO1xuXG5jb25zdCBnZXRJbWFnZURpbWVuc2lvbnMgPSAoZmlsZSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHsgd2lkdGg6IGltZy53aWR0aCwgaGVpZ2h0OiBpbWcuaGVpZ2h0IH0pO1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChpbWcuc3JjKTtcbiAgICB9O1xuICAgIGltZy5vbmVycm9yID0gKGVycikgPT4gcmVqZWN0KGVycik7XG4gICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gIH0pO1xufTtcblxuY29uc3QgcHJvY2Vzc0ltYWdlID0gYXN5bmMgKGZpbGUsIG9wdGlvbnMpID0+IHtcbiAgdHJ5IHtcbiAgICBpZighb3B0aW9ucy5uZWVkc1Jlc2l6aW5nICYmIG9wdGlvbnMuZmlsZVR5cGUgPT09IGZpbGUudHlwZSkge1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgY29uc3Qgc291cmNlVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICBzb3VyY2VJbWFnZS5zcmMgPSBzb3VyY2VVcmw7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICBzb3VyY2VJbWFnZS5vbmVycm9yID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVXJsKTtcblxuICAgIGNvbnN0IGRlc3RDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBzb3VyY2VJbWFnZS53aWR0aDtcbiAgICBsZXQgdGFyZ2V0SGVpZ2h0ID0gc291cmNlSW1hZ2UuaGVpZ2h0O1xuXG4gICAgaWYgKG9wdGlvbnMubWF4V2lkdGggJiYgc291cmNlSW1hZ2Uud2lkdGggPiBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gc291cmNlSW1hZ2Uud2lkdGggLyBzb3VyY2VJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHRhcmdldFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aDtcbiAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0V2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICB9XG4gICAgXG4gICAgZGVzdENhbnZhcy53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgIGRlc3RDYW52YXMuaGVpZ2h0ID0gdGFyZ2V0SGVpZ2h0O1xuICAgIFxuICAgIGF3YWl0IHBpY2EucmVzaXplKHNvdXJjZUltYWdlLCBkZXN0Q2FudmFzLCB7XG4gICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgIHVuc2hhcnBBbW91bnQ6IDE2MCxcbiAgICAgIHVuc2hhcnBSYWRpdXM6IDAuNixcbiAgICAgIHVuc2hhcnBUaHJlc2hvbGQ6IDEsXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3Qgb3V0cHV0UXVhbGl0eSA9IG9wdGlvbnMucXVhbGl0eSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5xdWFsaXR5IDogMTtcblxuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBwaWNhLnRvQmxvYihkZXN0Q2FudmFzLCBvcHRpb25zLmZpbGVUeXBlLCBvdXRwdXRRdWFsaXR5KTtcblxuICAgIHJldHVybiBuZXcgRmlsZShbYmxvYl0sIGZpbGUubmFtZSwgeyB0eXBlOiBvcHRpb25zLmZpbGVUeXBlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgdG8gJHtvcHRpb25zLmZpbGVUeXBlIHx8ICdvcmlnaW5hbCd9IGZvcm1hdDpgLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY29udmVydCB0byAke29wdGlvbnMuZmlsZVR5cGV9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eSA9IGFzeW5jIChmaWxlLCB7IG1heFdpZHRoIH0pID0+IHtcbiAgaWYgKCFmaWxlIHx8ICFmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZmlsZSB0eXBlLicpO1xuICB9XG5cbiAgY29uc3Qgb3JpZ2luYWxTaXplID0gZmlsZS5zaXplO1xuICBjb25zdCBvcmlnaW5hbEZvcm1hdCA9IGZpbGUudHlwZTtcbiAgY29uc3QgeyB3aWR0aCB9ID0gYXdhaXQgZ2V0SW1hZ2VEaW1lbnNpb25zKGZpbGUpO1xuICBjb25zdCBuZWVkc1Jlc2l6aW5nID0gd2lkdGggPiBtYXhXaWR0aDtcblxuICBjb25zdCB0YXJnZXRGb3JtYXRzID0gW1xuICAgIHsgZm9ybWF0OiAnaW1hZ2UvanBlZycsIGxhYmVsOiAnSlBFRycgfSxcbiAgICB7IGZvcm1hdDogJ2ltYWdlL3dlYnAnLCBsYWJlbDogJ1dlYlAnIH0sXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS9wbmcnLCBsYWJlbDogJ1BORycgfVxuICBdO1xuXG4gIGNvbnN0IHByb2Nlc3NpbmdQcm9taXNlcyA9IHRhcmdldEZvcm1hdHMubWFwKHRhcmdldCA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZpbGVUeXBlOiB0YXJnZXQuZm9ybWF0LFxuICAgICAgbWF4V2lkdGg6IG5lZWRzUmVzaXppbmcgPyBtYXhXaWR0aCA6IHVuZGVmaW5lZCxcbiAgICAgIHF1YWxpdHk6IDAuOTksIFxuICAgICAgbmVlZHNSZXNpemluZzogbmVlZHNSZXNpemluZyxcbiAgICB9O1xuICAgIHJldHVybiBwcm9jZXNzSW1hZ2UoZmlsZSwgb3B0aW9ucyk7XG4gIH0pO1xuXG4gIGNvbnN0IHNldHRsZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKHByb2Nlc3NpbmdQcm9taXNlcyk7XG5cbiAgY29uc3Qgc3VjY2Vzc2Z1bFJlc3VsdHMgPSBzZXR0bGVkUmVzdWx0c1xuICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKVxuICAgIC5tYXAocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IG5ld0ZpbGUgPSByZXN1bHQudmFsdWU7XG4gICAgICBjb25zdCByZWR1Y3Rpb24gPSAoKG9yaWdpbmFsU2l6ZSAtIG5ld0ZpbGUuc2l6ZSkgLyBvcmlnaW5hbFNpemUpICogMTAwO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZTogbmV3RmlsZSxcbiAgICAgICAgZm9ybWF0OiBuZXdGaWxlLnR5cGUsXG4gICAgICAgIGxhYmVsOiBgJHt0YXJnZXRGb3JtYXRzLmZpbmQoZiA9PiBmLmZvcm1hdCA9PT0gbmV3RmlsZS50eXBlKT8ubGFiZWx9ICR7bmV3RmlsZS50eXBlID09PSBvcmlnaW5hbEZvcm1hdCA/ICdyZXNpemVkJyA6ICcnfWAgfHwgJ1Vua25vd24nLFxuICAgICAgICBzaXplOiBuZXdGaWxlLnNpemUsXG4gICAgICAgIHJlZHVjdGlvbjogcmVkdWN0aW9uLFxuICAgICAgICBpc09yaWdpbmFsRm9ybWF0OiBuZXdGaWxlLnR5cGUgPT09IG9yaWdpbmFsRm9ybWF0LFxuICAgICAgfTtcbiAgICB9KTtcblxuICBzZXR0bGVkUmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihyZXN1bHQucmVhc29uKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzID0gc3VjY2Vzc2Z1bFJlc3VsdHMubWFwKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3NpbVNjb3JlID0gYXdhaXQgc3NpbVJlc3VsdChmaWxlLCByZXN1bHQuZmlsZSk7XG4gICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHNzaW1SZXN1bHQ6IHNzaW1TY29yZSB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgY2FsY3VsYXRlIFNTSU0gZm9yICR7cmVzdWx0LmxhYmVsfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4geyAuLi5yZXN1bHQsIHNzaW1SZXN1bHQ6ICdFcnJvcicgfTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGZpbmFsUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzKTtcbiAgcmV0dXJuIGZpbmFsUmVzdWx0cztcbn07Il0sIm5hbWVzIjpbIlBpY2EiLCJzc2ltUmVzdWx0IiwicGljYSIsImdldEltYWdlRGltZW5zaW9ucyIsImZpbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJVUkwiLCJyZXZva2VPYmplY3RVUkwiLCJzcmMiLCJvbmVycm9yIiwiZXJyIiwiY3JlYXRlT2JqZWN0VVJMIiwicHJvY2Vzc0ltYWdlIiwib3B0aW9ucyIsIm5lZWRzUmVzaXppbmciLCJmaWxlVHlwZSIsInR5cGUiLCJzb3VyY2VJbWFnZSIsInNvdXJjZVVybCIsImRlc3RDYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0YXJnZXRXaWR0aCIsInRhcmdldEhlaWdodCIsIm1heFdpZHRoIiwiYXNwZWN0UmF0aW8iLCJyZXNpemUiLCJhbHBoYSIsInVuc2hhcnBBbW91bnQiLCJ1bnNoYXJwUmFkaXVzIiwidW5zaGFycFRocmVzaG9sZCIsIm91dHB1dFF1YWxpdHkiLCJxdWFsaXR5IiwidW5kZWZpbmVkIiwiYmxvYiIsInRvQmxvYiIsIkZpbGUiLCJuYW1lIiwiZXJyb3IiLCJjb25zb2xlIiwiRXJyb3IiLCJtZXNzYWdlIiwiZ2VuZXJhdGVJbWFnZVByZXZpZXdzV2l0aFF1YWxpdHkiLCJzdGFydHNXaXRoIiwib3JpZ2luYWxTaXplIiwic2l6ZSIsIm9yaWdpbmFsRm9ybWF0IiwidGFyZ2V0Rm9ybWF0cyIsImZvcm1hdCIsImxhYmVsIiwicHJvY2Vzc2luZ1Byb21pc2VzIiwibWFwIiwidGFyZ2V0Iiwic2V0dGxlZFJlc3VsdHMiLCJhbGxTZXR0bGVkIiwic3VjY2Vzc2Z1bFJlc3VsdHMiLCJmaWx0ZXIiLCJyZXN1bHQiLCJzdGF0dXMiLCJuZXdGaWxlIiwidmFsdWUiLCJyZWR1Y3Rpb24iLCJmaW5kIiwiZiIsImlzT3JpZ2luYWxGb3JtYXQiLCJmb3JFYWNoIiwid2FybiIsInJlYXNvbiIsInJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzIiwic3NpbVNjb3JlIiwiZmluYWxSZXN1bHRzIiwiYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ })

});