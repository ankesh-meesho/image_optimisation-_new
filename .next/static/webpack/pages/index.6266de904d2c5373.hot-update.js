"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        if (!options.needsResizing && options.fileType === file.type) {\n            return file;\n        }\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99,\n            needsResizing: needsResizing\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat,\n            original\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy91dGlscy9pbWFnZVByb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdCO0FBQ2tCO0FBRTFDLE1BQU1FLE9BQU8sSUFBSUYsNkNBQUlBO0FBRXJCLE1BQU1HLHFCQUFxQixDQUFDQztJQUMxQixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsTUFBTUMsTUFBTSxJQUFJQztRQUNoQkQsSUFBSUUsTUFBTSxHQUFHO1lBQ1hKLFFBQVE7Z0JBQUVLLE9BQU9ILElBQUlHLEtBQUs7Z0JBQUVDLFFBQVFKLElBQUlJLE1BQU07WUFBQztZQUMvQ0MsSUFBSUMsZUFBZSxDQUFDTixJQUFJTyxHQUFHO1FBQzdCO1FBQ0FQLElBQUlRLE9BQU8sR0FBRyxDQUFDQyxNQUFRVixPQUFPVTtRQUM5QlQsSUFBSU8sR0FBRyxHQUFHRixJQUFJSyxlQUFlLENBQUNkO0lBQ2hDO0FBQ0Y7QUFFQSxNQUFNZSxlQUFlLE9BQU9mLE1BQU1nQjtJQUNoQyxJQUFJO1FBQ0YsSUFBRyxDQUFDQSxRQUFRQyxhQUFhLElBQUlELFFBQVFFLFFBQVEsS0FBS2xCLEtBQUttQixJQUFJLEVBQUU7WUFDM0QsT0FBT25CO1FBQ1Q7UUFDQSxNQUFNb0IsY0FBYyxJQUFJZjtRQUN4QixNQUFNZ0IsWUFBWVosSUFBSUssZUFBZSxDQUFDZDtRQUN0Q29CLFlBQVlULEdBQUcsR0FBR1U7UUFDbEIsTUFBTSxJQUFJcEIsUUFBUSxDQUFDQyxTQUFTQztZQUN4QmlCLFlBQVlkLE1BQU0sR0FBR0o7WUFDckJrQixZQUFZUixPQUFPLEdBQUdUO1FBQzFCO1FBQ0FNLElBQUlDLGVBQWUsQ0FBQ1c7UUFFcEIsTUFBTUMsYUFBYUMsU0FBU0MsYUFBYSxDQUFDO1FBQzFDLElBQUlDLGNBQWNMLFlBQVliLEtBQUs7UUFDbkMsSUFBSW1CLGVBQWVOLFlBQVlaLE1BQU07UUFFckMsSUFBSVEsUUFBUVcsUUFBUSxJQUFJUCxZQUFZYixLQUFLLEdBQUdTLFFBQVFXLFFBQVEsRUFBRTtZQUMxRCxNQUFNQyxjQUFjUixZQUFZYixLQUFLLEdBQUdhLFlBQVlaLE1BQU07WUFDMURpQixjQUFjVCxRQUFRVyxRQUFRO1lBQzlCRCxlQUFlRCxjQUFjRztRQUNqQztRQUVBTixXQUFXZixLQUFLLEdBQUdrQjtRQUNuQkgsV0FBV2QsTUFBTSxHQUFHa0I7UUFFcEIsTUFBTTVCLEtBQUsrQixNQUFNLENBQUNULGFBQWFFLFlBQVk7WUFDekNRLE9BQU87WUFDUEMsZUFBZTtZQUNmQyxlQUFlO1lBQ2ZDLGtCQUFrQjtRQUNwQjtRQUVBLE1BQU1DLGdCQUFnQmxCLFFBQVFtQixPQUFPLEtBQUtDLFlBQVlwQixRQUFRbUIsT0FBTyxHQUFHO1FBRXhFLE1BQU1FLE9BQU8sTUFBTXZDLEtBQUt3QyxNQUFNLENBQUNoQixZQUFZTixRQUFRRSxRQUFRLEVBQUVnQjtRQUU3RCxPQUFPLElBQUlLLEtBQUs7WUFBQ0Y7U0FBSyxFQUFFckMsS0FBS3dDLElBQUksRUFBRTtZQUFFckIsTUFBTUgsUUFBUUUsUUFBUTtRQUFDO0lBQzlELEVBQUUsT0FBT3VCLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLHVCQUFzRCxPQUEvQnpCLFFBQVFFLFFBQVEsSUFBSSxZQUFXLGFBQVd1QjtRQUMvRSxNQUFNLElBQUlFLE1BQU0sd0JBQTZDRixPQUFyQnpCLFFBQVFFLFFBQVEsRUFBQyxNQUFrQixPQUFkdUIsTUFBTUcsT0FBTztJQUM1RTtBQUNGO0FBRU8sTUFBTUMsbUNBQW1DLE9BQU83QztRQUFNLEVBQUUyQixRQUFRLEVBQUU7SUFDdkUsSUFBSSxDQUFDM0IsUUFBUSxDQUFDQSxLQUFLbUIsSUFBSSxDQUFDMkIsVUFBVSxDQUFDLFdBQVc7UUFDNUMsTUFBTSxJQUFJSCxNQUFNO0lBQ2xCO0lBRUEsTUFBTUksZUFBZS9DLEtBQUtnRCxJQUFJO0lBQzlCLE1BQU1DLGlCQUFpQmpELEtBQUttQixJQUFJO0lBQ2hDLE1BQU0sRUFBRVosS0FBSyxFQUFFLEdBQUcsTUFBTVIsbUJBQW1CQztJQUMzQyxNQUFNaUIsZ0JBQWdCVixRQUFRb0I7SUFFOUIsTUFBTXVCLGdCQUFnQjtRQUNwQjtZQUFFQyxRQUFRO1lBQWNDLE9BQU87UUFBTztRQUN0QztZQUFFRCxRQUFRO1lBQWNDLE9BQU87UUFBTztRQUN0QztZQUFFRCxRQUFRO1lBQWFDLE9BQU87UUFBTTtLQUNyQztJQUVELE1BQU1DLHFCQUFxQkgsY0FBY0ksR0FBRyxDQUFDQyxDQUFBQTtRQUMzQyxNQUFNdkMsVUFBVTtZQUNkRSxVQUFVcUMsT0FBT0osTUFBTTtZQUN2QnhCLFVBQVVWLGdCQUFnQlUsV0FBV1M7WUFDckNELFNBQVM7WUFDVGxCLGVBQWVBO1FBQ2pCO1FBQ0EsT0FBT0YsYUFBYWYsTUFBTWdCO0lBQzVCO0lBRUEsTUFBTXdDLGlCQUFpQixNQUFNdkQsUUFBUXdELFVBQVUsQ0FBQ0o7SUFFaEQsTUFBTUssb0JBQW9CRixlQUN2QkcsTUFBTSxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPQyxNQUFNLEtBQUssYUFDbkNQLEdBQUcsQ0FBQ00sQ0FBQUE7WUFNU1Y7UUFMWixNQUFNWSxVQUFVRixPQUFPRyxLQUFLO1FBQzVCLE1BQU1DLFlBQVksQ0FBRWpCLGVBQWVlLFFBQVFkLElBQUksSUFBSUQsZUFBZ0I7UUFDbkUsT0FBTztZQUNML0MsTUFBTThEO1lBQ05YLFFBQVFXLFFBQVEzQyxJQUFJO1lBQ3BCaUMsT0FBTyxHQUFnRVUsUUFBN0RaLHNCQUFBQSxjQUFjZSxJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVmLE1BQU0sS0FBS1csUUFBUTNDLElBQUksZUFBakQrQiwwQ0FBQUEsb0JBQW9ERSxLQUFLLEVBQUMsS0FBb0QsT0FBakRVLFFBQVEzQyxJQUFJLEtBQUs4QixpQkFBaUIsWUFBWSxPQUFRO1lBQzdIRCxNQUFNYyxRQUFRZCxJQUFJO1lBQ2xCZ0IsV0FBV0E7WUFDWEcsa0JBQWtCTCxRQUFRM0MsSUFBSSxLQUFLOEI7WUFDbkNtQjtRQUNGO0lBQ0Y7SUFFRlosZUFBZWEsT0FBTyxDQUFDVCxDQUFBQTtRQUNyQixJQUFJQSxPQUFPQyxNQUFNLEtBQUssWUFBWTtZQUNoQ25CLFFBQVE0QixJQUFJLENBQUNWLE9BQU9XLE1BQU07UUFDNUI7SUFDRjtJQUVBLE1BQU1DLDZCQUE2QmQsa0JBQWtCSixHQUFHLENBQUMsT0FBT007UUFDOUQsSUFBSTtZQUNGLE1BQU1hLFlBQVksTUFBTTVFLHVEQUFVQSxDQUFDRyxNQUFNNEQsT0FBTzVELElBQUk7WUFDcEQsT0FBTztnQkFBRSxHQUFHNEQsTUFBTTtnQkFBRS9ELFlBQVk0RTtZQUFVO1FBQzVDLEVBQUUsT0FBT2hDLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUE2QyxPQUFibUIsT0FBT1IsS0FBSyxFQUFDLE1BQUlYO1lBQy9ELE9BQU87Z0JBQUUsR0FBR21CLE1BQU07Z0JBQUUvRCxZQUFZO1lBQVE7UUFDMUM7SUFDRjtJQUVBLE1BQU02RSxlQUFlLE1BQU16RSxRQUFRMEUsR0FBRyxDQUFDSDtJQUN2QyxPQUFPRTtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvaW1hZ2VQcm9jZXNzb3IuanM/ZDI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGljYSBmcm9tICdwaWNhJztcbmltcG9ydCB7IHNzaW1SZXN1bHQgfSBmcm9tICcuL3NzaW1SZXN1bHQnO1xuXG5jb25zdCBwaWNhID0gbmV3IFBpY2EoKTtcblxuY29uc3QgZ2V0SW1hZ2VEaW1lbnNpb25zID0gKGZpbGUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBpbWcud2lkdGgsIGhlaWdodDogaW1nLmhlaWdodCB9KTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IChlcnIpID0+IHJlamVjdChlcnIpO1xuICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn07XG5cbmNvbnN0IHByb2Nlc3NJbWFnZSA9IGFzeW5jIChmaWxlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYoIW9wdGlvbnMubmVlZHNSZXNpemluZyAmJiBvcHRpb25zLmZpbGVUeXBlID09PSBmaWxlLnR5cGUpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHNvdXJjZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgc291cmNlSW1hZ2Uuc3JjID0gc291cmNlVXJsO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc291cmNlSW1hZ2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc291cmNlSW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVybCk7XG5cbiAgICBjb25zdCBkZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgbGV0IHRhcmdldFdpZHRoID0gc291cmNlSW1hZ2Uud2lkdGg7XG4gICAgbGV0IHRhcmdldEhlaWdodCA9IHNvdXJjZUltYWdlLmhlaWdodDtcblxuICAgIGlmIChvcHRpb25zLm1heFdpZHRoICYmIHNvdXJjZUltYWdlLndpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHNvdXJjZUltYWdlLndpZHRoIC8gc291cmNlSW1hZ2UuaGVpZ2h0O1xuICAgICAgICB0YXJnZXRXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGg7XG4gICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIFxuICAgIGRlc3RDYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICBkZXN0Q2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICBcbiAgICBhd2FpdCBwaWNhLnJlc2l6ZShzb3VyY2VJbWFnZSwgZGVzdENhbnZhcywge1xuICAgICAgYWxwaGE6IHRydWUsXG4gICAgICB1bnNoYXJwQW1vdW50OiAxNjAsXG4gICAgICB1bnNoYXJwUmFkaXVzOiAwLjYsXG4gICAgICB1bnNoYXJwVGhyZXNob2xkOiAxLFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IG91dHB1dFF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhbGl0eSA6IDE7XG5cbiAgICBjb25zdCBibG9iID0gYXdhaXQgcGljYS50b0Jsb2IoZGVzdENhbnZhcywgb3B0aW9ucy5maWxlVHlwZSwgb3V0cHV0UXVhbGl0eSk7XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2JdLCBmaWxlLm5hbWUsIHsgdHlwZTogb3B0aW9ucy5maWxlVHlwZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHRvICR7b3B0aW9ucy5maWxlVHlwZSB8fCAnb3JpZ2luYWwnfSBmb3JtYXQ6YCwgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbnZlcnQgdG8gJHtvcHRpb25zLmZpbGVUeXBlfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJbWFnZVByZXZpZXdzV2l0aFF1YWxpdHkgPSBhc3luYyAoZmlsZSwgeyBtYXhXaWR0aCB9KSA9PiB7XG4gIGlmICghZmlsZSB8fCAhZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpbGUgdHlwZS4nKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgY29uc3Qgb3JpZ2luYWxGb3JtYXQgPSBmaWxlLnR5cGU7XG4gIGNvbnN0IHsgd2lkdGggfSA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhmaWxlKTtcbiAgY29uc3QgbmVlZHNSZXNpemluZyA9IHdpZHRoID4gbWF4V2lkdGg7XG5cbiAgY29uc3QgdGFyZ2V0Rm9ybWF0cyA9IFtcbiAgICB7IGZvcm1hdDogJ2ltYWdlL2pwZWcnLCBsYWJlbDogJ0pQRUcnIH0sXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS93ZWJwJywgbGFiZWw6ICdXZWJQJyB9LFxuICAgIHsgZm9ybWF0OiAnaW1hZ2UvcG5nJywgbGFiZWw6ICdQTkcnIH1cbiAgXTtcblxuICBjb25zdCBwcm9jZXNzaW5nUHJvbWlzZXMgPSB0YXJnZXRGb3JtYXRzLm1hcCh0YXJnZXQgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmaWxlVHlwZTogdGFyZ2V0LmZvcm1hdCxcbiAgICAgIG1heFdpZHRoOiBuZWVkc1Jlc2l6aW5nID8gbWF4V2lkdGggOiB1bmRlZmluZWQsXG4gICAgICBxdWFsaXR5OiAwLjk5LCBcbiAgICAgIG5lZWRzUmVzaXppbmc6IG5lZWRzUmVzaXppbmcsXG4gICAgfTtcbiAgICByZXR1cm4gcHJvY2Vzc0ltYWdlKGZpbGUsIG9wdGlvbnMpO1xuICB9KTtcblxuICBjb25zdCBzZXR0bGVkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9jZXNzaW5nUHJvbWlzZXMpO1xuXG4gIGNvbnN0IHN1Y2Nlc3NmdWxSZXN1bHRzID0gc2V0dGxlZFJlc3VsdHNcbiAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJylcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBuZXdGaWxlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgY29uc3QgcmVkdWN0aW9uID0gKChvcmlnaW5hbFNpemUgLSBuZXdGaWxlLnNpemUpIC8gb3JpZ2luYWxTaXplKSAqIDEwMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGU6IG5ld0ZpbGUsXG4gICAgICAgIGZvcm1hdDogbmV3RmlsZS50eXBlLFxuICAgICAgICBsYWJlbDogYCR7dGFyZ2V0Rm9ybWF0cy5maW5kKGYgPT4gZi5mb3JtYXQgPT09IG5ld0ZpbGUudHlwZSk/LmxhYmVsfSAke25ld0ZpbGUudHlwZSA9PT0gb3JpZ2luYWxGb3JtYXQgPyAncmVzaXplZCcgOiAnJ31gIHx8ICdVbmtub3duJyxcbiAgICAgICAgc2l6ZTogbmV3RmlsZS5zaXplLFxuICAgICAgICByZWR1Y3Rpb246IHJlZHVjdGlvbixcbiAgICAgICAgaXNPcmlnaW5hbEZvcm1hdDogbmV3RmlsZS50eXBlID09PSBvcmlnaW5hbEZvcm1hdCxcbiAgICAgICAgb3JpZ2luYWxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgc2V0dGxlZFJlc3VsdHMuZm9yRWFjaChyZXN1bHQgPT4ge1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4ocmVzdWx0LnJlYXNvbik7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCByZXN1bHRzV2l0aFF1YWxpdHlQcm9taXNlcyA9IHN1Y2Nlc3NmdWxSZXN1bHRzLm1hcChhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNzaW1TY29yZSA9IGF3YWl0IHNzaW1SZXN1bHQoZmlsZSwgcmVzdWx0LmZpbGUpO1xuICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCBzc2ltUmVzdWx0OiBzc2ltU2NvcmUgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGNhbGN1bGF0ZSBTU0lNIGZvciAke3Jlc3VsdC5sYWJlbH06YCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCBzc2ltUmVzdWx0OiAnRXJyb3InIH07XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBmaW5hbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzV2l0aFF1YWxpdHlQcm9taXNlcyk7XG4gIHJldHVybiBmaW5hbFJlc3VsdHM7XG59OyJdLCJuYW1lcyI6WyJQaWNhIiwic3NpbVJlc3VsdCIsInBpY2EiLCJnZXRJbWFnZURpbWVuc2lvbnMiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0IiwiVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwic3JjIiwib25lcnJvciIsImVyciIsImNyZWF0ZU9iamVjdFVSTCIsInByb2Nlc3NJbWFnZSIsIm9wdGlvbnMiLCJuZWVkc1Jlc2l6aW5nIiwiZmlsZVR5cGUiLCJ0eXBlIiwic291cmNlSW1hZ2UiLCJzb3VyY2VVcmwiLCJkZXN0Q2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidGFyZ2V0V2lkdGgiLCJ0YXJnZXRIZWlnaHQiLCJtYXhXaWR0aCIsImFzcGVjdFJhdGlvIiwicmVzaXplIiwiYWxwaGEiLCJ1bnNoYXJwQW1vdW50IiwidW5zaGFycFJhZGl1cyIsInVuc2hhcnBUaHJlc2hvbGQiLCJvdXRwdXRRdWFsaXR5IiwicXVhbGl0eSIsInVuZGVmaW5lZCIsImJsb2IiLCJ0b0Jsb2IiLCJGaWxlIiwibmFtZSIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwibWVzc2FnZSIsImdlbmVyYXRlSW1hZ2VQcmV2aWV3c1dpdGhRdWFsaXR5Iiwic3RhcnRzV2l0aCIsIm9yaWdpbmFsU2l6ZSIsInNpemUiLCJvcmlnaW5hbEZvcm1hdCIsInRhcmdldEZvcm1hdHMiLCJmb3JtYXQiLCJsYWJlbCIsInByb2Nlc3NpbmdQcm9taXNlcyIsIm1hcCIsInRhcmdldCIsInNldHRsZWRSZXN1bHRzIiwiYWxsU2V0dGxlZCIsInN1Y2Nlc3NmdWxSZXN1bHRzIiwiZmlsdGVyIiwicmVzdWx0Iiwic3RhdHVzIiwibmV3RmlsZSIsInZhbHVlIiwicmVkdWN0aW9uIiwiZmluZCIsImYiLCJpc09yaWdpbmFsRm9ybWF0Iiwib3JpZ2luYWwiLCJmb3JFYWNoIiwid2FybiIsInJlYXNvbiIsInJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzIiwic3NpbVNjb3JlIiwiZmluYWxSZXN1bHRzIiwiYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ })

});