/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fankeshgupta%2FDocuments%2Fimage_optimisation_new%2Fsrc%2Fpages%2Findex.js&page=%2F!":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fankeshgupta%2FDocuments%2Fimage_optimisation_new%2Fsrc%2Fpages%2Findex.js&page=%2F! ***!
  \**************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.js */ \"./src/pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmFua2VzaGd1cHRhJTJGRG9jdW1lbnRzJTJGaW1hZ2Vfb3B0aW1pc2F0aW9uX25ldyUyRnNyYyUyRnBhZ2VzJTJGaW5kZXguanMmcGFnZT0lMkYhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0RBQXNCO0FBQzdDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz85ZDQxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fankeshgupta%2FDocuments%2Fimage_optimisation_new%2Fsrc%2Fpages%2Findex.js&page=%2F!\n"));

/***/ }),

/***/ "./src/components/ImageCompressor.jsx":
/*!********************************************!*\
  !*** ./src/components/ImageCompressor.jsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Preview__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Preview */ \"./src/components/Preview.jsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_imageProcessor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/imageProcessor */ \"./src/components/utils/imageProcessor.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n // Import the new function\nconst PreviewCard = (param)=>{\n    let { result } = param;\n    _s();\n    const [imageUrl, setImageUrl] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!result.file) return;\n        const url = URL.createObjectURL(result.file);\n        setImageUrl(url);\n        return ()=>URL.revokeObjectURL(url);\n    }, [\n        result.file\n    ]);\n    var _result_label;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            border: \"1px solid #ccc\",\n            textAlign: \"center\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: imageUrl,\n                alt: result.label,\n                style: {\n                    width: \"50vw\",\n                    objectFit: \"contain\"\n                },\n                caption: result.label\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 15,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                children: (_result_label = result.label) !== null && _result_label !== void 0 ? _result_label : \"Original\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 16,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n        lineNumber: 14,\n        columnNumber: 5\n    }, undefined);\n};\n_s(PreviewCard, \"KjMZRZCO4mLZUizaO9kQ3A3TUQU=\");\n_c = PreviewCard;\nconst ResultCard = (param)=>{\n    let { result, onSelect } = param;\n    _s1();\n    const [imageUrl, setImageUrl] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!result.file) return;\n        const url = URL.createObjectURL(result.file);\n        setImageUrl(url);\n        // Cleanup function to revoke the URL when the component unmounts\n        return ()=>URL.revokeObjectURL(url);\n    }, [\n        result.file\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            border: \"1px solid #ccc\",\n            padding: \"10px\",\n            borderRadius: \"8px\",\n            textAlign: \"center\"\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                children: result.label\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, undefined),\n            imageUrl && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: imageUrl,\n                alt: result.label,\n                style: {\n                    maxWidth: \"100%\",\n                    height: \"120px\",\n                    objectFit: \"contain\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 36,\n                columnNumber: 20\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    margin: \"8px 0\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                    children: [\n                        (result.size / 1024).toFixed(1),\n                        \" KB\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                    lineNumber: 38,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 37,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    color: result.reduction > 0 ? \"green\" : \"red\",\n                    margin: \"8px 0\",\n                    fontWeight: \"bold\"\n                },\n                children: [\n                    result.reduction.toFixed(0),\n                    \"% smaller\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    margin: \"8px 0\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        children: \"Quality Score (SSIM):\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 44,\n                        columnNumber: 9\n                    }, undefined),\n                    typeof result.ssimResult === \"number\" ? result.ssimResult.toFixed(4) : result.ssimResult\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 43,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>onSelect(result.file),\n                children: \"Use this version\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 47,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n        lineNumber: 34,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ResultCard, \"KjMZRZCO4mLZUizaO9kQ3A3TUQU=\");\n_c1 = ResultCard;\nfunction ImageUploader() {\n    var _results_;\n    _s2();\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [feedback, setFeedback] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"Select an image to see conversion options.\");\n    const [results, setResults] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [originalInfo, setOriginalInfo] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [maxWidth, setMaxWidth] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(1200);\n    const [advancedMode, setAdvancedMode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (!(originalInfo === null || originalInfo === void 0 ? void 0 : originalInfo.file)) return;\n        async function fetchPreviews() {\n            try {\n                const previews = await (0,_utils_imageProcessor__WEBPACK_IMPORTED_MODULE_3__.generateImagePreviewsWithQuality)(originalInfo.file, {\n                    maxWidth: maxWidth\n                });\n                setResults(previews);\n            } catch (error) {\n                console.error(\"Error generating previews:\", error);\n            }\n        }\n        fetchPreviews();\n    }, [\n        originalInfo === null || originalInfo === void 0 ? void 0 : originalInfo.file,\n        maxWidth\n    ]);\n    const handleMaxWidthChange = (event)=>{\n        setMaxWidth(event.target.value);\n    };\n    const handleFileChange = async (event)=>{\n        const file = event.target.files[0];\n        if (!file) return;\n        setIsProcessing(true);\n        setFeedback(\"Generating previews for all formats...\");\n        setResults([]);\n        setOriginalInfo({\n            name: file.name,\n            size: file.size,\n            file: file\n        });\n        try {\n            const previews = await (0,_utils_imageProcessor__WEBPACK_IMPORTED_MODULE_3__.generateImagePreviewsWithQuality)(file, {\n                maxWidth: maxWidth\n            });\n            setResults(previews);\n            if (previews.length === 0) {\n                setFeedback(\"Could not generate any previews. Check browser support (e.g., for AVIF).\");\n            } else {\n                setFeedback(\"Previews generated successfully. Choose a version to use.\");\n            }\n        } catch (error) {\n            setFeedback(\"An error occurred: \".concat(error.message));\n            console.error(error);\n        } finally{\n            setIsProcessing(false);\n        }\n    };\n    const handleSelectVersion = (file)=>{\n        // Create a download link\n        const link = document.createElement(\"a\");\n        link.href = URL.createObjectURL(file);\n        // Set the download filename with format and size info\n        const format = file.type.split(\"/\")[1];\n        const size = (file.size / 1024).toFixed(1);\n        link.download = \"compressed_\".concat(format, \"_\").concat(size, \"KB.\").concat(format);\n        // Trigger download\n        document.body.appendChild(link);\n        link.click();\n        // Clean up\n        document.body.removeChild(link);\n        URL.revokeObjectURL(link.href);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                children: \"Select Image to Generate Previews\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 126,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Your image will be resized (if width >  ) and converted to multiple formats.\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 127,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                children: [\n                    \"Original Width: \",\n                    (_results_ = results[0]) === null || _results_ === void 0 ? void 0 : _results_.originalWidth\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 128,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"number\",\n                value: maxWidth,\n                onChange: handleMaxWidthChange\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 129,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"file\",\n                accept: \"image/*\",\n                onChange: handleFileChange,\n                disabled: isProcessing\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 131,\n                columnNumber: 7\n            }, this),\n            isProcessing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                style: {\n                    fontWeight: \"bold\"\n                },\n                children: \"Processing, please wait...\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 133,\n                columnNumber: 24\n            }, this),\n            feedback && !isProcessing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: feedback\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 134,\n                columnNumber: 37\n            }, this),\n            originalInfo && !isProcessing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: [\n                    \"Original: \",\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                        children: originalInfo.name\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 137,\n                        columnNumber: 22\n                    }, this),\n                    \" (\",\n                    (originalInfo.size / 1024).toFixed(1),\n                    \" KB)\"\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 137,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: ()=>setAdvancedMode(!advancedMode),\n                children: \"Toggle Advanced Mode\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 139,\n                columnNumber: 7\n            }, this),\n            advancedMode && results.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>setAdvancedMode(false),\n                        children: \"X\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 142,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Preview__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                        beforeImage: originalInfo,\n                        afterImage: results.find((result)=>result.isOriginalFormat),\n                        width: maxWidth\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 143,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 141,\n                columnNumber: 9\n            }, this),\n            results.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"grid\",\n                    gridTemplateColumns: \"repeat(auto-fit, minmax(180px, 1fr))\",\n                    gap: \"15px\",\n                    marginTop: \"20px\"\n                },\n                children: results.map((result)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ResultCard, {\n                        result: result,\n                        onSelect: handleSelectVersion\n                    }, result.format, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 151,\n                        columnNumber: 13\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 149,\n                columnNumber: 9\n            }, this),\n            results.length > 0 && results.some((result)=>result.isOriginalFormat) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: \"flex\"\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PreviewCard, {\n                        result: originalInfo\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                        lineNumber: 158,\n                        columnNumber: 11\n                    }, this),\n                    results.map((result)=>result.isOriginalFormat && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PreviewCard, {\n                            result: result\n                        }, void 0, false, {\n                            fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                            lineNumber: 160,\n                            columnNumber: 40\n                        }, this))\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n                lineNumber: 157,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/ImageCompressor.jsx\",\n        lineNumber: 125,\n        columnNumber: 5\n    }, this);\n}\n_s2(ImageUploader, \"K32lidRh8qDifak6h1QxstKylx8=\");\n_c2 = ImageUploader;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageUploader);\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"PreviewCard\");\n$RefreshReg$(_c1, \"ResultCard\");\n$RefreshReg$(_c2, \"ImageUploader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVVBLE9BQU9zRixnQkFBZ0IsbUJBQ3BFLDhEQUFDOUU7Z0JBQUlDLE9BQU87b0JBQUVDLFNBQVM7Z0JBQU07O2tDQUMzQiw4REFBQ1g7d0JBQVlDLFFBQVE4Qzs7Ozs7O29CQUNwQk4sUUFBUWtELEdBQUcsQ0FBQyxDQUFDMUYsU0FDWkEsT0FBT3NGLGdCQUFnQixrQkFBSSw4REFBQ3ZGOzRCQUFZQyxRQUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTzVEO0lBbkhTdUM7TUFBQUE7QUFxSFQsK0RBQWVBLGFBQWFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSW1hZ2VDb21wcmVzc29yLmpzeD81Njk5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQcmV2aWV3IGZyb20gJy4vUHJldmlldyc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdlbmVyYXRlSW1hZ2VQcmV2aWV3c1dpdGhRdWFsaXR5IH0gZnJvbSAnLi91dGlscy9pbWFnZVByb2Nlc3Nvcic7IC8vIEltcG9ydCB0aGUgbmV3IGZ1bmN0aW9uXG5jb25zdCBQcmV2aWV3Q2FyZCA9ICgge3Jlc3VsdH0gKSA9PiB7XG4gIGNvbnN0IFtpbWFnZVVybCwgc2V0SW1hZ2VVcmxdID0gdXNlU3RhdGUoJycpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZXN1bHQuZmlsZSkgcmV0dXJuO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwocmVzdWx0LmZpbGUpO1xuICAgIHNldEltYWdlVXJsKHVybCk7XG4gICAgcmV0dXJuICgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgfSwgW3Jlc3VsdC5maWxlXSk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiAnZmxleCcsIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLCBib3JkZXI6ICcxcHggc29saWQgI2NjYycsIHRleHRBbGlnbjogJ2NlbnRlcicgfX0+XG4gICAgICA8aW1nIHNyYz17aW1hZ2VVcmx9IGFsdD17cmVzdWx0LmxhYmVsfSBzdHlsZT17eyB3aWR0aDogJzUwdncnLCBvYmplY3RGaXQ6ICdjb250YWluJyB9fSBjYXB0aW9uPXtyZXN1bHQubGFiZWx9IC8+XG4gICAgICA8aDQ+e3Jlc3VsdC5sYWJlbD8/J09yaWdpbmFsJ308L2g0PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmNvbnN0IFJlc3VsdENhcmQgPSAoeyByZXN1bHQsIG9uU2VsZWN0IH0pID0+IHtcbiAgY29uc3QgW2ltYWdlVXJsLCBzZXRJbWFnZVVybF0gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJlc3VsdC5maWxlKSByZXR1cm47XG4gICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChyZXN1bHQuZmlsZSk7XG4gICAgc2V0SW1hZ2VVcmwodXJsKTtcblxuICAgIC8vIENsZWFudXAgZnVuY3Rpb24gdG8gcmV2b2tlIHRoZSBVUkwgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXG4gICAgcmV0dXJuICgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgfSwgW3Jlc3VsdC5maWxlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHN0eWxlPXt7IGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJywgcGFkZGluZzogJzEwcHgnLCBib3JkZXJSYWRpdXM6ICc4cHgnLCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PlxuICAgICAgPGg0PntyZXN1bHQubGFiZWx9PC9oND5cbiAgICAgIHtpbWFnZVVybCAmJiA8aW1nIHNyYz17aW1hZ2VVcmx9IGFsdD17cmVzdWx0LmxhYmVsfSBzdHlsZT17eyBtYXhXaWR0aDogJzEwMCUnLCBoZWlnaHQ6ICcxMjBweCcsIG9iamVjdEZpdDogJ2NvbnRhaW4nIH19IC8+fVxuICAgICAgPHAgc3R5bGU9e3sgbWFyZ2luOiAnOHB4IDAnIH19PlxuICAgICAgICA8c3Ryb25nPnsocmVzdWx0LnNpemUgLyAxMDI0KS50b0ZpeGVkKDEpfSBLQjwvc3Ryb25nPlxuICAgICAgPC9wPlxuICAgICAgPHAgc3R5bGU9e3sgY29sb3I6IHJlc3VsdC5yZWR1Y3Rpb24gPiAwID8gJ2dyZWVuJyA6ICdyZWQnLCBtYXJnaW46ICc4cHggMCcsIGZvbnRXZWlnaHQ6ICdib2xkJyB9fT5cbiAgICAgICAge3Jlc3VsdC5yZWR1Y3Rpb24udG9GaXhlZCgwKX0lIHNtYWxsZXJcbiAgICAgIDwvcD5cbiAgICAgIDxwIHN0eWxlPXt7IG1hcmdpbjogJzhweCAwJyB9fT5cbiAgICAgICAgPHN0cm9uZz5RdWFsaXR5IFNjb3JlIChTU0lNKTo8L3N0cm9uZz5cbiAgICAgICAge3R5cGVvZiByZXN1bHQuc3NpbVJlc3VsdCA9PT0gJ251bWJlcicgPyByZXN1bHQuc3NpbVJlc3VsdC50b0ZpeGVkKDQpIDogcmVzdWx0LnNzaW1SZXN1bHR9XG4gICAgICA8L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IG9uU2VsZWN0KHJlc3VsdC5maWxlKX0+VXNlIHRoaXMgdmVyc2lvbjwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZnVuY3Rpb24gSW1hZ2VVcGxvYWRlcigpIHtcbiAgY29uc3QgW2lzUHJvY2Vzc2luZywgc2V0SXNQcm9jZXNzaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ZlZWRiYWNrLCBzZXRGZWVkYmFja10gPSB1c2VTdGF0ZSgnU2VsZWN0IGFuIGltYWdlIHRvIHNlZSBjb252ZXJzaW9uIG9wdGlvbnMuJyk7XG4gIGNvbnN0IFtyZXN1bHRzLCBzZXRSZXN1bHRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW29yaWdpbmFsSW5mbywgc2V0T3JpZ2luYWxJbmZvXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbbWF4V2lkdGgsIHNldE1heFdpZHRoXSA9IHVzZVN0YXRlKDEyMDApO1xuICBjb25zdCBbYWR2YW5jZWRNb2RlLCBzZXRBZHZhbmNlZE1vZGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcmlnaW5hbEluZm8/LmZpbGUpIHJldHVybjtcbiAgXG4gICAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcmV2aWV3cygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXdzID0gYXdhaXQgZ2VuZXJhdGVJbWFnZVByZXZpZXdzV2l0aFF1YWxpdHkob3JpZ2luYWxJbmZvLmZpbGUsIHsgbWF4V2lkdGg6IG1heFdpZHRoIH0pO1xuICAgICAgICBzZXRSZXN1bHRzKHByZXZpZXdzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgcHJldmlld3M6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgZmV0Y2hQcmV2aWV3cygpO1xuICB9LCBbb3JpZ2luYWxJbmZvPy5maWxlLCBtYXhXaWR0aF0pO1xuXG5cbiAgY29uc3QgaGFuZGxlTWF4V2lkdGhDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBzZXRNYXhXaWR0aChldmVudC50YXJnZXQudmFsdWUpO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgIGNvbnN0IGZpbGUgPSBldmVudC50YXJnZXQuZmlsZXNbMF07XG4gICAgaWYgKCFmaWxlKSByZXR1cm47XG5cbiAgICBzZXRJc1Byb2Nlc3NpbmcodHJ1ZSk7XG4gICAgc2V0RmVlZGJhY2soJ0dlbmVyYXRpbmcgcHJldmlld3MgZm9yIGFsbCBmb3JtYXRzLi4uJyk7XG4gICAgc2V0UmVzdWx0cyhbXSk7XG4gICAgc2V0T3JpZ2luYWxJbmZvKHsgbmFtZTogZmlsZS5uYW1lLCBzaXplOiBmaWxlLnNpemUsIGZpbGU6IGZpbGUgfSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJldmlld3MgPSBhd2FpdCBnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eShmaWxlLCB7IG1heFdpZHRoOiBtYXhXaWR0aCB9KTtcbiAgICAgIHNldFJlc3VsdHMocHJldmlld3MpO1xuICAgICAgaWYgKHByZXZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRGZWVkYmFjaygnQ291bGQgbm90IGdlbmVyYXRlIGFueSBwcmV2aWV3cy4gQ2hlY2sgYnJvd3NlciBzdXBwb3J0IChlLmcuLCBmb3IgQVZJRikuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRGZWVkYmFjaygnUHJldmlld3MgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseS4gQ2hvb3NlIGEgdmVyc2lvbiB0byB1c2UuJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldEZlZWRiYWNrKGBBbiBlcnJvciBvY2N1cnJlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNlbGVjdFZlcnNpb24gPSAoZmlsZSkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIGRvd25sb2FkIGxpbmtcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgXG4gICAgLy8gU2V0IHRoZSBkb3dubG9hZCBmaWxlbmFtZSB3aXRoIGZvcm1hdCBhbmQgc2l6ZSBpbmZvXG4gICAgY29uc3QgZm9ybWF0ID0gZmlsZS50eXBlLnNwbGl0KCcvJylbMV07XG4gICAgY29uc3Qgc2l6ZSA9IChmaWxlLnNpemUgLyAxMDI0KS50b0ZpeGVkKDEpO1xuICAgIGxpbmsuZG93bmxvYWQgPSBgY29tcHJlc3NlZF8ke2Zvcm1hdH1fJHtzaXplfUtCLiR7Zm9ybWF0fWA7XG4gICAgXG4gICAgLy8gVHJpZ2dlciBkb3dubG9hZFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgbGluay5jbGljaygpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGxpbmsuaHJlZik7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPGgzPlNlbGVjdCBJbWFnZSB0byBHZW5lcmF0ZSBQcmV2aWV3czwvaDM+XG4gICAgICA8cD5Zb3VyIGltYWdlIHdpbGwgYmUgcmVzaXplZCAoaWYgd2lkdGggJmd0OyAgKSBhbmQgY29udmVydGVkIHRvIG11bHRpcGxlIGZvcm1hdHMuPC9wPlxuICAgICAgPGgzPk9yaWdpbmFsIFdpZHRoOiB7cmVzdWx0c1swXT8ub3JpZ2luYWxXaWR0aH08L2gzPlxuICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17bWF4V2lkdGh9IG9uQ2hhbmdlPXtoYW5kbGVNYXhXaWR0aENoYW5nZX0gLz5cbiAgICAgIFxuICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgYWNjZXB0PVwiaW1hZ2UvKlwiIG9uQ2hhbmdlPXtoYW5kbGVGaWxlQ2hhbmdlfSBkaXNhYmxlZD17aXNQcm9jZXNzaW5nfSAvPlxuICAgICAgXG4gICAgICB7aXNQcm9jZXNzaW5nICYmIDxwIHN0eWxlPXt7Zm9udFdlaWdodDogJ2JvbGQnfX0+UHJvY2Vzc2luZywgcGxlYXNlIHdhaXQuLi48L3A+fVxuICAgICAge2ZlZWRiYWNrICYmICFpc1Byb2Nlc3NpbmcgJiYgPHA+e2ZlZWRiYWNrfTwvcD59XG5cbiAgICAgIHtvcmlnaW5hbEluZm8gJiYgIWlzUHJvY2Vzc2luZyAmJiAoXG4gICAgICAgIDxwPk9yaWdpbmFsOiA8c3Ryb25nPntvcmlnaW5hbEluZm8ubmFtZX08L3N0cm9uZz4gKHsob3JpZ2luYWxJbmZvLnNpemUgLyAxMDI0KS50b0ZpeGVkKDEpfSBLQik8L3A+XG4gICAgICApfVxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRBZHZhbmNlZE1vZGUoIWFkdmFuY2VkTW9kZSl9PlRvZ2dsZSBBZHZhbmNlZCBNb2RlPC9idXR0b24+XG4gICAgICB7YWR2YW5jZWRNb2RlICYmIHJlc3VsdHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRBZHZhbmNlZE1vZGUoZmFsc2UpfT5YPC9idXR0b24+XG4gICAgICAgICAgPFByZXZpZXcgYmVmb3JlSW1hZ2U9e29yaWdpbmFsSW5mb30gYWZ0ZXJJbWFnZT17cmVzdWx0cy5maW5kKHJlc3VsdCA9PiByZXN1bHQuaXNPcmlnaW5hbEZvcm1hdCl9IHdpZHRoPXttYXhXaWR0aH0gLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgKX1cblxuICAgICAge3Jlc3VsdHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2dyaWQnLCBncmlkVGVtcGxhdGVDb2x1bW5zOiAncmVwZWF0KGF1dG8tZml0LCBtaW5tYXgoMTgwcHgsIDFmcikpJywgZ2FwOiAnMTVweCcsIG1hcmdpblRvcDogJzIwcHgnIH19PlxuICAgICAgICAgIHtyZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoXG4gICAgICAgICAgICA8UmVzdWx0Q2FyZCBrZXk9e3Jlc3VsdC5mb3JtYXR9IHJlc3VsdD17cmVzdWx0fSBvblNlbGVjdD17aGFuZGxlU2VsZWN0VmVyc2lvbn0gLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7IHJlc3VsdHMubGVuZ3RoID4gMCAmJiByZXN1bHRzLnNvbWUocmVzdWx0ID0+IHJlc3VsdC5pc09yaWdpbmFsRm9ybWF0KSAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogJ2ZsZXgnfX0+XG4gICAgICAgICAgPFByZXZpZXdDYXJkIHJlc3VsdD17b3JpZ2luYWxJbmZvfSAvPlxuICAgICAgICAgIHtyZXN1bHRzLm1hcCgocmVzdWx0KSA9PiAoXG4gICAgICAgICAgICByZXN1bHQuaXNPcmlnaW5hbEZvcm1hdCAmJiA8UHJldmlld0NhcmQgcmVzdWx0PXtyZXN1bHR9IC8+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgIDwvZGl2PlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVVwbG9hZGVyOyJdLCJuYW1lcyI6WyJQcmV2aWV3IiwiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImdlbmVyYXRlSW1hZ2VQcmV2aWV3c1dpdGhRdWFsaXR5IiwiUHJldmlld0NhcmQiLCJyZXN1bHQiLCJpbWFnZVVybCIsInNldEltYWdlVXJsIiwiZmlsZSIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInJldm9rZU9iamVjdFVSTCIsImRpdiIsInN0eWxlIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJib3JkZXIiLCJ0ZXh0QWxpZ24iLCJpbWciLCJzcmMiLCJhbHQiLCJsYWJlbCIsIndpZHRoIiwib2JqZWN0Rml0IiwiY2FwdGlvbiIsImg0IiwiUmVzdWx0Q2FyZCIsIm9uU2VsZWN0IiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsIm1heFdpZHRoIiwiaGVpZ2h0IiwicCIsIm1hcmdpbiIsInN0cm9uZyIsInNpemUiLCJ0b0ZpeGVkIiwiY29sb3IiLCJyZWR1Y3Rpb24iLCJmb250V2VpZ2h0Iiwic3NpbVJlc3VsdCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJJbWFnZVVwbG9hZGVyIiwicmVzdWx0cyIsImlzUHJvY2Vzc2luZyIsInNldElzUHJvY2Vzc2luZyIsImZlZWRiYWNrIiwic2V0RmVlZGJhY2siLCJzZXRSZXN1bHRzIiwib3JpZ2luYWxJbmZvIiwic2V0T3JpZ2luYWxJbmZvIiwic2V0TWF4V2lkdGgiLCJhZHZhbmNlZE1vZGUiLCJzZXRBZHZhbmNlZE1vZGUiLCJmZXRjaFByZXZpZXdzIiwicHJldmlld3MiLCJlcnJvciIsImNvbnNvbGUiLCJoYW5kbGVNYXhXaWR0aENoYW5nZSIsImV2ZW50IiwidGFyZ2V0IiwidmFsdWUiLCJoYW5kbGVGaWxlQ2hhbmdlIiwiZmlsZXMiLCJuYW1lIiwibGVuZ3RoIiwibWVzc2FnZSIsImhhbmRsZVNlbGVjdFZlcnNpb24iLCJsaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImZvcm1hdCIsInR5cGUiLCJzcGxpdCIsImRvd25sb2FkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJyZW1vdmVDaGlsZCIsImgzIiwib3JpZ2luYWxXaWR0aCIsImlucHV0Iiwib25DaGFuZ2UiLCJhY2NlcHQiLCJkaXNhYmxlZCIsImJlZm9yZUltYWdlIiwiYWZ0ZXJJbWFnZSIsImZpbmQiLCJpc09yaWdpbmFsRm9ybWF0IiwiZ3JpZFRlbXBsYXRlQ29sdW1ucyIsImdhcCIsIm1hcmdpblRvcCIsIm1hcCIsInNvbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/ImageCompressor.jsx\n"));

/***/ }),

/***/ "./src/components/Preview.jsx":
/*!************************************!*\
  !*** ./src/components/Preview.jsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\n/**\n * ImageTogglePopup Component\n * Displays a \"before\" image and reveals an \"after\" image on press-and-hold.\n *\n * @param {object} props\n * @param {string} props.beforeImage - URL for the \"before\" image.\n * @param {string} props.afterImage - URL for the \"after\" image.\n */ const ImageTogglePopup = (param)=>{\n    let { beforeImage, afterImage, width } = param;\n    _s();\n    // State to track if the \"after\" image should be visible\n    console.log(beforeImage, afterImage);\n    const [isAfterVisible, setIsAfterVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // State to manage loading of images to prevent showing before they are ready\n    const [isBeforeLoaded, setIsBeforeLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isAfterLoaded, setIsAfterLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [beforeUrl, setBeforeUrl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [afterUrl, setAfterUrl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    // Preload images to ensure they are cached by the browser for a smooth transition\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!beforeImage || !afterImage) return;\n        const bURL = URL.createObjectURL(beforeImage.file);\n        const aURL = URL.createObjectURL(afterImage.file);\n        setBeforeUrl(bURL);\n        setAfterUrl(aURL);\n        return ()=>{\n            URL.revokeObjectURL(beforeImage.file);\n            URL.revokeObjectURL(afterImage.file);\n        };\n    }, [\n        beforeImage,\n        afterImage\n    ]);\n    // Event handlers to show the \"after\" image\n    const handleShowAfter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsAfterVisible(true);\n    }, []);\n    // Event handlers to show the \"before\" image\n    const handleShowBefore = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        setIsAfterVisible(false);\n    }, []);\n    const bothImagesLoaded = isBeforeLoaded && isAfterLoaded;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative w-full aspect-video rounded-xl shadow-2xl overflow-hidden select-none bg-gray-800 flex items-center justify-center\",\n        // Desktop events\n        onMouseDown: handleShowAfter,\n        onMouseUp: handleShowBefore,\n        onMouseLeave: handleShowBefore,\n        // Mobile events\n        onTouchStart: handleShowAfter,\n        onTouchEnd: handleShowBefore,\n        onTouchCancel: handleShowBefore,\n        children: [\n            !bothImagesLoaded && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-white\",\n                children: \"Loading images...\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/Preview.jsx\",\n                lineNumber: 61,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: beforeUrl,\n                alt: \"Before\",\n                style: {\n                    display: isAfterVisible ? \"none\" : \"block\",\n                    width: \"\".concat(width, \"px\"),\n                    height: \"auto\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/Preview.jsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: afterUrl,\n                alt: \"After\",\n                className: \"absolute inset-0 transition-opacity duration-300 ease-in-out \".concat(bothImagesLoaded ? \"opacity-100\" : \"opacity-0\"),\n                style: {\n                    display: isAfterVisible ? \"block\" : \"none\",\n                    width: \"\".concat(width, \"px\"),\n                    height: \"auto\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/Preview.jsx\",\n                lineNumber: 75,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 rounded-full text-white bg-black bg-opacity-50 backdrop-blur-sm transition-opacity duration-300 pointer-events-none \".concat(bothImagesLoaded ? \"opacity-100\" : \"opacity-0\"),\n                children: isAfterVisible ? \"After\" : \"Before (Hold to compare)\"\n            }, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/Preview.jsx\",\n                lineNumber: 86,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/components/Preview.jsx\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ImageTogglePopup, \"7Vq5xGoR2KHPIExfXs+gv+UOj+s=\");\n_c = ImageTogglePopup;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageTogglePopup);\nvar _c;\n$RefreshReg$(_c, \"ImageTogglePopup\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9QcmV2aWV3LmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdFO0FBRWhFOzs7Ozs7O0NBT0MsR0FDRCxNQUFNSSxtQkFBbUI7UUFBQyxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsS0FBSyxFQUFFOztJQUMxRCx3REFBd0Q7SUFDeERDLFFBQVFDLEdBQUcsQ0FBQ0osYUFBYUM7SUFFekIsTUFBTSxDQUFDSSxnQkFBZ0JDLGtCQUFrQixHQUFHViwrQ0FBUUEsQ0FBQztJQUVyRCw2RUFBNkU7SUFDN0UsTUFBTSxDQUFDVyxnQkFBZ0JDLGtCQUFrQixHQUFHWiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLENBQUNhLGVBQWVDLGlCQUFpQixHQUFHZCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNlLFdBQVdDLGFBQWEsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2lCLFVBQVVDLFlBQVksR0FBR2xCLCtDQUFRQSxDQUFDO0lBQ3pDLGtGQUFrRjtJQUNsRkMsZ0RBQVNBLENBQUM7UUFDUixJQUFHLENBQUNHLGVBQWUsQ0FBQ0MsWUFBWTtRQUNoQyxNQUFNYyxPQUFLQyxJQUFJQyxlQUFlLENBQUNqQixZQUFZa0IsSUFBSTtRQUMvQyxNQUFNQyxPQUFLSCxJQUFJQyxlQUFlLENBQUNoQixXQUFXaUIsSUFBSTtRQUM5Q04sYUFBYUc7UUFDYkQsWUFBWUs7UUFFWixPQUFPO1lBQ0xILElBQUlJLGVBQWUsQ0FBQ3BCLFlBQVlrQixJQUFJO1lBQ3BDRixJQUFJSSxlQUFlLENBQUNuQixXQUFXaUIsSUFBSTtRQUNyQztJQUNGLEdBQUc7UUFBQ2xCO1FBQWFDO0tBQVc7SUFFNUIsMkNBQTJDO0lBQzNDLE1BQU1vQixrQkFBa0J2QixrREFBV0EsQ0FBQztRQUNsQ1Esa0JBQWtCO0lBQ3BCLEdBQUcsRUFBRTtJQUVMLDRDQUE0QztJQUM1QyxNQUFNZ0IsbUJBQW1CeEIsa0RBQVdBLENBQUM7UUFDbkNRLGtCQUFrQjtJQUNwQixHQUFHLEVBQUU7SUFFTCxNQUFNaUIsbUJBQW1CaEIsa0JBQWtCRTtJQUUzQyxxQkFDRSw4REFBQ2U7UUFDQ0MsV0FBVTtRQUNWLGlCQUFpQjtRQUNqQkMsYUFBYUw7UUFDYk0sV0FBV0w7UUFDWE0sY0FBY047UUFDZCxnQkFBZ0I7UUFDaEJPLGNBQWNSO1FBQ2RTLFlBQVlSO1FBQ1pTLGVBQWVUOztZQUVkLENBQUNDLGtDQUNBLDhEQUFDQztnQkFBSUMsV0FBVTswQkFBYTs7Ozs7OzBCQUk5Qiw4REFBQ087Z0JBQ0NDLEtBQUt0QjtnQkFDTHVCLEtBQUk7Z0JBQ0pDLE9BQU87b0JBQUVDLFNBQVMvQixpQkFBaUIsU0FBUztvQkFDeENILE9BQU8sR0FBUyxPQUFOQSxPQUFNO29CQUNoQm1DLFFBQVE7Z0JBQ1g7Ozs7OzswQkFJSCw4REFBQ0w7Z0JBQ0NDLEtBQUtwQjtnQkFDTHFCLEtBQUk7Z0JBQ0pULFdBQVcsZ0VBQStHLE9BQS9DRixtQkFBbUIsZ0JBQWdCO2dCQUM5R1ksT0FBTztvQkFBRUMsU0FBUy9CLGlCQUFpQixVQUFVO29CQUN6Q0gsT0FBTyxHQUFTLE9BQU5BLE9BQU07b0JBQ2hCbUMsUUFBUTtnQkFDWDs7Ozs7OzBCQUlILDhEQUFDYjtnQkFDQ0MsV0FBVyw2S0FBNE4sT0FBL0NGLG1CQUFtQixnQkFBZ0I7MEJBRTFObEIsaUJBQWlCLFVBQVU7Ozs7Ozs7Ozs7OztBQUlwQztHQWxGTU47S0FBQUE7QUFvRk4sK0RBQWVBLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9QcmV2aWV3LmpzeD8zMzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbWFnZVRvZ2dsZVBvcHVwIENvbXBvbmVudFxuICogRGlzcGxheXMgYSBcImJlZm9yZVwiIGltYWdlIGFuZCByZXZlYWxzIGFuIFwiYWZ0ZXJcIiBpbWFnZSBvbiBwcmVzcy1hbmQtaG9sZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wcy5iZWZvcmVJbWFnZSAtIFVSTCBmb3IgdGhlIFwiYmVmb3JlXCIgaW1hZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuYWZ0ZXJJbWFnZSAtIFVSTCBmb3IgdGhlIFwiYWZ0ZXJcIiBpbWFnZS5cbiAqL1xuY29uc3QgSW1hZ2VUb2dnbGVQb3B1cCA9ICh7IGJlZm9yZUltYWdlLCBhZnRlckltYWdlLCB3aWR0aCB9KSA9PiB7XG4gIC8vIFN0YXRlIHRvIHRyYWNrIGlmIHRoZSBcImFmdGVyXCIgaW1hZ2Ugc2hvdWxkIGJlIHZpc2libGVcbiAgY29uc29sZS5sb2coYmVmb3JlSW1hZ2UsIGFmdGVySW1hZ2UpO1xuICBcbiAgY29uc3QgW2lzQWZ0ZXJWaXNpYmxlLCBzZXRJc0FmdGVyVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTdGF0ZSB0byBtYW5hZ2UgbG9hZGluZyBvZiBpbWFnZXMgdG8gcHJldmVudCBzaG93aW5nIGJlZm9yZSB0aGV5IGFyZSByZWFkeVxuICBjb25zdCBbaXNCZWZvcmVMb2FkZWQsIHNldElzQmVmb3JlTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQWZ0ZXJMb2FkZWQsIHNldElzQWZ0ZXJMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYmVmb3JlVXJsLCBzZXRCZWZvcmVVcmxdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbYWZ0ZXJVcmwsIHNldEFmdGVyVXJsXSA9IHVzZVN0YXRlKCcnKTtcbiAgLy8gUHJlbG9hZCBpbWFnZXMgdG8gZW5zdXJlIHRoZXkgYXJlIGNhY2hlZCBieSB0aGUgYnJvd3NlciBmb3IgYSBzbW9vdGggdHJhbnNpdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmKCFiZWZvcmVJbWFnZSB8fCAhYWZ0ZXJJbWFnZSkgcmV0dXJuO1xuICAgIGNvbnN0IGJVUkw9VVJMLmNyZWF0ZU9iamVjdFVSTChiZWZvcmVJbWFnZS5maWxlKTtcbiAgICBjb25zdCBhVVJMPVVSTC5jcmVhdGVPYmplY3RVUkwoYWZ0ZXJJbWFnZS5maWxlKTtcbiAgICBzZXRCZWZvcmVVcmwoYlVSTCk7XG4gICAgc2V0QWZ0ZXJVcmwoYVVSTCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmVmb3JlSW1hZ2UuZmlsZSk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGFmdGVySW1hZ2UuZmlsZSk7XG4gICAgfVxuICB9LCBbYmVmb3JlSW1hZ2UsIGFmdGVySW1hZ2VdKTtcblxuICAvLyBFdmVudCBoYW5kbGVycyB0byBzaG93IHRoZSBcImFmdGVyXCIgaW1hZ2VcbiAgY29uc3QgaGFuZGxlU2hvd0FmdGVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzQWZ0ZXJWaXNpYmxlKHRydWUpO1xuICB9LCBbXSk7XG4gIFxuICAvLyBFdmVudCBoYW5kbGVycyB0byBzaG93IHRoZSBcImJlZm9yZVwiIGltYWdlXG4gIGNvbnN0IGhhbmRsZVNob3dCZWZvcmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0SXNBZnRlclZpc2libGUoZmFsc2UpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgYm90aEltYWdlc0xvYWRlZCA9IGlzQmVmb3JlTG9hZGVkICYmIGlzQWZ0ZXJMb2FkZWQ7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCJyZWxhdGl2ZSB3LWZ1bGwgYXNwZWN0LXZpZGVvIHJvdW5kZWQteGwgc2hhZG93LTJ4bCBvdmVyZmxvdy1oaWRkZW4gc2VsZWN0LW5vbmUgYmctZ3JheS04MDAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIlxuICAgICAgLy8gRGVza3RvcCBldmVudHNcbiAgICAgIG9uTW91c2VEb3duPXtoYW5kbGVTaG93QWZ0ZXJ9XG4gICAgICBvbk1vdXNlVXA9e2hhbmRsZVNob3dCZWZvcmV9XG4gICAgICBvbk1vdXNlTGVhdmU9e2hhbmRsZVNob3dCZWZvcmV9IC8vIFJldmVydCBpZiBtb3VzZSBsZWF2ZXMgdGhlIGFyZWEgd2hpbGUgcHJlc3NlZFxuICAgICAgLy8gTW9iaWxlIGV2ZW50c1xuICAgICAgb25Ub3VjaFN0YXJ0PXtoYW5kbGVTaG93QWZ0ZXJ9XG4gICAgICBvblRvdWNoRW5kPXtoYW5kbGVTaG93QmVmb3JlfVxuICAgICAgb25Ub3VjaENhbmNlbD17aGFuZGxlU2hvd0JlZm9yZX0gLy8gUmV2ZXJ0IGlmIHRoZSB0b3VjaCBpcyBpbnRlcnJ1cHRlZFxuICAgID5cbiAgICAgIHshYm90aEltYWdlc0xvYWRlZCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZVwiPkxvYWRpbmcgaW1hZ2VzLi4uPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7LyogQmVmb3JlIEltYWdlIC0gYWx3YXlzIHJlbmRlcmVkLCBidXQgaXRzIG9wYWNpdHkgaXMgY2hhbmdlZCAqL31cbiAgICAgIDxpbWdcbiAgICAgICAgc3JjPXtiZWZvcmVVcmx9XG4gICAgICAgIGFsdD1cIkJlZm9yZVwiXG4gICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6IGlzQWZ0ZXJWaXNpYmxlID8gJ25vbmUnIDogJ2Jsb2NrJyxcbiAgICAgICAgICAgIHdpZHRoOiBgJHt3aWR0aH1weGAsXG4gICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgICAgIH19XG4gICAgICAvPlxuICAgICAgXG4gICAgICB7LyogQWZ0ZXIgSW1hZ2UgLSBhbHdheXMgcmVuZGVyZWQsIGJ1dCBpdHMgb3BhY2l0eSBpcyBjaGFuZ2VkICovfVxuICAgICAgPGltZ1xuICAgICAgICBzcmM9e2FmdGVyVXJsfVxuICAgICAgICBhbHQ9XCJBZnRlclwiXG4gICAgICAgIGNsYXNzTmFtZT17YGFic29sdXRlIGluc2V0LTAgdHJhbnNpdGlvbi1vcGFjaXR5IGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCAke2JvdGhJbWFnZXNMb2FkZWQgPyAnb3BhY2l0eS0xMDAnIDogJ29wYWNpdHktMCd9YH1cbiAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogaXNBZnRlclZpc2libGUgPyAnYmxvY2snIDogJ25vbmUnLFxuICAgICAgICAgICAgd2lkdGg6IGAke3dpZHRofXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogJ2F1dG8nLFxuICAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgICBcbiAgICAgIHsvKiBJbmZvcm1hdGlvbmFsIFRleHQgT3ZlcmxheSAqL31cbiAgICAgIDxkaXYgXG4gICAgICAgIGNsYXNzTmFtZT17YGFic29sdXRlIGJvdHRvbS00IGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgcHgtNCBweS0yIHJvdW5kZWQtZnVsbCB0ZXh0LXdoaXRlIGJnLWJsYWNrIGJnLW9wYWNpdHktNTAgYmFja2Ryb3AtYmx1ci1zbSB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMzAwIHBvaW50ZXItZXZlbnRzLW5vbmUgJHtib3RoSW1hZ2VzTG9hZGVkID8gJ29wYWNpdHktMTAwJyA6ICdvcGFjaXR5LTAnfWB9XG4gICAgICA+XG4gICAgICAgIHtpc0FmdGVyVmlzaWJsZSA/ICdBZnRlcicgOiAnQmVmb3JlIChIb2xkIHRvIGNvbXBhcmUpJ31cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VUb2dnbGVQb3B1cDsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiSW1hZ2VUb2dnbGVQb3B1cCIsImJlZm9yZUltYWdlIiwiYWZ0ZXJJbWFnZSIsIndpZHRoIiwiY29uc29sZSIsImxvZyIsImlzQWZ0ZXJWaXNpYmxlIiwic2V0SXNBZnRlclZpc2libGUiLCJpc0JlZm9yZUxvYWRlZCIsInNldElzQmVmb3JlTG9hZGVkIiwiaXNBZnRlckxvYWRlZCIsInNldElzQWZ0ZXJMb2FkZWQiLCJiZWZvcmVVcmwiLCJzZXRCZWZvcmVVcmwiLCJhZnRlclVybCIsInNldEFmdGVyVXJsIiwiYlVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImZpbGUiLCJhVVJMIiwicmV2b2tlT2JqZWN0VVJMIiwiaGFuZGxlU2hvd0FmdGVyIiwiaGFuZGxlU2hvd0JlZm9yZSIsImJvdGhJbWFnZXNMb2FkZWQiLCJkaXYiLCJjbGFzc05hbWUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsIm9uTW91c2VMZWF2ZSIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoQ2FuY2VsIiwiaW1nIiwic3JjIiwiYWx0Iiwic3R5bGUiLCJkaXNwbGF5IiwiaGVpZ2h0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Preview.jsx\n"));

/***/ }),

/***/ "./src/components/utils/imageProcessor.js":
/*!************************************************!*\
  !*** ./src/components/utils/imageProcessor.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateImagePreviewsWithQuality: function() { return /* binding */ generateImagePreviewsWithQuality; }\n/* harmony export */ });\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pica */ \"./node_modules/pica/dist/pica.js\");\n/* harmony import */ var pica__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pica__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ssimResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ssimResult */ \"./src/components/utils/ssimResult.js\");\n\n\nconst pica = new (pica__WEBPACK_IMPORTED_MODULE_0___default())();\nconst getImageDimensions = (file)=>{\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.onload = ()=>{\n            resolve({\n                width: img.width,\n                height: img.height\n            });\n            URL.revokeObjectURL(img.src);\n        };\n        img.onerror = (err)=>reject(err);\n        img.src = URL.createObjectURL(file);\n    });\n};\nconst processImage = async (file, options)=>{\n    try {\n        if (!options.needsResizing && options.fileType === file.type) {\n            return file;\n        }\n        const sourceImage = new Image();\n        const sourceUrl = URL.createObjectURL(file);\n        sourceImage.src = sourceUrl;\n        await new Promise((resolve, reject)=>{\n            sourceImage.onload = resolve;\n            sourceImage.onerror = reject;\n        });\n        URL.revokeObjectURL(sourceUrl);\n        const destCanvas = document.createElement(\"canvas\");\n        let targetWidth = sourceImage.width;\n        let targetHeight = sourceImage.height;\n        if (options.maxWidth && sourceImage.width > options.maxWidth) {\n            const aspectRatio = sourceImage.width / sourceImage.height;\n            targetWidth = options.maxWidth;\n            targetHeight = targetWidth / aspectRatio;\n        }\n        destCanvas.width = targetWidth;\n        destCanvas.height = targetHeight;\n        await pica.resize(sourceImage, destCanvas, {\n            alpha: true,\n            unsharpAmount: 160,\n            unsharpRadius: 0.6,\n            unsharpThreshold: 1\n        });\n        const outputQuality = options.quality !== undefined ? options.quality : 1;\n        const blob = await pica.toBlob(destCanvas, options.fileType, outputQuality);\n        return new File([\n            blob\n        ], file.name, {\n            type: options.fileType\n        });\n    } catch (error) {\n        console.error(\"Error processing to \".concat(options.fileType || \"original\", \" format:\"), error);\n        throw new Error(\"Failed to convert to \".concat(options.fileType, \": \").concat(error.message));\n    }\n};\nconst generateImagePreviewsWithQuality = async (file, param)=>{\n    let { maxWidth } = param;\n    if (!file || !file.type.startsWith(\"image/\")) {\n        throw new Error(\"Invalid file type.\");\n    }\n    const originalSize = file.size;\n    const originalFormat = file.type;\n    const { width } = await getImageDimensions(file);\n    const needsResizing = width > maxWidth;\n    const targetFormats = [\n        {\n            format: \"image/jpeg\",\n            label: \"JPEG\"\n        },\n        {\n            format: \"image/webp\",\n            label: \"WebP\"\n        },\n        {\n            format: \"image/png\",\n            label: \"PNG\"\n        }\n    ];\n    const processingPromises = targetFormats.map((target)=>{\n        const options = {\n            fileType: target.format,\n            maxWidth: needsResizing ? maxWidth : undefined,\n            quality: 0.99,\n            needsResizing: needsResizing\n        };\n        return processImage(file, options);\n    });\n    const settledResults = await Promise.allSettled(processingPromises);\n    const successfulResults = settledResults.filter((result)=>result.status === \"fulfilled\").map((result)=>{\n        var _targetFormats_find;\n        const newFile = result.value;\n        const reduction = (originalSize - newFile.size) / originalSize * 100;\n        return {\n            file: newFile,\n            format: newFile.type,\n            label: \"\".concat((_targetFormats_find = targetFormats.find((f)=>f.format === newFile.type)) === null || _targetFormats_find === void 0 ? void 0 : _targetFormats_find.label, \" \").concat(newFile.type === originalFormat ? \"resized\" : \"\") || \"Unknown\",\n            size: newFile.size,\n            reduction: reduction,\n            isOriginalFormat: newFile.type === originalFormat,\n            originalWidth: width\n        };\n    });\n    settledResults.forEach((result)=>{\n        if (result.status === \"rejected\") {\n            console.warn(result.reason);\n        }\n    });\n    const resultsWithQualityPromises = successfulResults.map(async (result)=>{\n        try {\n            const ssimScore = await (0,_ssimResult__WEBPACK_IMPORTED_MODULE_1__.ssimResult)(file, result.file);\n            return {\n                ...result,\n                ssimResult: ssimScore\n            };\n        } catch (error) {\n            console.error(\"Could not calculate SSIM for \".concat(result.label, \":\"), error);\n            return {\n                ...result,\n                ssimResult: \"Error\"\n            };\n        }\n    });\n    const finalResults = await Promise.all(resultsWithQualityPromises);\n    return finalResults;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLEtBQUssWUFBWTtZQUNoQ25CLFFBQVE0QixJQUFJLENBQUNWLE9BQU9XLE1BQU07UUFDNUI7SUFDRjtJQUVBLE1BQU1DLDZCQUE2QmQsa0JBQWtCSixHQUFHLENBQUMsT0FBT007UUFDOUQsSUFBSTtZQUNGLE1BQU1hLFlBQVksTUFBTTVFLHVEQUFVQSxDQUFDRyxNQUFNNEQsT0FBTzVELElBQUk7WUFDcEQsT0FBTztnQkFBRSxHQUFHNEQsTUFBTTtnQkFBRS9ELFlBQVk0RTtZQUFVO1FBQzVDLEVBQUUsT0FBT2hDLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUE2QyxPQUFibUIsT0FBT1IsS0FBSyxFQUFDLE1BQUlYO1lBQy9ELE9BQU87Z0JBQUUsR0FBR21CLE1BQU07Z0JBQUUvRCxZQUFZO1lBQVE7UUFDMUM7SUFDRjtJQUVBLE1BQU02RSxlQUFlLE1BQU16RSxRQUFRMEUsR0FBRyxDQUFDSDtJQUN2QyxPQUFPRTtBQUNULEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvaW1hZ2VQcm9jZXNzb3IuanM/ZDI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUGljYSBmcm9tICdwaWNhJztcbmltcG9ydCB7IHNzaW1SZXN1bHQgfSBmcm9tICcuL3NzaW1SZXN1bHQnO1xuXG5jb25zdCBwaWNhID0gbmV3IFBpY2EoKTtcblxuY29uc3QgZ2V0SW1hZ2VEaW1lbnNpb25zID0gKGZpbGUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSh7IHdpZHRoOiBpbWcud2lkdGgsIGhlaWdodDogaW1nLmhlaWdodCB9KTtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoaW1nLnNyYyk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IChlcnIpID0+IHJlamVjdChlcnIpO1xuICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn07XG5cbmNvbnN0IHByb2Nlc3NJbWFnZSA9IGFzeW5jIChmaWxlLCBvcHRpb25zKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYoIW9wdGlvbnMubmVlZHNSZXNpemluZyAmJiBvcHRpb25zLmZpbGVUeXBlID09PSBmaWxlLnR5cGUpIHtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGNvbnN0IHNvdXJjZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gICAgc291cmNlSW1hZ2Uuc3JjID0gc291cmNlVXJsO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgc291cmNlSW1hZ2Uub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc291cmNlSW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICB9KTtcbiAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHNvdXJjZVVybCk7XG5cbiAgICBjb25zdCBkZXN0Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgbGV0IHRhcmdldFdpZHRoID0gc291cmNlSW1hZ2Uud2lkdGg7XG4gICAgbGV0IHRhcmdldEhlaWdodCA9IHNvdXJjZUltYWdlLmhlaWdodDtcblxuICAgIGlmIChvcHRpb25zLm1heFdpZHRoICYmIHNvdXJjZUltYWdlLndpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHNvdXJjZUltYWdlLndpZHRoIC8gc291cmNlSW1hZ2UuaGVpZ2h0O1xuICAgICAgICB0YXJnZXRXaWR0aCA9IG9wdGlvbnMubWF4V2lkdGg7XG4gICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldFdpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIFxuICAgIGRlc3RDYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICBkZXN0Q2FudmFzLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICBcbiAgICBhd2FpdCBwaWNhLnJlc2l6ZShzb3VyY2VJbWFnZSwgZGVzdENhbnZhcywge1xuICAgICAgYWxwaGE6IHRydWUsXG4gICAgICB1bnNoYXJwQW1vdW50OiAxNjAsXG4gICAgICB1bnNoYXJwUmFkaXVzOiAwLjYsXG4gICAgICB1bnNoYXJwVGhyZXNob2xkOiAxLFxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IG91dHB1dFF1YWxpdHkgPSBvcHRpb25zLnF1YWxpdHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucXVhbGl0eSA6IDE7XG5cbiAgICBjb25zdCBibG9iID0gYXdhaXQgcGljYS50b0Jsb2IoZGVzdENhbnZhcywgb3B0aW9ucy5maWxlVHlwZSwgb3V0cHV0UXVhbGl0eSk7XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2JdLCBmaWxlLm5hbWUsIHsgdHlwZTogb3B0aW9ucy5maWxlVHlwZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHRvICR7b3B0aW9ucy5maWxlVHlwZSB8fCAnb3JpZ2luYWwnfSBmb3JtYXQ6YCwgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbnZlcnQgdG8gJHtvcHRpb25zLmZpbGVUeXBlfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVJbWFnZVByZXZpZXdzV2l0aFF1YWxpdHkgPSBhc3luYyAoZmlsZSwgeyBtYXhXaWR0aCB9KSA9PiB7XG4gIGlmICghZmlsZSB8fCAhZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZpbGUgdHlwZS4nKTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IGZpbGUuc2l6ZTtcbiAgY29uc3Qgb3JpZ2luYWxGb3JtYXQgPSBmaWxlLnR5cGU7XG4gIGNvbnN0IHsgd2lkdGggfSA9IGF3YWl0IGdldEltYWdlRGltZW5zaW9ucyhmaWxlKTtcbiAgY29uc3QgbmVlZHNSZXNpemluZyA9IHdpZHRoID4gbWF4V2lkdGg7XG5cbiAgY29uc3QgdGFyZ2V0Rm9ybWF0cyA9IFtcbiAgICB7IGZvcm1hdDogJ2ltYWdlL2pwZWcnLCBsYWJlbDogJ0pQRUcnIH0sXG4gICAgeyBmb3JtYXQ6ICdpbWFnZS93ZWJwJywgbGFiZWw6ICdXZWJQJyB9LFxuICAgIHsgZm9ybWF0OiAnaW1hZ2UvcG5nJywgbGFiZWw6ICdQTkcnIH1cbiAgXTtcblxuICBjb25zdCBwcm9jZXNzaW5nUHJvbWlzZXMgPSB0YXJnZXRGb3JtYXRzLm1hcCh0YXJnZXQgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmaWxlVHlwZTogdGFyZ2V0LmZvcm1hdCxcbiAgICAgIG1heFdpZHRoOiBuZWVkc1Jlc2l6aW5nID8gbWF4V2lkdGggOiB1bmRlZmluZWQsXG4gICAgICBxdWFsaXR5OiAwLjk5LCBcbiAgICAgIG5lZWRzUmVzaXppbmc6IG5lZWRzUmVzaXppbmcsXG4gICAgfTtcbiAgICByZXR1cm4gcHJvY2Vzc0ltYWdlKGZpbGUsIG9wdGlvbnMpO1xuICB9KTtcblxuICBjb25zdCBzZXR0bGVkUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9jZXNzaW5nUHJvbWlzZXMpO1xuXG4gIGNvbnN0IHN1Y2Nlc3NmdWxSZXN1bHRzID0gc2V0dGxlZFJlc3VsdHNcbiAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuc3RhdHVzID09PSAnZnVsZmlsbGVkJylcbiAgICAubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBuZXdGaWxlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgY29uc3QgcmVkdWN0aW9uID0gKChvcmlnaW5hbFNpemUgLSBuZXdGaWxlLnNpemUpIC8gb3JpZ2luYWxTaXplKSAqIDEwMDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGU6IG5ld0ZpbGUsXG4gICAgICAgIGZvcm1hdDogbmV3RmlsZS50eXBlLFxuICAgICAgICBsYWJlbDogYCR7dGFyZ2V0Rm9ybWF0cy5maW5kKGYgPT4gZi5mb3JtYXQgPT09IG5ld0ZpbGUudHlwZSk/LmxhYmVsfSAke25ld0ZpbGUudHlwZSA9PT0gb3JpZ2luYWxGb3JtYXQgPyAncmVzaXplZCcgOiAnJ31gIHx8ICdVbmtub3duJyxcbiAgICAgICAgc2l6ZTogbmV3RmlsZS5zaXplLFxuICAgICAgICByZWR1Y3Rpb246IHJlZHVjdGlvbixcbiAgICAgICAgaXNPcmlnaW5hbEZvcm1hdDogbmV3RmlsZS50eXBlID09PSBvcmlnaW5hbEZvcm1hdCxcbiAgICAgICAgb3JpZ2luYWxXaWR0aDogd2lkdGgsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gIHNldHRsZWRSZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgY29uc29sZS53YXJuKHJlc3VsdC5yZWFzb24pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMgPSBzdWNjZXNzZnVsUmVzdWx0cy5tYXAoYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzc2ltU2NvcmUgPSBhd2FpdCBzc2ltUmVzdWx0KGZpbGUsIHJlc3VsdC5maWxlKTtcbiAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgc3NpbVJlc3VsdDogc3NpbVNjb3JlIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYENvdWxkIG5vdCBjYWxjdWxhdGUgU1NJTSBmb3IgJHtyZXN1bHQubGFiZWx9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgc3NpbVJlc3VsdDogJ0Vycm9yJyB9O1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgZmluYWxSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0c1dpdGhRdWFsaXR5UHJvbWlzZXMpO1xuICByZXR1cm4gZmluYWxSZXN1bHRzO1xufTsiXSwibmFtZXMiOlsiUGljYSIsInNzaW1SZXN1bHQiLCJwaWNhIiwiZ2V0SW1hZ2VEaW1lbnNpb25zIiwiZmlsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsIlVSTCIsInJldm9rZU9iamVjdFVSTCIsInNyYyIsIm9uZXJyb3IiLCJlcnIiLCJjcmVhdGVPYmplY3RVUkwiLCJwcm9jZXNzSW1hZ2UiLCJvcHRpb25zIiwibmVlZHNSZXNpemluZyIsImZpbGVUeXBlIiwidHlwZSIsInNvdXJjZUltYWdlIiwic291cmNlVXJsIiwiZGVzdENhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwibWF4V2lkdGgiLCJhc3BlY3RSYXRpbyIsInJlc2l6ZSIsImFscGhhIiwidW5zaGFycEFtb3VudCIsInVuc2hhcnBSYWRpdXMiLCJ1bnNoYXJwVGhyZXNob2xkIiwib3V0cHV0UXVhbGl0eSIsInF1YWxpdHkiLCJ1bmRlZmluZWQiLCJibG9iIiwidG9CbG9iIiwiRmlsZSIsIm5hbWUiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsIm1lc3NhZ2UiLCJnZW5lcmF0ZUltYWdlUHJldmlld3NXaXRoUXVhbGl0eSIsInN0YXJ0c1dpdGgiLCJvcmlnaW5hbFNpemUiLCJzaXplIiwib3JpZ2luYWxGb3JtYXQiLCJ0YXJnZXRGb3JtYXRzIiwiZm9ybWF0IiwibGFiZWwiLCJwcm9jZXNzaW5nUHJvbWlzZXMiLCJtYXAiLCJ0YXJnZXQiLCJzZXR0bGVkUmVzdWx0cyIsImFsbFNldHRsZWQiLCJzdWNjZXNzZnVsUmVzdWx0cyIsImZpbHRlciIsInJlc3VsdCIsInN0YXR1cyIsIm5ld0ZpbGUiLCJ2YWx1ZSIsInJlZHVjdGlvbiIsImZpbmQiLCJmIiwiaXNPcmlnaW5hbEZvcm1hdCIsIm9yaWdpbmFsV2lkdGgiLCJmb3JFYWNoIiwid2FybiIsInJlYXNvbiIsInJlc3VsdHNXaXRoUXVhbGl0eVByb21pc2VzIiwic3NpbVNjb3JlIiwiZmluYWxSZXN1bHRzIiwiYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/utils/imageProcessor.js\n"));

/***/ }),

/***/ "./src/components/utils/ssimResult.js":
/*!********************************************!*\
  !*** ./src/components/utils/ssimResult.js ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ssimResult: function() { return /* binding */ ssimResult; }\n/* harmony export */ });\n/* harmony import */ var ssim_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ssim.js */ \"./node_modules/ssim.js/dist/ssim.web.js\");\n/* harmony import */ var ssim_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ssim_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * ssimResult.js (Main-Thread Version)\n * =====================================\n * WARNING: This implementation runs CPU-intensive calculations on the main\n * browser thread. This WILL FREEZE the user interface (UI) while the\n * SSIM score is being calculated. The page will become unresponsive.\n * This approach is NOT RECOMMENDED for a production environment. Use it only\n * for simple testing or debugging purposes where UI performance is not a concern.\n */  // Import the library directly\n/**\n * A helper function to draw an image file onto an off-screen canvas\n * at specific dimensions and extract its raw pixel data (ImageData).\n */ const getImageDataFromFile = async (file, param)=>{\n    let { width, height } = param;\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    const imageBitmap = await createImageBitmap(file);\n    ctx.drawImage(imageBitmap, 0, 0, width, height);\n    imageBitmap.close(); // Release memory\n    return ctx.getImageData(0, 0, width, height);\n};\n/**\n * Calculates the SSIM score between two images directly on the main thread.\n * @param {File} originalImageFile - The original, uncompressed image file.\n * @param {File} compressedImageFile - The modified, compressed image file.\n * @returns {Promise<number>} A promise that resolves with the SSIM score.\n */ const ssimResult = async (originalImageFile, compressedImageFile)=>{\n    try {\n        // 1. Validate inputs\n        if (!originalImageFile || !compressedImageFile) {\n            throw new Error(\"Two image files must be provided.\");\n        }\n        // 2. Get the dimensions of the compressed image for comparison\n        const imageBitmap = await createImageBitmap(compressedImageFile);\n        const { width, height } = imageBitmap;\n        imageBitmap.close();\n        if (width === 0 || height === 0) {\n            throw new Error(\"Compressed image has invalid dimensions (0x0).\");\n        }\n        // 3. Get the raw pixel data for both images\n        const [originalImageData, compressedImageData] = await Promise.all([\n            getImageDataFromFile(originalImageFile, {\n                width,\n                height\n            }),\n            getImageDataFromFile(compressedImageFile, {\n                width,\n                height\n            })\n        ]);\n        console.log(\"Preparing data for SSIM calculation (UI may freeze now)...\");\n        // 4. Prepare the data for the ssim function\n        const image1 = {\n            data: originalImageData.data,\n            width: originalImageData.width,\n            height: originalImageData.height\n        };\n        const image2 = {\n            data: compressedImageData.data,\n            width: compressedImageData.width,\n            height: compressedImageData.height\n        };\n        // 5. Run the SSIM calculation directly. This is the blocking operation.\n        const result = (0,ssim_js__WEBPACK_IMPORTED_MODULE_0__.ssim)(image1, image2);\n        // 6. Return the final score\n        return result.mssim;\n    } catch (error) {\n        console.error(\"SSIM calculation failed:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy91dGlscy9zc2ltUmVzdWx0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7OztDQVFDLEdBRThCLENBQUMsOEJBQThCO0FBRTlEOzs7Q0FHQyxHQUNELE1BQU1DLHVCQUF1QixPQUFPQztRQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ3pELE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztJQUN0Q0YsT0FBT0YsS0FBSyxHQUFHQTtJQUNmRSxPQUFPRCxNQUFNLEdBQUdBO0lBQ2hCLE1BQU1JLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztJQUU5QixNQUFNQyxjQUFjLE1BQU1DLGtCQUFrQlQ7SUFDNUNNLElBQUlJLFNBQVMsQ0FBQ0YsYUFBYSxHQUFHLEdBQUdQLE9BQU9DO0lBQ3hDTSxZQUFZRyxLQUFLLElBQUksaUJBQWlCO0lBRXRDLE9BQU9MLElBQUlNLFlBQVksQ0FBQyxHQUFHLEdBQUdYLE9BQU9DO0FBQ3ZDO0FBRUE7Ozs7O0NBS0MsR0FDTSxNQUFNVyxhQUFhLE9BQU9DLG1CQUFtQkM7SUFDbEQsSUFBSTtRQUNGLHFCQUFxQjtRQUNyQixJQUFJLENBQUNELHFCQUFxQixDQUFDQyxxQkFBcUI7WUFDOUMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsK0RBQStEO1FBQy9ELE1BQU1SLGNBQWMsTUFBTUMsa0JBQWtCTTtRQUM1QyxNQUFNLEVBQUVkLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdNO1FBQzFCQSxZQUFZRyxLQUFLO1FBRWpCLElBQUlWLFVBQVUsS0FBS0MsV0FBVyxHQUFHO1lBQy9CLE1BQU0sSUFBSWMsTUFBTTtRQUNsQjtRQUVBLDRDQUE0QztRQUM1QyxNQUFNLENBQUNDLG1CQUFtQkMsb0JBQW9CLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO1lBQ2pFckIscUJBQXFCZSxtQkFBbUI7Z0JBQUViO2dCQUFPQztZQUFPO1lBQ3hESCxxQkFBcUJnQixxQkFBcUI7Z0JBQUVkO2dCQUFPQztZQUFPO1NBQzNEO1FBRURtQixRQUFRQyxHQUFHLENBQUM7UUFFWiw0Q0FBNEM7UUFDNUMsTUFBTUMsU0FBUztZQUNiQyxNQUFNUCxrQkFBa0JPLElBQUk7WUFDNUJ2QixPQUFPZ0Isa0JBQWtCaEIsS0FBSztZQUM5QkMsUUFBUWUsa0JBQWtCZixNQUFNO1FBQ2xDO1FBQ0EsTUFBTXVCLFNBQVM7WUFDYkQsTUFBTU4sb0JBQW9CTSxJQUFJO1lBQzlCdkIsT0FBT2lCLG9CQUFvQmpCLEtBQUs7WUFDaENDLFFBQVFnQixvQkFBb0JoQixNQUFNO1FBQ3BDO1FBRUEsd0VBQXdFO1FBQ3hFLE1BQU13QixTQUFTNUIsNkNBQUlBLENBQUN5QixRQUFRRTtRQUU1Qiw0QkFBNEI7UUFDNUIsT0FBT0MsT0FBT0MsS0FBSztJQUVyQixFQUFFLE9BQU9DLE9BQU87UUFDZFAsUUFBUU8sS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsTUFBTUE7SUFDUjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdXRpbHMvc3NpbVJlc3VsdC5qcz8zYzlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogc3NpbVJlc3VsdC5qcyAoTWFpbi1UaHJlYWQgVmVyc2lvbilcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFdBUk5JTkc6IFRoaXMgaW1wbGVtZW50YXRpb24gcnVucyBDUFUtaW50ZW5zaXZlIGNhbGN1bGF0aW9ucyBvbiB0aGUgbWFpblxuICogYnJvd3NlciB0aHJlYWQuIFRoaXMgV0lMTCBGUkVFWkUgdGhlIHVzZXIgaW50ZXJmYWNlIChVSSkgd2hpbGUgdGhlXG4gKiBTU0lNIHNjb3JlIGlzIGJlaW5nIGNhbGN1bGF0ZWQuIFRoZSBwYWdlIHdpbGwgYmVjb21lIHVucmVzcG9uc2l2ZS5cbiAqIFRoaXMgYXBwcm9hY2ggaXMgTk9UIFJFQ09NTUVOREVEIGZvciBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQuIFVzZSBpdCBvbmx5XG4gKiBmb3Igc2ltcGxlIHRlc3Rpbmcgb3IgZGVidWdnaW5nIHB1cnBvc2VzIHdoZXJlIFVJIHBlcmZvcm1hbmNlIGlzIG5vdCBhIGNvbmNlcm4uXG4gKi9cblxuaW1wb3J0IHsgc3NpbSB9IGZyb20gJ3NzaW0uanMnOyAvLyBJbXBvcnQgdGhlIGxpYnJhcnkgZGlyZWN0bHlcblxuLyoqXG4gKiBBIGhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGFuIGltYWdlIGZpbGUgb250byBhbiBvZmYtc2NyZWVuIGNhbnZhc1xuICogYXQgc3BlY2lmaWMgZGltZW5zaW9ucyBhbmQgZXh0cmFjdCBpdHMgcmF3IHBpeGVsIGRhdGEgKEltYWdlRGF0YSkuXG4gKi9cbmNvbnN0IGdldEltYWdlRGF0YUZyb21GaWxlID0gYXN5bmMgKGZpbGUsIHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIFxuICBjb25zdCBpbWFnZUJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGZpbGUpO1xuICBjdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgaW1hZ2VCaXRtYXAuY2xvc2UoKTsgLy8gUmVsZWFzZSBtZW1vcnlcbiAgXG4gIHJldHVybiBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBTU0lNIHNjb3JlIGJldHdlZW4gdHdvIGltYWdlcyBkaXJlY3RseSBvbiB0aGUgbWFpbiB0aHJlYWQuXG4gKiBAcGFyYW0ge0ZpbGV9IG9yaWdpbmFsSW1hZ2VGaWxlIC0gVGhlIG9yaWdpbmFsLCB1bmNvbXByZXNzZWQgaW1hZ2UgZmlsZS5cbiAqIEBwYXJhbSB7RmlsZX0gY29tcHJlc3NlZEltYWdlRmlsZSAtIFRoZSBtb2RpZmllZCwgY29tcHJlc3NlZCBpbWFnZSBmaWxlLlxuICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgU1NJTSBzY29yZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNzaW1SZXN1bHQgPSBhc3luYyAob3JpZ2luYWxJbWFnZUZpbGUsIGNvbXByZXNzZWRJbWFnZUZpbGUpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyAxLiBWYWxpZGF0ZSBpbnB1dHNcbiAgICBpZiAoIW9yaWdpbmFsSW1hZ2VGaWxlIHx8ICFjb21wcmVzc2VkSW1hZ2VGaWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUd28gaW1hZ2UgZmlsZXMgbXVzdCBiZSBwcm92aWRlZC5cIik7XG4gICAgfVxuXG4gICAgLy8gMi4gR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb21wcmVzc2VkIGltYWdlIGZvciBjb21wYXJpc29uXG4gICAgY29uc3QgaW1hZ2VCaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChjb21wcmVzc2VkSW1hZ2VGaWxlKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlQml0bWFwO1xuICAgIGltYWdlQml0bWFwLmNsb3NlKCk7XG5cbiAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wcmVzc2VkIGltYWdlIGhhcyBpbnZhbGlkIGRpbWVuc2lvbnMgKDB4MCkuXCIpO1xuICAgIH1cblxuICAgIC8vIDMuIEdldCB0aGUgcmF3IHBpeGVsIGRhdGEgZm9yIGJvdGggaW1hZ2VzXG4gICAgY29uc3QgW29yaWdpbmFsSW1hZ2VEYXRhLCBjb21wcmVzc2VkSW1hZ2VEYXRhXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGdldEltYWdlRGF0YUZyb21GaWxlKG9yaWdpbmFsSW1hZ2VGaWxlLCB7IHdpZHRoLCBoZWlnaHQgfSksXG4gICAgICBnZXRJbWFnZURhdGFGcm9tRmlsZShjb21wcmVzc2VkSW1hZ2VGaWxlLCB7IHdpZHRoLCBoZWlnaHQgfSlcbiAgICBdKTtcblxuICAgIGNvbnNvbGUubG9nKFwiUHJlcGFyaW5nIGRhdGEgZm9yIFNTSU0gY2FsY3VsYXRpb24gKFVJIG1heSBmcmVlemUgbm93KS4uLlwiKTtcblxuICAgIC8vIDQuIFByZXBhcmUgdGhlIGRhdGEgZm9yIHRoZSBzc2ltIGZ1bmN0aW9uXG4gICAgY29uc3QgaW1hZ2UxID0ge1xuICAgICAgZGF0YTogb3JpZ2luYWxJbWFnZURhdGEuZGF0YSxcbiAgICAgIHdpZHRoOiBvcmlnaW5hbEltYWdlRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodDogb3JpZ2luYWxJbWFnZURhdGEuaGVpZ2h0LFxuICAgIH07XG4gICAgY29uc3QgaW1hZ2UyID0ge1xuICAgICAgZGF0YTogY29tcHJlc3NlZEltYWdlRGF0YS5kYXRhLFxuICAgICAgd2lkdGg6IGNvbXByZXNzZWRJbWFnZURhdGEud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNvbXByZXNzZWRJbWFnZURhdGEuaGVpZ2h0LFxuICAgIH07XG4gIFxuICAgIC8vIDUuIFJ1biB0aGUgU1NJTSBjYWxjdWxhdGlvbiBkaXJlY3RseS4gVGhpcyBpcyB0aGUgYmxvY2tpbmcgb3BlcmF0aW9uLlxuICAgIGNvbnN0IHJlc3VsdCA9IHNzaW0oaW1hZ2UxLCBpbWFnZTIpO1xuICAgIFxuICAgIC8vIDYuIFJldHVybiB0aGUgZmluYWwgc2NvcmVcbiAgICByZXR1cm4gcmVzdWx0Lm1zc2ltO1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlNTSU0gY2FsY3VsYXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07Il0sIm5hbWVzIjpbInNzaW0iLCJnZXRJbWFnZURhdGFGcm9tRmlsZSIsImZpbGUiLCJ3aWR0aCIsImhlaWdodCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJpbWFnZUJpdG1hcCIsImNyZWF0ZUltYWdlQml0bWFwIiwiZHJhd0ltYWdlIiwiY2xvc2UiLCJnZXRJbWFnZURhdGEiLCJzc2ltUmVzdWx0Iiwib3JpZ2luYWxJbWFnZUZpbGUiLCJjb21wcmVzc2VkSW1hZ2VGaWxlIiwiRXJyb3IiLCJvcmlnaW5hbEltYWdlRGF0YSIsImNvbXByZXNzZWRJbWFnZURhdGEiLCJQcm9taXNlIiwiYWxsIiwiY29uc29sZSIsImxvZyIsImltYWdlMSIsImRhdGEiLCJpbWFnZTIiLCJyZXN1bHQiLCJtc3NpbSIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/utils/ssimResult.js\n"));

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ImageCompressor_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/ImageCompressor.jsx */ \"./src/components/ImageCompressor.jsx\");\n\n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"My App\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                        lineNumber: 7,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"My Next.js app\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                        lineNumber: 8,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                        lineNumber: 9,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                        lineNumber: 10,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                lineNumber: 6,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ImageCompressor_jsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/ankeshgupta/Documents/image_optimisation_new/src/pages/index.js\",\n                lineNumber: 12,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QjtBQUNtQztBQUNqRCxTQUFTRTtJQUN0QixxQkFDRTs7MEJBQ0UsOERBQUNGLGtEQUFJQTs7a0NBQ0gsOERBQUNHO2tDQUFNOzs7Ozs7a0NBQ1AsOERBQUNDO3dCQUFLQyxNQUFLO3dCQUFjQyxTQUFROzs7Ozs7a0NBQ2pDLDhEQUFDRjt3QkFBS0MsTUFBSzt3QkFBV0MsU0FBUTs7Ozs7O2tDQUM5Qiw4REFBQ0M7d0JBQUtDLEtBQUk7d0JBQU9DLE1BQUs7Ozs7Ozs7Ozs7OzswQkFFeEIsOERBQUNSLHVFQUFlQTs7Ozs7OztBQUd0QjtLQVp3QkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2luZGV4LmpzPzQwODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSBcIm5leHQvaGVhZFwiO1xuaW1wb3J0IEltYWdlQ29tcHJlc3NvciBmcm9tIFwiLi4vY29tcG9uZW50cy9JbWFnZUNvbXByZXNzb3IuanN4XCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPk15IEFwcDwvdGl0bGU+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJkZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJNeSBOZXh0LmpzIGFwcFwiIC8+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gICAgICAgIDxsaW5rIHJlbD1cImljb25cIiBocmVmPVwiL2Zhdmljb24uaWNvXCIgLz5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxJbWFnZUNvbXByZXNzb3IgLz5cbiAgICA8Lz5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbIkhlYWQiLCJJbWFnZUNvbXByZXNzb3IiLCJIb21lIiwidGl0bGUiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJsaW5rIiwicmVsIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/pica/dist/pica.js":
/*!****************************************!*\
  !*** ./node_modules/pica/dist/pica.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*!\n\npica\nhttps://github.com/nodeca/pica\n\n*/\n\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(_dereq_,module,exports){\n// Collection of math functions\n//\n// 1. Combine components together\n// 2. Has async init to load wasm modules\n//\n'use strict';\n\nvar Multimath = _dereq_('multimath');\n\nvar mm_unsharp_mask = _dereq_('./mm_unsharp_mask');\n\nvar mm_resize = _dereq_('./mm_resize');\n\nfunction MathLib(requested_features) {\n  var __requested_features = requested_features || [];\n\n  var features = {\n    js: __requested_features.indexOf('js') >= 0,\n    wasm: __requested_features.indexOf('wasm') >= 0\n  };\n  Multimath.call(this, features);\n  this.features = {\n    js: features.js,\n    wasm: features.wasm && this.has_wasm()\n  };\n  this.use(mm_unsharp_mask);\n  this.use(mm_resize);\n}\n\nMathLib.prototype = Object.create(Multimath.prototype);\nMathLib.prototype.constructor = MathLib;\n\nMathLib.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {\n  var result = this.resize(options, cache);\n\n  if (options.unsharpAmount) {\n    this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold);\n  }\n\n  return result;\n};\n\nmodule.exports = MathLib;\n\n},{\"./mm_resize\":4,\"./mm_unsharp_mask\":9,\"multimath\":19}],2:[function(_dereq_,module,exports){\n// Resize convolvers, pure JS implementation\n//\n'use strict'; // Precision of fixed FP values\n//var FIXED_FRAC_BITS = 14;\n\nfunction clampTo8(i) {\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampNegative(i) {\n  return i >= 0 ? i : 0;\n} // Convolve image data in horizontal direction. Can be used for:\n//\n// 1. bitmap with premultiplied alpha\n// 2. bitmap without alpha (all values 255)\n//\n// Notes:\n//\n// - output is transposed\n// - output resolution is ~15 bits per channel(for better precision).\n//\n\n\nfunction convolveHor(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Store 15 bits between passes for better precision\n      // Instead of shift to 14 (FIXED_FRAC_BITS), shift to 7 only\n      //\n\n\n      dest[destOffset + 3] = clampNegative(a >> 7);\n      dest[destOffset + 2] = clampNegative(b >> 7);\n      dest[destOffset + 1] = clampNegative(g >> 7);\n      dest[destOffset] = clampNegative(r >> 7);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Supplementary method for `convolveHor()`\n//\n\n\nfunction convolveVert(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Sync with premultiplied version for exact result match\n\n\n      r >>= 7;\n      g >>= 7;\n      b >>= 7;\n      a >>= 7; // Bring this value back in range + round result.\n      //\n\n      dest[destOffset + 3] = clampTo8(a + (1 << 13) >> 14);\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Premultiply & convolve image data in horizontal direction. Can be used for:\n//\n// - Any bitmap data, extracted with `.getImageData()` method (with\n//   non-premultiplied alpha)\n//\n// For images without alpha channel this method is slower than `convolveHor()`\n//\n\n\nfunction convolveHorWithPre(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a, alpha;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        alpha = src[srcPtr + 3];\n        a = a + filterVal * alpha | 0;\n        b = b + filterVal * src[srcPtr + 2] * alpha | 0;\n        g = g + filterVal * src[srcPtr + 1] * alpha | 0;\n        r = r + filterVal * src[srcPtr] * alpha | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Premultiply is (* alpha / 255).\n      // Postpone division for better performance\n\n\n      b = b / 255 | 0;\n      g = g / 255 | 0;\n      r = r / 255 | 0; // Store 15 bits between passes for better precision\n      // Instead of shift to 14 (FIXED_FRAC_BITS), shift to 7 only\n      //\n\n      dest[destOffset + 3] = clampNegative(a >> 7);\n      dest[destOffset + 2] = clampNegative(b >> 7);\n      dest[destOffset + 1] = clampNegative(g >> 7);\n      dest[destOffset] = clampNegative(r >> 7);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n} // Supplementary method for `convolveHorWithPre()`\n//\n\n\nfunction convolveVertWithPre(src, dest, srcW, srcH, destW, filters) {\n  var r, g, b, a;\n  var filterPtr, filterShift, filterSize;\n  var srcPtr, srcY, destX, filterVal;\n  var srcOffset = 0,\n      destOffset = 0; // For each row\n\n  for (srcY = 0; srcY < srcH; srcY++) {\n    filterPtr = 0; // Apply precomputed filters to each destination row point\n\n    for (destX = 0; destX < destW; destX++) {\n      // Get the filter that determines the current output pixel.\n      filterShift = filters[filterPtr++];\n      filterSize = filters[filterPtr++];\n      srcPtr = srcOffset + filterShift * 4 | 0;\n      r = g = b = a = 0; // Apply the filter to the row to get the destination pixel r, g, b, a\n\n      for (; filterSize > 0; filterSize--) {\n        filterVal = filters[filterPtr++]; // Use reverse order to workaround deopts in old v8 (node v.10)\n        // Big thanks to @mraleph (Vyacheslav Egorov) for the tip.\n\n        a = a + filterVal * src[srcPtr + 3] | 0;\n        b = b + filterVal * src[srcPtr + 2] | 0;\n        g = g + filterVal * src[srcPtr + 1] | 0;\n        r = r + filterVal * src[srcPtr] | 0;\n        srcPtr = srcPtr + 4 | 0;\n      } // Downscale to leave room for un-premultiply\n\n\n      r >>= 7;\n      g >>= 7;\n      b >>= 7;\n      a >>= 7; // Un-premultiply\n\n      a = clampTo8(a + (1 << 13) >> 14);\n\n      if (a > 0) {\n        r = r * 255 / a | 0;\n        g = g * 255 / a | 0;\n        b = b * 255 / a | 0;\n      } // Bring this value back in range + round result.\n      // Shift value = FIXED_FRAC_BITS + 7\n      //\n\n\n      dest[destOffset + 3] = a;\n      dest[destOffset + 2] = clampTo8(b + (1 << 13) >> 14);\n      dest[destOffset + 1] = clampTo8(g + (1 << 13) >> 14);\n      dest[destOffset] = clampTo8(r + (1 << 13) >> 14);\n      destOffset = destOffset + srcH * 4 | 0;\n    }\n\n    destOffset = (srcY + 1) * 4 | 0;\n    srcOffset = (srcY + 1) * srcW * 4 | 0;\n  }\n}\n\nmodule.exports = {\n  convolveHor: convolveHor,\n  convolveVert: convolveVert,\n  convolveHorWithPre: convolveHorWithPre,\n  convolveVertWithPre: convolveVertWithPre\n};\n\n},{}],3:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],4:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'resize',\n  fn: _dereq_('./resize'),\n  wasm_fn: _dereq_('./resize_wasm'),\n  wasm_src: _dereq_('./convolve_wasm_base64')\n};\n\n},{\"./convolve_wasm_base64\":3,\"./resize\":5,\"./resize_wasm\":8}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nvar _require = _dereq_('./convolve'),\n    convolveHor = _require.convolveHor,\n    convolveVert = _require.convolveVert,\n    convolveHorWithPre = _require.convolveHorWithPre,\n    convolveVertWithPre = _require.convolveVertWithPre;\n\nfunction hasAlpha(src, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    if (src[ptr] !== 255) return true;\n    ptr = ptr + 4 | 0;\n  }\n\n  return false;\n}\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nmodule.exports = function resize(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0;\n  var offsetY = options.offsetY || 0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var filter = typeof options.filter === 'undefined' ? 'mks2013' : options.filter;\n  var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(filter, srcH, destH, scaleY, offsetY);\n  var tmp = new Uint16Array(destW * srcH * 4); // Autodetect if alpha channel exists, and use appropriate method\n\n  if (hasAlpha(src, srcW, srcH)) {\n    convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX);\n    convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY);\n  } else {\n    convolveHor(src, tmp, srcW, srcH, destW, filtersX);\n    convolveVert(tmp, dest, srcH, destW, destH, filtersY);\n    resetAlpha(dest, destW, destH);\n  }\n\n  return dest;\n};\n\n},{\"./convolve\":2,\"./resize_filter_gen\":6}],6:[function(_dereq_,module,exports){\n// Calculate convolution filters for each destination point,\n// and pack data to Int16Array:\n//\n// [ shift, length, data..., shift2, length2, data..., ... ]\n//\n// - shift - offset in src image\n// - length - filter length (in src points)\n// - data - filter values sequence\n//\n'use strict';\n\nvar FILTER_INFO = _dereq_('./resize_filter_info'); // Precision of fixed FP values\n\n\nvar FIXED_FRAC_BITS = 14;\n\nfunction toFixedPoint(num) {\n  return Math.round(num * ((1 << FIXED_FRAC_BITS) - 1));\n}\n\nmodule.exports = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {\n  var filterFunction = FILTER_INFO.filter[filter].fn;\n  var scaleInverted = 1.0 / scale;\n  var scaleClamped = Math.min(1.0, scale); // For upscale\n  // Filter window (averaging interval), scaled to src image\n\n  var srcWindow = FILTER_INFO.filter[filter].win / scaleClamped;\n  var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal;\n  var leftNotEmpty, rightNotEmpty, filterShift, filterSize;\n  var maxFilterElementSize = Math.floor((srcWindow + 1) * 2);\n  var packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize);\n  var packedFilterPtr = 0;\n  var slowCopy = !packedFilter.subarray || !packedFilter.set; // For each destination pixel calculate source range and built filter values\n\n  for (destPixel = 0; destPixel < destSize; destPixel++) {\n    // Scaling should be done relative to central pixel point\n    srcPixel = (destPixel + 0.5) * scaleInverted + offset;\n    srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow));\n    srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow));\n    filterElementSize = srcLast - srcFirst + 1;\n    floatFilter = new Float32Array(filterElementSize);\n    fxpFilter = new Int16Array(filterElementSize);\n    total = 0.0; // Fill filter values for calculated range\n\n    for (pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) {\n      floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped);\n      total += floatVal;\n      floatFilter[idx] = floatVal;\n    } // Normalize filter, convert to fixed point and accumulate conversion error\n\n\n    filterTotal = 0;\n\n    for (idx = 0; idx < floatFilter.length; idx++) {\n      filterVal = floatFilter[idx] / total;\n      filterTotal += filterVal;\n      fxpFilter[idx] = toFixedPoint(filterVal);\n    } // Compensate normalization error, to minimize brightness drift\n\n\n    fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal); //\n    // Now pack filter to useable form\n    //\n    // 1. Trim heading and tailing zero values, and compensate shitf/length\n    // 2. Put all to single array in this format:\n    //\n    //    [ pos shift, data length, value1, value2, value3, ... ]\n    //\n\n    leftNotEmpty = 0;\n\n    while (leftNotEmpty < fxpFilter.length && fxpFilter[leftNotEmpty] === 0) {\n      leftNotEmpty++;\n    }\n\n    if (leftNotEmpty < fxpFilter.length) {\n      rightNotEmpty = fxpFilter.length - 1;\n\n      while (rightNotEmpty > 0 && fxpFilter[rightNotEmpty] === 0) {\n        rightNotEmpty--;\n      }\n\n      filterShift = srcFirst + leftNotEmpty;\n      filterSize = rightNotEmpty - leftNotEmpty + 1;\n      packedFilter[packedFilterPtr++] = filterShift; // shift\n\n      packedFilter[packedFilterPtr++] = filterSize; // size\n\n      if (!slowCopy) {\n        packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr);\n        packedFilterPtr += filterSize;\n      } else {\n        // fallback for old IE < 11, without subarray/set methods\n        for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) {\n          packedFilter[packedFilterPtr++] = fxpFilter[idx];\n        }\n      }\n    } else {\n      // zero data, write header only\n      packedFilter[packedFilterPtr++] = 0; // shift\n\n      packedFilter[packedFilterPtr++] = 0; // size\n    }\n  }\n\n  return packedFilter;\n};\n\n},{\"./resize_filter_info\":7}],7:[function(_dereq_,module,exports){\n// Filter definitions to build tables for\n// resizing convolvers.\n//\n// Presets for quality 0..3. Filter functions + window size\n//\n'use strict';\n\nvar filter = {\n  // Nearest neibor\n  box: {\n    win: 0.5,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n      return x < 0.5 ? 1.0 : 0.0;\n    }\n  },\n  // // Hamming\n  hamming: {\n    win: 1.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 1.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));\n    }\n  },\n  // Lanczos, win = 2\n  lanczos2: {\n    win: 2.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 2.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);\n    }\n  },\n  // Lanczos, win = 3\n  lanczos3: {\n    win: 3.0,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 3.0) {\n        return 0.0;\n      }\n\n      if (x < 1.19209290E-07) {\n        return 1.0;\n      }\n\n      var xpi = x * Math.PI;\n      return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);\n    }\n  },\n  // Magic Kernel Sharp 2013, win = 2.5\n  // http://johncostella.com/magic/\n  mks2013: {\n    win: 2.5,\n    fn: function fn(x) {\n      if (x < 0) x = -x;\n\n      if (x >= 2.5) {\n        return 0.0;\n      }\n\n      if (x >= 1.5) {\n        return -0.125 * (x - 2.5) * (x - 2.5);\n      }\n\n      if (x >= 0.5) {\n        return 0.25 * (4 * x * x - 11 * x + 7);\n      }\n\n      return 1.0625 - 1.75 * x * x;\n    }\n  }\n};\nmodule.exports = {\n  filter: filter,\n  // Legacy mapping\n  f2q: {\n    box: 0,\n    hamming: 1,\n    lanczos2: 2,\n    lanczos3: 3\n  },\n  q2f: ['box', 'hamming', 'lanczos2', 'lanczos3']\n};\n\n},{}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar createFilters = _dereq_('./resize_filter_gen');\n\nfunction hasAlpha(src, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    if (src[ptr] !== 255) return true;\n    ptr = ptr + 4 | 0;\n  }\n\n  return false;\n}\n\nfunction resetAlpha(dst, width, height) {\n  var ptr = 3,\n      len = width * height * 4 | 0;\n\n  while (ptr < len) {\n    dst[ptr] = 0xFF;\n    ptr = ptr + 4 | 0;\n  }\n}\n\nfunction asUint8Array(src) {\n  return new Uint8Array(src.buffer, 0, src.byteLength);\n}\n\nvar IS_LE = true; // should not crash everything on module load in old browsers\n\ntry {\n  IS_LE = new Uint32Array(new Uint8Array([1, 0, 0, 0]).buffer)[0] === 1;\n} catch (__) {}\n\nfunction copyInt16asLE(src, target, target_offset) {\n  if (IS_LE) {\n    target.set(asUint8Array(src), target_offset);\n    return;\n  }\n\n  for (var ptr = target_offset, i = 0; i < src.length; i++) {\n    var data = src[i];\n    target[ptr++] = data & 0xFF;\n    target[ptr++] = data >> 8 & 0xFF;\n  }\n}\n\nmodule.exports = function resize_wasm(options) {\n  var src = options.src;\n  var srcW = options.width;\n  var srcH = options.height;\n  var destW = options.toWidth;\n  var destH = options.toHeight;\n  var scaleX = options.scaleX || options.toWidth / options.width;\n  var scaleY = options.scaleY || options.toHeight / options.height;\n  var offsetX = options.offsetX || 0.0;\n  var offsetY = options.offsetY || 0.0;\n  var dest = options.dest || new Uint8Array(destW * destH * 4);\n  var filter = typeof options.filter === 'undefined' ? 'mks2013' : options.filter;\n  var filtersX = createFilters(filter, srcW, destW, scaleX, offsetX),\n      filtersY = createFilters(filter, srcH, destH, scaleY, offsetY); // destination is 0 too.\n\n  var src_offset = 0;\n  var src_size = Math.max(src.byteLength, dest.byteLength); // buffer between convolve passes\n\n  var tmp_offset = this.__align(src_offset + src_size);\n\n  var tmp_size = srcH * destW * 4 * 2; // 2 bytes per channel\n\n  var filtersX_offset = this.__align(tmp_offset + tmp_size);\n\n  var filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength);\n\n  var alloc_bytes = filtersY_offset + filtersY.byteLength;\n\n  var instance = this.__instance('resize', alloc_bytes); //\n  // Fill memory block with data to process\n  //\n\n\n  var mem = new Uint8Array(this.__memory.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer); // 32-bit copy is much faster in chrome\n\n  var src32 = new Uint32Array(src.buffer);\n  mem32.set(src32); // We should guarantee LE bytes order. Filters are not big, so\n  // speed difference is not significant vs direct .set()\n\n  copyInt16asLE(filtersX, mem, filtersX_offset);\n  copyInt16asLE(filtersY, mem, filtersY_offset); // Now call webassembly method\n  // emsdk does method names with '_'\n\n  var fn = instance.exports.convolveHV || instance.exports._convolveHV;\n\n  if (hasAlpha(src, srcW, srcH)) {\n    fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1);\n  } else {\n    fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0);\n    resetAlpha(dest, destW, destH);\n  } //\n  // Copy data back to typed array\n  //\n  // 32-bit copy is much faster in chrome\n\n\n  var dest32 = new Uint32Array(dest.buffer);\n  dest32.set(new Uint32Array(this.__memory.buffer, 0, destH * destW));\n  return dest;\n};\n\n},{\"./resize_filter_gen\":6}],9:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = {\n  name: 'unsharp_mask',\n  fn: _dereq_('./unsharp_mask'),\n  wasm_fn: _dereq_('./unsharp_mask_wasm'),\n  wasm_src: _dereq_('./unsharp_mask_wasm_base64')\n};\n\n},{\"./unsharp_mask\":10,\"./unsharp_mask_wasm\":11,\"./unsharp_mask_wasm_base64\":12}],10:[function(_dereq_,module,exports){\n// Unsharp mask filter\n//\n// http://stackoverflow.com/a/23322820/1031804\n// USM(O) = O + (2 * (Amount / 100) * (O - GB))\n// GB - gaussian blur.\n//\n// Image is converted from RGB to HSV, unsharp mask is applied to the\n// brightness channel and then image is converted back to RGB.\n//\n'use strict';\n\nvar glur_mono16 = _dereq_('glur/mono16');\n\nfunction hsv_v16(img, width, height) {\n  var size = width * height;\n  var out = new Uint16Array(size);\n  var r, g, b, max;\n\n  for (var i = 0; i < size; i++) {\n    r = img[4 * i];\n    g = img[4 * i + 1];\n    b = img[4 * i + 2];\n    max = r >= g && r >= b ? r : g >= b && g >= r ? g : b;\n    out[i] = max << 8;\n  }\n\n  return out;\n}\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  var v1, v2, vmul;\n  var diff, iTimes4;\n\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var brightness = hsv_v16(img, width, height);\n  var blured = new Uint16Array(brightness); // copy, because blur modify src\n\n  glur_mono16(blured, width, height, radius);\n  var amountFp = amount / 100 * 0x1000 + 0.5 | 0;\n  var thresholdFp = threshold << 8;\n  var size = width * height;\n  /* eslint-disable indent */\n\n  for (var i = 0; i < size; i++) {\n    v1 = brightness[i];\n    diff = v1 - blured[i];\n\n    if (Math.abs(diff) >= thresholdFp) {\n      // add unsharp mask to the brightness channel\n      v2 = v1 + (amountFp * diff + 0x800 >> 12); // Both v1 and v2 are within [0.0 .. 255.0] (0000-FF00) range, never going into\n      // [255.003 .. 255.996] (FF01-FFFF). This allows to round this value as (x+.5)|0\n      // later without overflowing.\n\n      v2 = v2 > 0xff00 ? 0xff00 : v2;\n      v2 = v2 < 0x0000 ? 0x0000 : v2; // Avoid division by 0. V=0 means rgb(0,0,0), unsharp with unsharpAmount>0 cannot\n      // change this value (because diff between colors gets inflated), so no need to verify correctness.\n\n      v1 = v1 !== 0 ? v1 : 1; // Multiplying V in HSV model by a constant is equivalent to multiplying each component\n      // in RGB by the same constant (same for HSL), see also:\n      // https://beesbuzz.biz/code/16-hsv-color-transforms\n\n      vmul = (v2 << 12) / v1 | 0; // Result will be in [0..255] range because:\n      //  - all numbers are positive\n      //  - r,g,b <= (v1/256)\n      //  - r,g,b,(v1/256),(v2/256) <= 255\n      // So highest this number can get is X*255/X+0.5=255.5 which is < 256 and rounds down.\n\n      iTimes4 = i * 4;\n      img[iTimes4] = img[iTimes4] * vmul + 0x800 >> 12; // R\n\n      img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12; // G\n\n      img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12; // B\n    }\n  }\n};\n\n},{\"glur/mono16\":18}],11:[function(_dereq_,module,exports){\n'use strict';\n\nmodule.exports = function unsharp(img, width, height, amount, radius, threshold) {\n  if (amount === 0 || radius < 0.5) {\n    return;\n  }\n\n  if (radius > 2.0) {\n    radius = 2.0;\n  }\n\n  var pixels = width * height;\n  var img_bytes_cnt = pixels * 4;\n  var hsv_bytes_cnt = pixels * 2;\n  var blur_bytes_cnt = pixels * 2;\n  var blur_line_byte_cnt = Math.max(width, height) * 4; // float32 array\n\n  var blur_coeffs_byte_cnt = 8 * 4; // float32 array\n\n  var img_offset = 0;\n  var hsv_offset = img_bytes_cnt;\n  var blur_offset = hsv_offset + hsv_bytes_cnt;\n  var blur_tmp_offset = blur_offset + blur_bytes_cnt;\n  var blur_line_offset = blur_tmp_offset + blur_bytes_cnt;\n  var blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt;\n\n  var instance = this.__instance('unsharp_mask', img_bytes_cnt + hsv_bytes_cnt + blur_bytes_cnt * 2 + blur_line_byte_cnt + blur_coeffs_byte_cnt, {\n    exp: Math.exp\n  }); // 32-bit copy is much faster in chrome\n\n\n  var img32 = new Uint32Array(img.buffer);\n  var mem32 = new Uint32Array(this.__memory.buffer);\n  mem32.set(img32); // HSL\n\n  var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;\n  fn(img_offset, hsv_offset, width, height); // BLUR\n\n  fn = instance.exports.blurMono16 || instance.exports._blurMono16;\n  fn(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius); // UNSHARP\n\n  fn = instance.exports.unsharp || instance.exports._unsharp;\n  fn(img_offset, img_offset, hsv_offset, blur_offset, width, height, amount, threshold); // 32-bit copy is much faster in chrome\n\n  img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));\n};\n\n},{}],12:[function(_dereq_,module,exports){\n// This is autogenerated file from math.wasm, don't edit.\n//\n'use strict';\n/* eslint-disable max-len */\n\nmodule.exports = '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';\n\n},{}],13:[function(_dereq_,module,exports){\n'use strict';\n\nvar GC_INTERVAL = 100;\n\nfunction Pool(create, idle) {\n  this.create = create;\n  this.available = [];\n  this.acquired = {};\n  this.lastId = 1;\n  this.timeoutId = 0;\n  this.idle = idle || 2000;\n}\n\nPool.prototype.acquire = function () {\n  var _this = this;\n\n  var resource;\n\n  if (this.available.length !== 0) {\n    resource = this.available.pop();\n  } else {\n    resource = this.create();\n    resource.id = this.lastId++;\n\n    resource.release = function () {\n      return _this.release(resource);\n    };\n  }\n\n  this.acquired[resource.id] = resource;\n  return resource;\n};\n\nPool.prototype.release = function (resource) {\n  var _this2 = this;\n\n  delete this.acquired[resource.id];\n  resource.lastUsed = Date.now();\n  this.available.push(resource);\n\n  if (this.timeoutId === 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this2.gc();\n    }, GC_INTERVAL);\n  }\n};\n\nPool.prototype.gc = function () {\n  var _this3 = this;\n\n  var now = Date.now();\n  this.available = this.available.filter(function (resource) {\n    if (now - resource.lastUsed > _this3.idle) {\n      resource.destroy();\n      return false;\n    }\n\n    return true;\n  });\n\n  if (this.available.length !== 0) {\n    this.timeoutId = setTimeout(function () {\n      return _this3.gc();\n    }, GC_INTERVAL);\n  } else {\n    this.timeoutId = 0;\n  }\n};\n\nmodule.exports = Pool;\n\n},{}],14:[function(_dereq_,module,exports){\n// Add intermediate resizing steps when scaling down by a very large factor.\n//\n// For example, when resizing 10000x10000 down to 10x10, it'll resize it to\n// 300x300 first.\n//\n// It's needed because tiler has issues when the entire tile is scaled down\n// to a few pixels (1024px source tile with border size 3 should result in\n// at least 3+3+2 = 8px target tile, so max scale factor is 128 here).\n//\n// Also, adding intermediate steps can speed up processing if we use lower\n// quality algorithms for first stages.\n//\n'use strict'; // min size = 0 results in infinite loop,\n// min size = 1 can consume large amount of memory\n\nvar MIN_INNER_TILE_SIZE = 2;\n\nmodule.exports = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {\n  var scaleX = toWidth / fromWidth;\n  var scaleY = toHeight / fromHeight; // derived from createRegions equation:\n  // innerTileWidth = pixelFloor(srcTileSize * scaleX) - 2 * destTileBorder;\n\n  var minScale = (2 * destTileBorder + MIN_INNER_TILE_SIZE + 1) / srcTileSize; // refuse to scale image multiple times by less than twice each time,\n  // it could only happen because of invalid options\n\n  if (minScale > 0.5) return [[toWidth, toHeight]];\n  var stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale)); // no additional resizes are necessary,\n  // stageCount can be zero or be negative when enlarging the image\n\n  if (stageCount <= 1) return [[toWidth, toHeight]];\n  var result = [];\n\n  for (var i = 0; i < stageCount; i++) {\n    var width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount));\n    var height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));\n    result.push([width, height]);\n  }\n\n  return result;\n};\n\n},{}],15:[function(_dereq_,module,exports){\n// Split original image into multiple 1024x1024 chunks to reduce memory usage\n// (images have to be unpacked into typed arrays for resizing) and allow\n// parallel processing of multiple tiles at a time.\n//\n'use strict';\n/*\n * pixelFloor and pixelCeil are modified versions of Math.floor and Math.ceil\n * functions which take into account floating point arithmetic errors.\n * Those errors can cause undesired increments/decrements of sizes and offsets:\n * Math.ceil(36 / (36 / 500)) = 501\n * pixelCeil(36 / (36 / 500)) = 500\n */\n\nvar PIXEL_EPSILON = 1e-5;\n\nfunction pixelFloor(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.floor(x);\n}\n\nfunction pixelCeil(x) {\n  var nearest = Math.round(x);\n\n  if (Math.abs(x - nearest) < PIXEL_EPSILON) {\n    return nearest;\n  }\n\n  return Math.ceil(x);\n}\n\nmodule.exports = function createRegions(options) {\n  var scaleX = options.toWidth / options.width;\n  var scaleY = options.toHeight / options.height;\n  var innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder;\n  var innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder; // prevent infinite loop, this should never happen\n\n  if (innerTileWidth < 1 || innerTileHeight < 1) {\n    throw new Error('Internal error in pica: target tile width/height is too small.');\n  }\n\n  var x, y;\n  var innerX, innerY, toTileWidth, toTileHeight;\n  var tiles = [];\n  var tile; // we go top-to-down instead of left-to-right to make image displayed from top to\n  // doesn in the browser\n\n  for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) {\n    for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) {\n      x = innerX - options.destTileBorder;\n\n      if (x < 0) {\n        x = 0;\n      }\n\n      toTileWidth = innerX + innerTileWidth + options.destTileBorder - x;\n\n      if (x + toTileWidth >= options.toWidth) {\n        toTileWidth = options.toWidth - x;\n      }\n\n      y = innerY - options.destTileBorder;\n\n      if (y < 0) {\n        y = 0;\n      }\n\n      toTileHeight = innerY + innerTileHeight + options.destTileBorder - y;\n\n      if (y + toTileHeight >= options.toHeight) {\n        toTileHeight = options.toHeight - y;\n      }\n\n      tile = {\n        toX: x,\n        toY: y,\n        toWidth: toTileWidth,\n        toHeight: toTileHeight,\n        toInnerX: innerX,\n        toInnerY: innerY,\n        toInnerWidth: innerTileWidth,\n        toInnerHeight: innerTileHeight,\n        offsetX: x / scaleX - pixelFloor(x / scaleX),\n        offsetY: y / scaleY - pixelFloor(y / scaleY),\n        scaleX: scaleX,\n        scaleY: scaleY,\n        x: pixelFloor(x / scaleX),\n        y: pixelFloor(y / scaleY),\n        width: pixelCeil(toTileWidth / scaleX),\n        height: pixelCeil(toTileHeight / scaleY)\n      };\n      tiles.push(tile);\n    }\n  }\n\n  return tiles;\n};\n\n},{}],16:[function(_dereq_,module,exports){\n'use strict';\n\nfunction objClass(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nmodule.exports.isCanvas = function isCanvas(element) {\n  var cname = objClass(element);\n  return cname === '[object HTMLCanvasElement]'\n  /* browser */\n  || cname === '[object OffscreenCanvas]' || cname === '[object Canvas]'\n  /* node-canvas */\n  ;\n};\n\nmodule.exports.isImage = function isImage(element) {\n  return objClass(element) === '[object HTMLImageElement]';\n};\n\nmodule.exports.isImageBitmap = function isImageBitmap(element) {\n  return objClass(element) === '[object ImageBitmap]';\n};\n\nmodule.exports.limiter = function limiter(concurrency) {\n  var active = 0,\n      queue = [];\n\n  function roll() {\n    if (active < concurrency && queue.length) {\n      active++;\n      queue.shift()();\n    }\n  }\n\n  return function limit(fn) {\n    return new Promise(function (resolve, reject) {\n      queue.push(function () {\n        fn().then(function (result) {\n          resolve(result);\n          active--;\n          roll();\n        }, function (err) {\n          reject(err);\n          active--;\n          roll();\n        });\n      });\n      roll();\n    });\n  };\n};\n\nmodule.exports.cib_quality_name = function cib_quality_name(num) {\n  switch (num) {\n    case 0:\n      return 'pixelated';\n\n    case 1:\n      return 'low';\n\n    case 2:\n      return 'medium';\n  }\n\n  return 'high';\n};\n\nmodule.exports.cib_support = function cib_support(createCanvas) {\n  return Promise.resolve().then(function () {\n    if (typeof createImageBitmap === 'undefined') {\n      return false;\n    }\n\n    var c = createCanvas(100, 100);\n    return createImageBitmap(c, 0, 0, 100, 100, {\n      resizeWidth: 10,\n      resizeHeight: 10,\n      resizeQuality: 'high'\n    }).then(function (bitmap) {\n      var status = bitmap.width === 10; // Branch below is filtered on upper level. We do not call resize\n      // detection for basic ImageBitmap.\n      //\n      // https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap\n      // old Crome 51 has ImageBitmap without .close(). Then this code\n      // will throw and return 'false' as expected.\n      //\n\n      bitmap.close();\n      c = null;\n      return status;\n    });\n  })[\"catch\"](function () {\n    return false;\n  });\n};\n\nmodule.exports.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {\n  return new Promise(function (resolve, reject) {\n    if (typeof OffscreenCanvas === 'undefined') {\n      // if OffscreenCanvas is present, we assume browser supports Worker and built-in Promise as well\n      resolve(false);\n      return;\n    }\n\n    function workerPayload(self) {\n      if (typeof createImageBitmap === 'undefined') {\n        self.postMessage(false);\n        return;\n      }\n\n      Promise.resolve().then(function () {\n        var canvas = new OffscreenCanvas(10, 10); // test that 2d context can be used in worker\n\n        var ctx = canvas.getContext('2d');\n        ctx.rect(0, 0, 1, 1); // test that cib can be used to return image bitmap from worker\n\n        return createImageBitmap(canvas, 0, 0, 1, 1);\n      }).then(function () {\n        return self.postMessage(true);\n      }, function () {\n        return self.postMessage(false);\n      });\n    }\n\n    var code = btoa(\"(\".concat(workerPayload.toString(), \")(self);\"));\n    var w = new Worker(\"data:text/javascript;base64,\".concat(code));\n\n    w.onmessage = function (ev) {\n      return resolve(ev.data);\n    };\n\n    w.onerror = reject;\n  }).then(function (result) {\n    return result;\n  }, function () {\n    return false;\n  });\n}; // Check if canvas.getContext('2d').getImageData can be used,\n// FireFox randomizes the output of that function in `privacy.resistFingerprinting` mode\n\n\nmodule.exports.can_use_canvas = function can_use_canvas(createCanvas) {\n  var usable = false;\n\n  try {\n    var canvas = createCanvas(2, 1);\n    var ctx = canvas.getContext('2d');\n    var d = ctx.createImageData(2, 1);\n    d.data[0] = 12;\n    d.data[1] = 23;\n    d.data[2] = 34;\n    d.data[3] = 255;\n    d.data[4] = 45;\n    d.data[5] = 56;\n    d.data[6] = 67;\n    d.data[7] = 255;\n    ctx.putImageData(d, 0, 0);\n    d = null;\n    d = ctx.getImageData(0, 0, 2, 1);\n\n    if (d.data[0] === 12 && d.data[1] === 23 && d.data[2] === 34 && d.data[3] === 255 && d.data[4] === 45 && d.data[5] === 56 && d.data[6] === 67 && d.data[7] === 255) {\n      usable = true;\n    }\n  } catch (err) {}\n\n  return usable;\n}; // Check if createImageBitmap(img, sx, sy, sw, sh) signature works correctly\n// with JPEG images oriented with Exif;\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n// TODO: remove after it's fixed in chrome for at least 2 releases\n\n\nmodule.exports.cib_can_use_region = function cib_can_use_region() {\n  return new Promise(function (resolve) {\n    // `Image` check required for use in `ServiceWorker`\n    if (typeof Image === 'undefined' || typeof createImageBitmap === 'undefined') {\n      resolve(false);\n      return;\n    }\n\n    var image = new Image();\n    image.src = 'data:image/jpeg;base64,' + '/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAA' + 'AABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9' + 'sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRc' + 'ZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoa' + 'GhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRA' + 'f/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAA' + 'IQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAA' + 'AAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIB' + 'AT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAA' + 'AAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAA' + 'AAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQ' + 'QAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z';\n\n    image.onload = function () {\n      createImageBitmap(image, 0, 0, image.width, image.height).then(function (bitmap) {\n        if (bitmap.width === image.width && bitmap.height === image.height) {\n          resolve(true);\n        } else {\n          resolve(false);\n        }\n      }, function () {\n        return resolve(false);\n      });\n    };\n\n    image.onerror = function () {\n      return resolve(false);\n    };\n  });\n};\n\n},{}],17:[function(_dereq_,module,exports){\n// Web Worker wrapper for image resize function\n'use strict';\n\nmodule.exports = function () {\n  var MathLib = _dereq_('./mathlib');\n\n  var mathLib;\n  /* eslint-disable no-undef */\n\n  onmessage = function onmessage(ev) {\n    var tileOpts = ev.data.opts;\n    var returnBitmap = false;\n\n    if (!tileOpts.src && tileOpts.srcBitmap) {\n      var canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height);\n      var ctx = canvas.getContext('2d');\n      ctx.drawImage(tileOpts.srcBitmap, 0, 0);\n      tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data;\n      canvas.width = canvas.height = 0;\n      canvas = null;\n      tileOpts.srcBitmap.close();\n      tileOpts.srcBitmap = null; // Temporary force out data to typed array, because Chrome have artefacts\n      // https://github.com/nodeca/pica/issues/223\n      // returnBitmap = true;\n    }\n\n    if (!mathLib) mathLib = new MathLib(ev.data.features); // Use multimath's sync auto-init. Avoid Promise use in old browsers,\n    // because polyfills are not propagated to webworker.\n\n    var data = mathLib.resizeAndUnsharp(tileOpts);\n\n    if (returnBitmap) {\n      var toImageData = new ImageData(new Uint8ClampedArray(data), tileOpts.toWidth, tileOpts.toHeight);\n\n      var _canvas = new OffscreenCanvas(tileOpts.toWidth, tileOpts.toHeight);\n\n      var _ctx = _canvas.getContext('2d');\n\n      _ctx.putImageData(toImageData, 0, 0);\n\n      createImageBitmap(_canvas).then(function (bitmap) {\n        postMessage({\n          bitmap: bitmap\n        }, [bitmap]);\n      });\n    } else {\n      postMessage({\n        data: data\n      }, [data.buffer]);\n    }\n  };\n};\n\n},{\"./mathlib\":1}],18:[function(_dereq_,module,exports){\n// Calculate Gaussian blur of an image using IIR filter\n// The method is taken from Intel's white paper and code example attached to it:\n// https://software.intel.com/en-us/articles/iir-gaussian-blur-filter\n// -implementation-using-intel-advanced-vector-extensions\n\nvar a0, a1, a2, a3, b1, b2, left_corner, right_corner;\n\nfunction gaussCoef(sigma) {\n  if (sigma < 0.5) {\n    sigma = 0.5;\n  }\n\n  var a = Math.exp(0.726 * 0.726) / sigma,\n      g1 = Math.exp(-a),\n      g2 = Math.exp(-2 * a),\n      k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);\n\n  a0 = k;\n  a1 = k * (a - 1) * g1;\n  a2 = k * (a + 1) * g1;\n  a3 = -k * g2;\n  b1 = 2 * g1;\n  b2 = -g2;\n  left_corner = (a0 + a1) / (1 - b1 - b2);\n  right_corner = (a2 + a3) / (1 - b1 - b2);\n\n  // Attempt to force type to FP32.\n  return new Float32Array([ a0, a1, a2, a3, b1, b2, left_corner, right_corner ]);\n}\n\nfunction convolveMono16(src, out, line, coeff, width, height) {\n  // takes src image and writes the blurred and transposed result into out\n\n  var prev_src, curr_src, curr_out, prev_out, prev_prev_out;\n  var src_index, out_index, line_index;\n  var i, j;\n  var coeff_a0, coeff_a1, coeff_b1, coeff_b2;\n\n  for (i = 0; i < height; i++) {\n    src_index = i * width;\n    out_index = i;\n    line_index = 0;\n\n    // left to right\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[6];\n    prev_out = prev_prev_out;\n\n    coeff_a0 = coeff[0];\n    coeff_a1 = coeff[1];\n    coeff_b1 = coeff[4];\n    coeff_b2 = coeff[5];\n\n    for (j = 0; j < width; j++) {\n      curr_src = src[src_index];\n\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n      prev_src = curr_src;\n\n      line[line_index] = prev_out;\n      line_index++;\n      src_index++;\n    }\n\n    src_index--;\n    line_index--;\n    out_index += height * (width - 1);\n\n    // right to left\n    prev_src = src[src_index];\n    prev_prev_out = prev_src * coeff[7];\n    prev_out = prev_prev_out;\n    curr_src = prev_src;\n\n    coeff_a0 = coeff[2];\n    coeff_a1 = coeff[3];\n\n    for (j = width - 1; j >= 0; j--) {\n      curr_out = curr_src * coeff_a0 +\n                 prev_src * coeff_a1 +\n                 prev_out * coeff_b1 +\n                 prev_prev_out * coeff_b2;\n\n      prev_prev_out = prev_out;\n      prev_out = curr_out;\n\n      prev_src = curr_src;\n      curr_src = src[src_index];\n\n      out[out_index] = line[line_index] + prev_out;\n\n      src_index--;\n      line_index--;\n      out_index -= height;\n    }\n  }\n}\n\n\nfunction blurMono16(src, width, height, radius) {\n  // Quick exit on zero radius\n  if (!radius) { return; }\n\n  var out      = new Uint16Array(src.length),\n      tmp_line = new Float32Array(Math.max(width, height));\n\n  var coeff = gaussCoef(radius);\n\n  convolveMono16(src, out, tmp_line, coeff, width, height, radius);\n  convolveMono16(out, src, tmp_line, coeff, height, width, radius);\n}\n\nmodule.exports = blurMono16;\n\n},{}],19:[function(_dereq_,module,exports){\n'use strict';\n\n\nvar assign         = _dereq_('object-assign');\nvar base64decode   = _dereq_('./lib/base64decode');\nvar hasWebAssembly = _dereq_('./lib/wa_detect');\n\n\nvar DEFAULT_OPTIONS = {\n  js: true,\n  wasm: true\n};\n\n\nfunction MultiMath(options) {\n  if (!(this instanceof MultiMath)) return new MultiMath(options);\n\n  var opts = assign({}, DEFAULT_OPTIONS, options || {});\n\n  this.options         = opts;\n\n  this.__cache         = {};\n\n  this.__init_promise  = null;\n  this.__modules       = opts.modules || {};\n  this.__memory        = null;\n  this.__wasm          = {};\n\n  this.__isLE = ((new Uint32Array((new Uint8Array([ 1, 0, 0, 0 ])).buffer))[0] === 1);\n\n  if (!this.options.js && !this.options.wasm) {\n    throw new Error('mathlib: at least \"js\" or \"wasm\" should be enabled');\n  }\n}\n\n\nMultiMath.prototype.has_wasm = hasWebAssembly;\n\n\nMultiMath.prototype.use = function (module) {\n  this.__modules[module.name] = module;\n\n  // Pin the best possible implementation\n  if (this.options.wasm && this.has_wasm() && module.wasm_fn) {\n    this[module.name] = module.wasm_fn;\n  } else {\n    this[module.name] = module.fn;\n  }\n\n  return this;\n};\n\n\nMultiMath.prototype.init = function () {\n  if (this.__init_promise) return this.__init_promise;\n\n  if (!this.options.js && this.options.wasm && !this.has_wasm()) {\n    return Promise.reject(new Error('mathlib: only \"wasm\" was enabled, but it\\'s not supported'));\n  }\n\n  var self = this;\n\n  this.__init_promise = Promise.all(Object.keys(self.__modules).map(function (name) {\n    var module = self.__modules[name];\n\n    if (!self.options.wasm || !self.has_wasm() || !module.wasm_fn) return null;\n\n    // If already compiled - exit\n    if (self.__wasm[name]) return null;\n\n    // Compile wasm source\n    return WebAssembly.compile(self.__base64decode(module.wasm_src))\n      .then(function (m) { self.__wasm[name] = m; });\n  }))\n    .then(function () { return self; });\n\n  return this.__init_promise;\n};\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Methods below are for internal use from plugins\n\n\n// Simple decode base64 to typed array. Useful to load embedded webassembly\n// code. You probably don't need to call this method directly.\n//\nMultiMath.prototype.__base64decode = base64decode;\n\n\n// Increase current memory to include specified number of bytes. Do nothing if\n// size is already ok. You probably don't need to call this method directly,\n// because it will be invoked from `.__instance()`.\n//\nMultiMath.prototype.__reallocate = function mem_grow_to(bytes) {\n  if (!this.__memory) {\n    this.__memory = new WebAssembly.Memory({\n      initial: Math.ceil(bytes / (64 * 1024))\n    });\n    return this.__memory;\n  }\n\n  var mem_size = this.__memory.buffer.byteLength;\n\n  if (mem_size < bytes) {\n    this.__memory.grow(Math.ceil((bytes - mem_size) / (64 * 1024)));\n  }\n\n  return this.__memory;\n};\n\n\n// Returns instantinated webassembly item by name, with specified memory size\n// and environment.\n// - use cache if available\n// - do sync module init, if async init was not called earlier\n// - allocate memory if not enougth\n// - can export functions to webassembly via \"env_extra\",\n//   for example, { exp: Math.exp }\n//\nMultiMath.prototype.__instance = function instance(name, memsize, env_extra) {\n  if (memsize) this.__reallocate(memsize);\n\n  // If .init() was not called, do sync compile\n  if (!this.__wasm[name]) {\n    var module = this.__modules[name];\n    this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));\n  }\n\n  if (!this.__cache[name]) {\n    var env_base = {\n      memoryBase: 0,\n      memory: this.__memory,\n      tableBase: 0,\n      table: new WebAssembly.Table({ initial: 0, element: 'anyfunc' })\n    };\n\n    this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {\n      env: assign(env_base, env_extra || {})\n    });\n  }\n\n  return this.__cache[name];\n};\n\n\n// Helper to calculate memory aligh for pointers. Webassembly does not require\n// this, but you may wish to experiment. Default base = 8;\n//\nMultiMath.prototype.__align = function align(number, base) {\n  base = base || 8;\n  var reminder = number % base;\n  return number + (reminder ? base - reminder : 0);\n};\n\n\nmodule.exports = MultiMath;\n\n},{\"./lib/base64decode\":20,\"./lib/wa_detect\":21,\"object-assign\":22}],20:[function(_dereq_,module,exports){\n// base64 decode str -> Uint8Array, to load WA modules\n//\n'use strict';\n\n\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\nmodule.exports = function base64decode(str) {\n  var input = str.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max   = input.length;\n\n  var out = new Uint8Array((max * 3) >> 2);\n\n  // Collect by 6*4 bits (3 bytes)\n\n  var bits = 0;\n  var ptr  = 0;\n\n  for (var idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      out[ptr++] = (bits >> 16) & 0xFF;\n      out[ptr++] = (bits >> 8) & 0xFF;\n      out[ptr++] = bits & 0xFF;\n    }\n\n    bits = (bits << 6) | BASE64_MAP.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  var tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    out[ptr++] = (bits >> 16) & 0xFF;\n    out[ptr++] = (bits >> 8) & 0xFF;\n    out[ptr++] = bits & 0xFF;\n  } else if (tailbits === 18) {\n    out[ptr++] = (bits >> 10) & 0xFF;\n    out[ptr++] = (bits >> 2) & 0xFF;\n  } else if (tailbits === 12) {\n    out[ptr++] = (bits >> 4) & 0xFF;\n  }\n\n  return out;\n};\n\n},{}],21:[function(_dereq_,module,exports){\n// Detect WebAssembly support.\n// - Check global WebAssembly object\n// - Try to load simple module (can be disabled via CSP)\n//\n'use strict';\n\n\nvar wa;\n\n\nmodule.exports = function hasWebAssembly() {\n  // use cache if called before;\n  if (typeof wa !== 'undefined') return wa;\n\n  wa = false;\n\n  if (typeof WebAssembly === 'undefined') return wa;\n\n  // If WebAssenbly is disabled, code can throw on compile\n  try {\n    // https://github.com/brion/min-wasm-fail/blob/master/min-wasm-fail.in.js\n    // Additional check that WA internals are correct\n\n    /* eslint-disable comma-spacing, max-len */\n    var bin      = new Uint8Array([ 0,97,115,109,1,0,0,0,1,6,1,96,1,127,1,127,3,2,1,0,5,3,1,0,1,7,8,1,4,116,101,115,116,0,0,10,16,1,14,0,32,0,65,1,54,2,0,32,0,40,2,0,11 ]);\n    var module   = new WebAssembly.Module(bin);\n    var instance = new WebAssembly.Instance(module, {});\n\n    // test storing to and loading from a non-zero location via a parameter.\n    // Safari on iOS 11.2.5 returns 0 unexpectedly at non-zero locations\n    if (instance.exports.test(4) !== 0) wa = true;\n\n    return wa;\n  } catch (__) {}\n\n  return wa;\n};\n\n},{}],22:[function(_dereq_,module,exports){\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n},{}],23:[function(_dereq_,module,exports){\nvar bundleFn = arguments[3];\nvar sources = arguments[4];\nvar cache = arguments[5];\n\nvar stringify = JSON.stringify;\n\nmodule.exports = function (fn, options) {\n    var wkey;\n    var cacheKeys = Object.keys(cache);\n\n    for (var i = 0, l = cacheKeys.length; i < l; i++) {\n        var key = cacheKeys[i];\n        var exp = cache[key].exports;\n        // Using babel as a transpiler to use esmodule, the export will always\n        // be an object with the default export as a property of it. To ensure\n        // the existing api and babel esmodule exports are both supported we\n        // check for both\n        if (exp === fn || exp && exp.default === fn) {\n            wkey = key;\n            break;\n        }\n    }\n\n    if (!wkey) {\n        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n        var wcache = {};\n        for (var i = 0, l = cacheKeys.length; i < l; i++) {\n            var key = cacheKeys[i];\n            wcache[key] = key;\n        }\n        sources[wkey] = [\n            'function(require,module,exports){' + fn + '(self); }',\n            wcache\n        ];\n    }\n    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);\n\n    var scache = {}; scache[wkey] = wkey;\n    sources[skey] = [\n        'function(require,module,exports){' +\n            // try to call default if defined to also support babel esmodule exports\n            'var f = require(' + stringify(wkey) + ');' +\n            '(f.default ? f.default : f)(self);' +\n        '}',\n        scache\n    ];\n\n    var workerSources = {};\n    resolveSources(skey);\n\n    function resolveSources(key) {\n        workerSources[key] = true;\n\n        for (var depPath in sources[key][1]) {\n            var depKey = sources[key][1][depPath];\n            if (!workerSources[depKey]) {\n                resolveSources(depKey);\n            }\n        }\n    }\n\n    var src = '(' + bundleFn + ')({'\n        + Object.keys(workerSources).map(function (key) {\n            return stringify(key) + ':['\n                + sources[key][0]\n                + ',' + stringify(sources[key][1]) + ']'\n            ;\n        }).join(',')\n        + '},{},[' + stringify(skey) + '])'\n    ;\n\n    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n    var blob = new Blob([src], { type: 'text/javascript' });\n    if (options && options.bare) { return blob; }\n    var workerUrl = URL.createObjectURL(blob);\n    var worker = new Worker(workerUrl);\n    worker.objectURL = workerUrl;\n    return worker;\n};\n\n},{}],\"/index.js\":[function(_dereq_,module,exports){\n'use strict';\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar assign = _dereq_('object-assign');\n\nvar webworkify = _dereq_('webworkify');\n\nvar MathLib = _dereq_('./lib/mathlib');\n\nvar Pool = _dereq_('./lib/pool');\n\nvar utils = _dereq_('./lib/utils');\n\nvar worker = _dereq_('./lib/worker');\n\nvar createStages = _dereq_('./lib/stepper');\n\nvar createRegions = _dereq_('./lib/tiler');\n\nvar filter_info = _dereq_('./lib/mm_resize/resize_filter_info'); // Deduplicate pools & limiters with the same configs\n// when user creates multiple pica instances.\n\n\nvar singletones = {};\nvar NEED_SAFARI_FIX = false;\n\ntry {\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    NEED_SAFARI_FIX = navigator.userAgent.indexOf('Safari') >= 0;\n  }\n} catch (e) {}\n\nvar concurrency = 1;\n\nif (typeof navigator !== 'undefined') {\n  concurrency = Math.min(navigator.hardwareConcurrency || 1, 4);\n}\n\nvar DEFAULT_PICA_OPTS = {\n  tile: 1024,\n  concurrency: concurrency,\n  features: ['js', 'wasm', 'ww'],\n  idle: 2000,\n  createCanvas: function createCanvas(width, height) {\n    var tmpCanvas = document.createElement('canvas');\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    return tmpCanvas;\n  }\n};\nvar DEFAULT_RESIZE_OPTS = {\n  filter: 'mks2013',\n  unsharpAmount: 0,\n  unsharpRadius: 0.0,\n  unsharpThreshold: 0\n};\nvar CAN_NEW_IMAGE_DATA = false;\nvar CAN_CREATE_IMAGE_BITMAP = false;\nvar CAN_USE_CANVAS_GET_IMAGE_DATA = false;\nvar CAN_USE_OFFSCREEN_CANVAS = false;\nvar CAN_USE_CIB_REGION_FOR_IMAGE = false;\n\nfunction workerFabric() {\n  return {\n    value: webworkify(worker),\n    destroy: function destroy() {\n      this.value.terminate();\n\n      if (typeof window !== 'undefined') {\n        var url = window.URL || window.webkitURL || window.mozURL || window.msURL;\n\n        if (url && url.revokeObjectURL && this.value.objectURL) {\n          url.revokeObjectURL(this.value.objectURL);\n        }\n      }\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n// API methods\n\n\nfunction Pica(options) {\n  if (!(this instanceof Pica)) return new Pica(options);\n  this.options = assign({}, DEFAULT_PICA_OPTS, options || {});\n  var limiter_key = \"lk_\".concat(this.options.concurrency); // Share limiters to avoid multiple parallel workers when user creates\n  // multiple pica instances.\n\n  this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency);\n  if (!singletones[limiter_key]) singletones[limiter_key] = this.__limit; // List of supported features, according to options & browser/node.js\n\n  this.features = {\n    js: false,\n    // pure JS implementation, can be disabled for testing\n    wasm: false,\n    // webassembly implementation for heavy functions\n    cib: false,\n    // resize via createImageBitmap (only FF at this moment)\n    ww: false // webworkers\n\n  };\n  this.__workersPool = null; // Store requested features for webworkers\n\n  this.__requested_features = [];\n  this.__mathlib = null;\n}\n\nPica.prototype.init = function () {\n  var _this = this;\n\n  if (this.__initPromise) return this.__initPromise; // Test if we can create ImageData without canvas and memory copy\n\n  if (typeof ImageData !== 'undefined' && typeof Uint8ClampedArray !== 'undefined') {\n    try {\n      /* eslint-disable no-new */\n      new ImageData(new Uint8ClampedArray(400), 10, 10);\n      CAN_NEW_IMAGE_DATA = true;\n    } catch (__) {}\n  } // ImageBitmap can be effective in 2 places:\n  //\n  // 1. Threaded jpeg unpack (basic)\n  // 2. Built-in resize (blocked due problem in chrome, see issue #89)\n  //\n  // For basic use we also need ImageBitmap wo support .close() method,\n  // see https://developer.mozilla.org/ru/docs/Web/API/ImageBitmap\n\n\n  if (typeof ImageBitmap !== 'undefined') {\n    if (ImageBitmap.prototype && ImageBitmap.prototype.close) {\n      CAN_CREATE_IMAGE_BITMAP = true;\n    } else {\n      this.debug('ImageBitmap does not support .close(), disabled');\n    }\n  }\n\n  var features = this.options.features.slice();\n\n  if (features.indexOf('all') >= 0) {\n    features = ['cib', 'wasm', 'js', 'ww'];\n  }\n\n  this.__requested_features = features;\n  this.__mathlib = new MathLib(features); // Check WebWorker support if requested\n\n  if (features.indexOf('ww') >= 0) {\n    if (typeof window !== 'undefined' && 'Worker' in window) {\n      // IE <= 11 don't allow to create webworkers from string. We should check it.\n      // https://connect.microsoft.com/IE/feedback/details/801810/web-workers-from-blob-urls-in-ie-10-and-11\n      try {\n        var wkr = _dereq_('webworkify')(function () {});\n\n        wkr.terminate();\n        this.features.ww = true; // pool uniqueness depends on pool config + webworker config\n\n        var wpool_key = \"wp_\".concat(JSON.stringify(this.options));\n\n        if (singletones[wpool_key]) {\n          this.__workersPool = singletones[wpool_key];\n        } else {\n          this.__workersPool = new Pool(workerFabric, this.options.idle);\n          singletones[wpool_key] = this.__workersPool;\n        }\n      } catch (__) {}\n    }\n  }\n\n  var initMath = this.__mathlib.init().then(function (mathlib) {\n    // Copy detected features\n    assign(_this.features, mathlib.features);\n  });\n\n  var checkCibResize;\n\n  if (!CAN_CREATE_IMAGE_BITMAP) {\n    checkCibResize = Promise.resolve(false);\n  } else {\n    checkCibResize = utils.cib_support(this.options.createCanvas).then(function (status) {\n      if (_this.features.cib && features.indexOf('cib') < 0) {\n        _this.debug('createImageBitmap() resize supported, but disabled by config');\n\n        return;\n      }\n\n      if (features.indexOf('cib') >= 0) _this.features.cib = status;\n    });\n  }\n\n  CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas);\n  var checkOffscreenCanvas;\n\n  if (CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && features.indexOf('ww') !== -1) {\n    checkOffscreenCanvas = utils.worker_offscreen_canvas_support();\n  } else {\n    checkOffscreenCanvas = Promise.resolve(false);\n  }\n\n  checkOffscreenCanvas = checkOffscreenCanvas.then(function (result) {\n    CAN_USE_OFFSCREEN_CANVAS = result;\n  }); // we use createImageBitmap to crop image data and pass it to workers,\n  // so need to check whether function works correctly;\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n\n  var checkCibRegion = utils.cib_can_use_region().then(function (result) {\n    CAN_USE_CIB_REGION_FOR_IMAGE = result;\n  }); // Init math lib. That's async because can load some\n\n  this.__initPromise = Promise.all([initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion]).then(function () {\n    return _this;\n  });\n  return this.__initPromise;\n}; // Call resizer in webworker or locally, depending on config\n\n\nPica.prototype.__invokeResize = function (tileOpts, opts) {\n  var _this2 = this;\n\n  // Share cache between calls:\n  //\n  // - wasm instance\n  // - wasm memory object\n  //\n  opts.__mathCache = opts.__mathCache || {};\n  return Promise.resolve().then(function () {\n    if (!_this2.features.ww) {\n      // not possible to have ImageBitmap here if user disabled WW\n      return {\n        data: _this2.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)\n      };\n    }\n\n    return new Promise(function (resolve, reject) {\n      var w = _this2.__workersPool.acquire();\n\n      if (opts.cancelToken) opts.cancelToken[\"catch\"](function (err) {\n        return reject(err);\n      });\n\n      w.value.onmessage = function (ev) {\n        w.release();\n        if (ev.data.err) reject(ev.data.err);else resolve(ev.data);\n      };\n\n      var transfer = [];\n      if (tileOpts.src) transfer.push(tileOpts.src.buffer);\n      if (tileOpts.srcBitmap) transfer.push(tileOpts.srcBitmap);\n      w.value.postMessage({\n        opts: tileOpts,\n        features: _this2.__requested_features,\n        preload: {\n          wasm_nodule: _this2.__mathlib.__\n        }\n      }, transfer);\n    });\n  });\n}; // this function can return promise if createImageBitmap is used\n\n\nPica.prototype.__extractTileData = function (tile, from, opts, stageEnv, extractTo) {\n  if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && ( // createImageBitmap doesn't work for images (Image, ImageBitmap) with Exif orientation in Chrome,\n  // can use canvas because canvas doesn't have orientation;\n  // see https://bugs.chromium.org/p/chromium/issues/detail?id=1220671\n  utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) {\n    this.debug('Create tile for OffscreenCanvas');\n    return createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then(function (bitmap) {\n      extractTo.srcBitmap = bitmap;\n      return extractTo;\n    });\n  } // Extract tile RGBA buffer, depending on input type\n\n\n  if (utils.isCanvas(from)) {\n    if (!stageEnv.srcCtx) stageEnv.srcCtx = from.getContext('2d'); // If input is Canvas - extract region data directly\n\n    this.debug('Get tile pixel data');\n    extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data;\n    return extractTo;\n  } // If input is Image or decoded to ImageBitmap,\n  // draw region to temporary canvas and extract data from it\n  //\n  // Note! Attempt to reuse this canvas causes significant slowdown in chrome\n  //\n\n\n  this.debug('Draw tile imageBitmap/image to temporary canvas');\n  var tmpCanvas = this.options.createCanvas(tile.width, tile.height);\n  var tmpCtx = tmpCanvas.getContext('2d');\n  tmpCtx.globalCompositeOperation = 'copy';\n  tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height);\n  this.debug('Get tile pixel data');\n  extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data; // Safari 12 workaround\n  // https://github.com/nodeca/pica/issues/199\n\n  tmpCanvas.width = tmpCanvas.height = 0;\n  return extractTo;\n};\n\nPica.prototype.__landTileData = function (tile, result, stageEnv) {\n  var toImageData;\n  this.debug('Convert raw rgba tile result to ImageData');\n\n  if (result.bitmap) {\n    stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY);\n    return null;\n  }\n\n  if (CAN_NEW_IMAGE_DATA) {\n    // this branch is for modern browsers\n    // If `new ImageData()` & Uint8ClampedArray suported\n    toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight);\n  } else {\n    // fallback for `node-canvas` and old browsers\n    // (IE11 has ImageData but does not support `new ImageData()`)\n    toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight);\n\n    if (toImageData.data.set) {\n      toImageData.data.set(result.data);\n    } else {\n      // IE9 don't have `.set()`\n      for (var i = toImageData.data.length - 1; i >= 0; i--) {\n        toImageData.data[i] = result.data[i];\n      }\n    }\n  }\n\n  this.debug('Draw tile');\n\n  if (NEED_SAFARI_FIX) {\n    // Safari draws thin white stripes between tiles without this fix\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5);\n  } else {\n    stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight);\n  }\n\n  return null;\n};\n\nPica.prototype.__tileAndResize = function (from, to, opts) {\n  var _this3 = this;\n\n  var stageEnv = {\n    srcCtx: null,\n    srcImageBitmap: null,\n    isImageBitmapReused: false,\n    toCtx: null\n  };\n\n  var processTile = function processTile(tile) {\n    return _this3.__limit(function () {\n      if (opts.canceled) return opts.cancelToken;\n      var tileOpts = {\n        width: tile.width,\n        height: tile.height,\n        toWidth: tile.toWidth,\n        toHeight: tile.toHeight,\n        scaleX: tile.scaleX,\n        scaleY: tile.scaleY,\n        offsetX: tile.offsetX,\n        offsetY: tile.offsetY,\n        filter: opts.filter,\n        unsharpAmount: opts.unsharpAmount,\n        unsharpRadius: opts.unsharpRadius,\n        unsharpThreshold: opts.unsharpThreshold\n      };\n\n      _this3.debug('Invoke resize math');\n\n      return Promise.resolve(tileOpts).then(function (tileOpts) {\n        return _this3.__extractTileData(tile, from, opts, stageEnv, tileOpts);\n      }).then(function (tileOpts) {\n        _this3.debug('Invoke resize math');\n\n        return _this3.__invokeResize(tileOpts, opts);\n      }).then(function (result) {\n        if (opts.canceled) return opts.cancelToken;\n        stageEnv.srcImageData = null;\n        return _this3.__landTileData(tile, result, stageEnv);\n      });\n    });\n  }; // Need to normalize data source first. It can be canvas or image.\n  // If image - try to decode in background if possible\n\n\n  return Promise.resolve().then(function () {\n    stageEnv.toCtx = to.getContext('2d');\n    if (utils.isCanvas(from)) return null;\n\n    if (utils.isImageBitmap(from)) {\n      stageEnv.srcImageBitmap = from;\n      stageEnv.isImageBitmapReused = true;\n      return null;\n    }\n\n    if (utils.isImage(from)) {\n      // try do decode image in background for faster next operations;\n      // if we're using offscreen canvas, cib is called per tile, so not needed here\n      if (!CAN_CREATE_IMAGE_BITMAP) return null;\n\n      _this3.debug('Decode image via createImageBitmap');\n\n      return createImageBitmap(from).then(function (imageBitmap) {\n        stageEnv.srcImageBitmap = imageBitmap;\n      }) // Suppress error to use fallback, if method fails\n      // https://github.com/nodeca/pica/issues/190\n\n      /* eslint-disable no-unused-vars */\n      [\"catch\"](function (e) {\n        return null;\n      });\n    }\n\n    throw new Error('Pica: \".from\" should be Image, Canvas or ImageBitmap');\n  }).then(function () {\n    if (opts.canceled) return opts.cancelToken;\n\n    _this3.debug('Calculate tiles'); //\n    // Here we are with \"normalized\" source,\n    // follow to tiling\n    //\n\n\n    var regions = createRegions({\n      width: opts.width,\n      height: opts.height,\n      srcTileSize: _this3.options.tile,\n      toWidth: opts.toWidth,\n      toHeight: opts.toHeight,\n      destTileBorder: opts.__destTileBorder\n    });\n    var jobs = regions.map(function (tile) {\n      return processTile(tile);\n    });\n\n    function cleanup(stageEnv) {\n      if (stageEnv.srcImageBitmap) {\n        if (!stageEnv.isImageBitmapReused) stageEnv.srcImageBitmap.close();\n        stageEnv.srcImageBitmap = null;\n      }\n    }\n\n    _this3.debug('Process tiles');\n\n    return Promise.all(jobs).then(function () {\n      _this3.debug('Finished!');\n\n      cleanup(stageEnv);\n      return to;\n    }, function (err) {\n      cleanup(stageEnv);\n      throw err;\n    });\n  });\n};\n\nPica.prototype.__processStages = function (stages, from, to, opts) {\n  var _this4 = this;\n\n  if (opts.canceled) return opts.cancelToken;\n\n  var _stages$shift = stages.shift(),\n      _stages$shift2 = _slicedToArray(_stages$shift, 2),\n      toWidth = _stages$shift2[0],\n      toHeight = _stages$shift2[1];\n\n  var isLastStage = stages.length === 0; // Optimization for legacy filters -\n  // only use user-defined quality for the last stage,\n  // use simpler (Hamming) filter for the first stages where\n  // scale factor is large enough (more than 2-3)\n  //\n  // For advanced filters (mks2013 and custom) - skip optimization,\n  // because need to apply sharpening every time\n\n  var filter;\n  if (isLastStage || filter_info.q2f.indexOf(opts.filter) < 0) filter = opts.filter;else if (opts.filter === 'box') filter = 'box';else filter = 'hamming';\n  opts = assign({}, opts, {\n    toWidth: toWidth,\n    toHeight: toHeight,\n    filter: filter\n  });\n  var tmpCanvas;\n\n  if (!isLastStage) {\n    // create temporary canvas\n    tmpCanvas = this.options.createCanvas(toWidth, toHeight);\n  }\n\n  return this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then(function () {\n    if (isLastStage) return to;\n    opts.width = toWidth;\n    opts.height = toHeight;\n    return _this4.__processStages(stages, tmpCanvas, to, opts);\n  }).then(function (res) {\n    if (tmpCanvas) {\n      // Safari 12 workaround\n      // https://github.com/nodeca/pica/issues/199\n      tmpCanvas.width = tmpCanvas.height = 0;\n    }\n\n    return res;\n  });\n};\n\nPica.prototype.__resizeViaCreateImageBitmap = function (from, to, opts) {\n  var _this5 = this;\n\n  var toCtx = to.getContext('2d');\n  this.debug('Resize via createImageBitmap()');\n  return createImageBitmap(from, {\n    resizeWidth: opts.toWidth,\n    resizeHeight: opts.toHeight,\n    resizeQuality: utils.cib_quality_name(filter_info.f2q[opts.filter])\n  }).then(function (imageBitmap) {\n    if (opts.canceled) return opts.cancelToken; // if no unsharp - draw directly to output canvas\n\n    if (!opts.unsharpAmount) {\n      toCtx.drawImage(imageBitmap, 0, 0);\n      imageBitmap.close();\n      toCtx = null;\n\n      _this5.debug('Finished!');\n\n      return to;\n    }\n\n    _this5.debug('Unsharp result');\n\n    var tmpCanvas = _this5.options.createCanvas(opts.toWidth, opts.toHeight);\n\n    var tmpCtx = tmpCanvas.getContext('2d');\n    tmpCtx.drawImage(imageBitmap, 0, 0);\n    imageBitmap.close();\n    var iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);\n\n    _this5.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold);\n\n    toCtx.putImageData(iData, 0, 0); // Safari 12 workaround\n    // https://github.com/nodeca/pica/issues/199\n\n    tmpCanvas.width = tmpCanvas.height = 0;\n    iData = tmpCtx = tmpCanvas = toCtx = null;\n\n    _this5.debug('Finished!');\n\n    return to;\n  });\n};\n\nPica.prototype.resize = function (from, to, options) {\n  var _this6 = this;\n\n  this.debug('Start resize...');\n  var opts = assign({}, DEFAULT_RESIZE_OPTS);\n\n  if (!isNaN(options)) {\n    opts = assign(opts, {\n      quality: options\n    });\n  } else if (options) {\n    opts = assign(opts, options);\n  }\n\n  opts.toWidth = to.width;\n  opts.toHeight = to.height;\n  opts.width = from.naturalWidth || from.width;\n  opts.height = from.naturalHeight || from.height; // Legacy `.quality` option\n\n  if (Object.prototype.hasOwnProperty.call(opts, 'quality')) {\n    if (opts.quality < 0 || opts.quality > 3) {\n      throw new Error(\"Pica: .quality should be [0..3], got \".concat(opts.quality));\n    }\n\n    opts.filter = filter_info.q2f[opts.quality];\n  } // Prevent stepper from infinite loop\n\n\n  if (to.width === 0 || to.height === 0) {\n    return Promise.reject(new Error(\"Invalid output size: \".concat(to.width, \"x\").concat(to.height)));\n  }\n\n  if (opts.unsharpRadius > 2) opts.unsharpRadius = 2;\n  opts.canceled = false;\n\n  if (opts.cancelToken) {\n    // Wrap cancelToken to avoid successive resolve & set flag\n    opts.cancelToken = opts.cancelToken.then(function (data) {\n      opts.canceled = true;\n      throw data;\n    }, function (err) {\n      opts.canceled = true;\n      throw err;\n    });\n  }\n\n  var DEST_TILE_BORDER = 3; // Max possible filter window size\n\n  opts.__destTileBorder = Math.ceil(Math.max(DEST_TILE_BORDER, 2.5 * opts.unsharpRadius | 0));\n  return this.init().then(function () {\n    if (opts.canceled) return opts.cancelToken; // if createImageBitmap supports resize, just do it and return\n\n    if (_this6.features.cib) {\n      if (filter_info.q2f.indexOf(opts.filter) >= 0) {\n        return _this6.__resizeViaCreateImageBitmap(from, to, opts);\n      }\n\n      _this6.debug('cib is enabled, but not supports provided filter, fallback to manual math');\n    }\n\n    if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {\n      var err = new Error('Pica: cannot use getImageData on canvas, ' + \"make sure fingerprinting protection isn't enabled\");\n      err.code = 'ERR_GET_IMAGE_DATA';\n      throw err;\n    } //\n    // No easy way, let's resize manually via arrays\n    //\n\n\n    var stages = createStages(opts.width, opts.height, opts.toWidth, opts.toHeight, _this6.options.tile, opts.__destTileBorder);\n    return _this6.__processStages(stages, from, to, opts);\n  });\n}; // RGBA buffer resize\n//\n\n\nPica.prototype.resizeBuffer = function (options) {\n  var _this7 = this;\n\n  var opts = assign({}, DEFAULT_RESIZE_OPTS, options); // Legacy `.quality` option\n\n  if (Object.prototype.hasOwnProperty.call(opts, 'quality')) {\n    if (opts.quality < 0 || opts.quality > 3) {\n      throw new Error(\"Pica: .quality should be [0..3], got \".concat(opts.quality));\n    }\n\n    opts.filter = filter_info.q2f[opts.quality];\n  }\n\n  return this.init().then(function () {\n    return _this7.__mathlib.resizeAndUnsharp(opts);\n  });\n};\n\nPica.prototype.toBlob = function (canvas, mimeType, quality) {\n  mimeType = mimeType || 'image/png';\n  return new Promise(function (resolve) {\n    if (canvas.toBlob) {\n      canvas.toBlob(function (blob) {\n        return resolve(blob);\n      }, mimeType, quality);\n      return;\n    }\n\n    if (canvas.convertToBlob) {\n      resolve(canvas.convertToBlob({\n        type: mimeType,\n        quality: quality\n      }));\n      return;\n    } // Fallback for old browsers\n\n\n    var asString = atob(canvas.toDataURL(mimeType, quality).split(',')[1]);\n    var len = asString.length;\n    var asBuffer = new Uint8Array(len);\n\n    for (var i = 0; i < len; i++) {\n      asBuffer[i] = asString.charCodeAt(i);\n    }\n\n    resolve(new Blob([asBuffer], {\n      type: mimeType\n    }));\n  });\n};\n\nPica.prototype.debug = function () {};\n\nmodule.exports = Pica;\n\n},{\"./lib/mathlib\":1,\"./lib/mm_resize/resize_filter_info\":7,\"./lib/pool\":13,\"./lib/stepper\":14,\"./lib/tiler\":15,\"./lib/utils\":16,\"./lib/worker\":17,\"object-assign\":22,\"webworkify\":23}]},{},[])(\"/index.js\")\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBLHNCQUFzQixpQ0FBaUM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSxtTEFBbUwsRUFBRSxHQUFHO0FBQzNMLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3BpY2EvZGlzdC9waWNhLmpzP2NiOGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5cbnBpY2Fcbmh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYVxuXG4qL1xuXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5waWNhID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb2xsZWN0aW9uIG9mIG1hdGggZnVuY3Rpb25zXG4vL1xuLy8gMS4gQ29tYmluZSBjb21wb25lbnRzIHRvZ2V0aGVyXG4vLyAyLiBIYXMgYXN5bmMgaW5pdCB0byBsb2FkIHdhc20gbW9kdWxlc1xuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIE11bHRpbWF0aCA9IF9kZXJlcV8oJ211bHRpbWF0aCcpO1xuXG52YXIgbW1fdW5zaGFycF9tYXNrID0gX2RlcmVxXygnLi9tbV91bnNoYXJwX21hc2snKTtcblxudmFyIG1tX3Jlc2l6ZSA9IF9kZXJlcV8oJy4vbW1fcmVzaXplJyk7XG5cbmZ1bmN0aW9uIE1hdGhMaWIocmVxdWVzdGVkX2ZlYXR1cmVzKSB7XG4gIHZhciBfX3JlcXVlc3RlZF9mZWF0dXJlcyA9IHJlcXVlc3RlZF9mZWF0dXJlcyB8fCBbXTtcblxuICB2YXIgZmVhdHVyZXMgPSB7XG4gICAganM6IF9fcmVxdWVzdGVkX2ZlYXR1cmVzLmluZGV4T2YoJ2pzJykgPj0gMCxcbiAgICB3YXNtOiBfX3JlcXVlc3RlZF9mZWF0dXJlcy5pbmRleE9mKCd3YXNtJykgPj0gMFxuICB9O1xuICBNdWx0aW1hdGguY2FsbCh0aGlzLCBmZWF0dXJlcyk7XG4gIHRoaXMuZmVhdHVyZXMgPSB7XG4gICAganM6IGZlYXR1cmVzLmpzLFxuICAgIHdhc206IGZlYXR1cmVzLndhc20gJiYgdGhpcy5oYXNfd2FzbSgpXG4gIH07XG4gIHRoaXMudXNlKG1tX3Vuc2hhcnBfbWFzayk7XG4gIHRoaXMudXNlKG1tX3Jlc2l6ZSk7XG59XG5cbk1hdGhMaWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNdWx0aW1hdGgucHJvdG90eXBlKTtcbk1hdGhMaWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWF0aExpYjtcblxuTWF0aExpYi5wcm90b3R5cGUucmVzaXplQW5kVW5zaGFycCA9IGZ1bmN0aW9uIHJlc2l6ZUFuZFVuc2hhcnAob3B0aW9ucywgY2FjaGUpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMucmVzaXplKG9wdGlvbnMsIGNhY2hlKTtcblxuICBpZiAob3B0aW9ucy51bnNoYXJwQW1vdW50KSB7XG4gICAgdGhpcy51bnNoYXJwX21hc2socmVzdWx0LCBvcHRpb25zLnRvV2lkdGgsIG9wdGlvbnMudG9IZWlnaHQsIG9wdGlvbnMudW5zaGFycEFtb3VudCwgb3B0aW9ucy51bnNoYXJwUmFkaXVzLCBvcHRpb25zLnVuc2hhcnBUaHJlc2hvbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0aExpYjtcblxufSx7XCIuL21tX3Jlc2l6ZVwiOjQsXCIuL21tX3Vuc2hhcnBfbWFza1wiOjksXCJtdWx0aW1hdGhcIjoxOX1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gUmVzaXplIGNvbnZvbHZlcnMsIHB1cmUgSlMgaW1wbGVtZW50YXRpb25cbi8vXG4ndXNlIHN0cmljdCc7IC8vIFByZWNpc2lvbiBvZiBmaXhlZCBGUCB2YWx1ZXNcbi8vdmFyIEZJWEVEX0ZSQUNfQklUUyA9IDE0O1xuXG5mdW5jdGlvbiBjbGFtcFRvOChpKSB7XG4gIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbn1cblxuZnVuY3Rpb24gY2xhbXBOZWdhdGl2ZShpKSB7XG4gIHJldHVybiBpID49IDAgPyBpIDogMDtcbn0gLy8gQ29udm9sdmUgaW1hZ2UgZGF0YSBpbiBob3Jpem9udGFsIGRpcmVjdGlvbi4gQ2FuIGJlIHVzZWQgZm9yOlxuLy9cbi8vIDEuIGJpdG1hcCB3aXRoIHByZW11bHRpcGxpZWQgYWxwaGFcbi8vIDIuIGJpdG1hcCB3aXRob3V0IGFscGhhIChhbGwgdmFsdWVzIDI1NSlcbi8vXG4vLyBOb3Rlczpcbi8vXG4vLyAtIG91dHB1dCBpcyB0cmFuc3Bvc2VkXG4vLyAtIG91dHB1dCByZXNvbHV0aW9uIGlzIH4xNSBiaXRzIHBlciBjaGFubmVsKGZvciBiZXR0ZXIgcHJlY2lzaW9uKS5cbi8vXG5cblxuZnVuY3Rpb24gY29udm9sdmVIb3Ioc3JjLCBkZXN0LCBzcmNXLCBzcmNILCBkZXN0VywgZmlsdGVycykge1xuICB2YXIgciwgZywgYiwgYTtcbiAgdmFyIGZpbHRlclB0ciwgZmlsdGVyU2hpZnQsIGZpbHRlclNpemU7XG4gIHZhciBzcmNQdHIsIHNyY1ksIGRlc3RYLCBmaWx0ZXJWYWw7XG4gIHZhciBzcmNPZmZzZXQgPSAwLFxuICAgICAgZGVzdE9mZnNldCA9IDA7IC8vIEZvciBlYWNoIHJvd1xuXG4gIGZvciAoc3JjWSA9IDA7IHNyY1kgPCBzcmNIOyBzcmNZKyspIHtcbiAgICBmaWx0ZXJQdHIgPSAwOyAvLyBBcHBseSBwcmVjb21wdXRlZCBmaWx0ZXJzIHRvIGVhY2ggZGVzdGluYXRpb24gcm93IHBvaW50XG5cbiAgICBmb3IgKGRlc3RYID0gMDsgZGVzdFggPCBkZXN0VzsgZGVzdFgrKykge1xuICAgICAgLy8gR2V0IHRoZSBmaWx0ZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBjdXJyZW50IG91dHB1dCBwaXhlbC5cbiAgICAgIGZpbHRlclNoaWZ0ID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBmaWx0ZXJTaXplID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBzcmNQdHIgPSBzcmNPZmZzZXQgKyBmaWx0ZXJTaGlmdCAqIDQgfCAwO1xuICAgICAgciA9IGcgPSBiID0gYSA9IDA7IC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gdGhlIHJvdyB0byBnZXQgdGhlIGRlc3RpbmF0aW9uIHBpeGVsIHIsIGcsIGIsIGFcblxuICAgICAgZm9yICg7IGZpbHRlclNpemUgPiAwOyBmaWx0ZXJTaXplLS0pIHtcbiAgICAgICAgZmlsdGVyVmFsID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107IC8vIFVzZSByZXZlcnNlIG9yZGVyIHRvIHdvcmthcm91bmQgZGVvcHRzIGluIG9sZCB2OCAobm9kZSB2LjEwKVxuICAgICAgICAvLyBCaWcgdGhhbmtzIHRvIEBtcmFsZXBoIChWeWFjaGVzbGF2IEVnb3JvdikgZm9yIHRoZSB0aXAuXG5cbiAgICAgICAgYSA9IGEgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgM10gfCAwO1xuICAgICAgICBiID0gYiArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAyXSB8IDA7XG4gICAgICAgIGcgPSBnICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDFdIHwgMDtcbiAgICAgICAgciA9IHIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyXSB8IDA7XG4gICAgICAgIHNyY1B0ciA9IHNyY1B0ciArIDQgfCAwO1xuICAgICAgfSAvLyBTdG9yZSAxNSBiaXRzIGJldHdlZW4gcGFzc2VzIGZvciBiZXR0ZXIgcHJlY2lzaW9uXG4gICAgICAvLyBJbnN0ZWFkIG9mIHNoaWZ0IHRvIDE0IChGSVhFRF9GUkFDX0JJVFMpLCBzaGlmdCB0byA3IG9ubHlcbiAgICAgIC8vXG5cblxuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBjbGFtcE5lZ2F0aXZlKGEgPj4gNyk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAyXSA9IGNsYW1wTmVnYXRpdmUoYiA+PiA3KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gY2xhbXBOZWdhdGl2ZShnID4+IDcpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0XSA9IGNsYW1wTmVnYXRpdmUociA+PiA3KTtcbiAgICAgIGRlc3RPZmZzZXQgPSBkZXN0T2Zmc2V0ICsgc3JjSCAqIDQgfCAwO1xuICAgIH1cblxuICAgIGRlc3RPZmZzZXQgPSAoc3JjWSArIDEpICogNCB8IDA7XG4gICAgc3JjT2Zmc2V0ID0gKHNyY1kgKyAxKSAqIHNyY1cgKiA0IHwgMDtcbiAgfVxufSAvLyBTdXBwbGVtZW50YXJ5IG1ldGhvZCBmb3IgYGNvbnZvbHZlSG9yKClgXG4vL1xuXG5cbmZ1bmN0aW9uIGNvbnZvbHZlVmVydChzcmMsIGRlc3QsIHNyY1csIHNyY0gsIGRlc3RXLCBmaWx0ZXJzKSB7XG4gIHZhciByLCBnLCBiLCBhO1xuICB2YXIgZmlsdGVyUHRyLCBmaWx0ZXJTaGlmdCwgZmlsdGVyU2l6ZTtcbiAgdmFyIHNyY1B0ciwgc3JjWSwgZGVzdFgsIGZpbHRlclZhbDtcbiAgdmFyIHNyY09mZnNldCA9IDAsXG4gICAgICBkZXN0T2Zmc2V0ID0gMDsgLy8gRm9yIGVhY2ggcm93XG5cbiAgZm9yIChzcmNZID0gMDsgc3JjWSA8IHNyY0g7IHNyY1krKykge1xuICAgIGZpbHRlclB0ciA9IDA7IC8vIEFwcGx5IHByZWNvbXB1dGVkIGZpbHRlcnMgdG8gZWFjaCBkZXN0aW5hdGlvbiByb3cgcG9pbnRcblxuICAgIGZvciAoZGVzdFggPSAwOyBkZXN0WCA8IGRlc3RXOyBkZXN0WCsrKSB7XG4gICAgICAvLyBHZXQgdGhlIGZpbHRlciB0aGF0IGRldGVybWluZXMgdGhlIGN1cnJlbnQgb3V0cHV0IHBpeGVsLlxuICAgICAgZmlsdGVyU2hpZnQgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIGZpbHRlclNpemUgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTtcbiAgICAgIHNyY1B0ciA9IHNyY09mZnNldCArIGZpbHRlclNoaWZ0ICogNCB8IDA7XG4gICAgICByID0gZyA9IGIgPSBhID0gMDsgLy8gQXBwbHkgdGhlIGZpbHRlciB0byB0aGUgcm93IHRvIGdldCB0aGUgZGVzdGluYXRpb24gcGl4ZWwgciwgZywgYiwgYVxuXG4gICAgICBmb3IgKDsgZmlsdGVyU2l6ZSA+IDA7IGZpbHRlclNpemUtLSkge1xuICAgICAgICBmaWx0ZXJWYWwgPSBmaWx0ZXJzW2ZpbHRlclB0cisrXTsgLy8gVXNlIHJldmVyc2Ugb3JkZXIgdG8gd29ya2Fyb3VuZCBkZW9wdHMgaW4gb2xkIHY4IChub2RlIHYuMTApXG4gICAgICAgIC8vIEJpZyB0aGFua3MgdG8gQG1yYWxlcGggKFZ5YWNoZXNsYXYgRWdvcm92KSBmb3IgdGhlIHRpcC5cblxuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAzXSB8IDA7XG4gICAgICAgIGIgPSBiICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDJdIHwgMDtcbiAgICAgICAgZyA9IGcgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMV0gfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdIHwgMDtcbiAgICAgICAgc3JjUHRyID0gc3JjUHRyICsgNCB8IDA7XG4gICAgICB9IC8vIFN5bmMgd2l0aCBwcmVtdWx0aXBsaWVkIHZlcnNpb24gZm9yIGV4YWN0IHJlc3VsdCBtYXRjaFxuXG5cbiAgICAgIHIgPj49IDc7XG4gICAgICBnID4+PSA3O1xuICAgICAgYiA+Pj0gNztcbiAgICAgIGEgPj49IDc7IC8vIEJyaW5nIHRoaXMgdmFsdWUgYmFjayBpbiByYW5nZSArIHJvdW5kIHJlc3VsdC5cbiAgICAgIC8vXG5cbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDNdID0gY2xhbXBUbzgoYSArICgxIDw8IDEzKSA+PiAxNCk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAyXSA9IGNsYW1wVG84KGIgKyAoMSA8PCAxMykgPj4gMTQpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcFRvOChnICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldF0gPSBjbGFtcFRvOChyICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RPZmZzZXQgPSBkZXN0T2Zmc2V0ICsgc3JjSCAqIDQgfCAwO1xuICAgIH1cblxuICAgIGRlc3RPZmZzZXQgPSAoc3JjWSArIDEpICogNCB8IDA7XG4gICAgc3JjT2Zmc2V0ID0gKHNyY1kgKyAxKSAqIHNyY1cgKiA0IHwgMDtcbiAgfVxufSAvLyBQcmVtdWx0aXBseSAmIGNvbnZvbHZlIGltYWdlIGRhdGEgaW4gaG9yaXpvbnRhbCBkaXJlY3Rpb24uIENhbiBiZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEFueSBiaXRtYXAgZGF0YSwgZXh0cmFjdGVkIHdpdGggYC5nZXRJbWFnZURhdGEoKWAgbWV0aG9kICh3aXRoXG4vLyAgIG5vbi1wcmVtdWx0aXBsaWVkIGFscGhhKVxuLy9cbi8vIEZvciBpbWFnZXMgd2l0aG91dCBhbHBoYSBjaGFubmVsIHRoaXMgbWV0aG9kIGlzIHNsb3dlciB0aGFuIGBjb252b2x2ZUhvcigpYFxuLy9cblxuXG5mdW5jdGlvbiBjb252b2x2ZUhvcldpdGhQcmUoc3JjLCBkZXN0LCBzcmNXLCBzcmNILCBkZXN0VywgZmlsdGVycykge1xuICB2YXIgciwgZywgYiwgYSwgYWxwaGE7XG4gIHZhciBmaWx0ZXJQdHIsIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgc3JjUHRyLCBzcmNZLCBkZXN0WCwgZmlsdGVyVmFsO1xuICB2YXIgc3JjT2Zmc2V0ID0gMCxcbiAgICAgIGRlc3RPZmZzZXQgPSAwOyAvLyBGb3IgZWFjaCByb3dcblxuICBmb3IgKHNyY1kgPSAwOyBzcmNZIDwgc3JjSDsgc3JjWSsrKSB7XG4gICAgZmlsdGVyUHRyID0gMDsgLy8gQXBwbHkgcHJlY29tcHV0ZWQgZmlsdGVycyB0byBlYWNoIGRlc3RpbmF0aW9uIHJvdyBwb2ludFxuXG4gICAgZm9yIChkZXN0WCA9IDA7IGRlc3RYIDwgZGVzdFc7IGRlc3RYKyspIHtcbiAgICAgIC8vIEdldCB0aGUgZmlsdGVyIHRoYXQgZGV0ZXJtaW5lcyB0aGUgY3VycmVudCBvdXRwdXQgcGl4ZWwuXG4gICAgICBmaWx0ZXJTaGlmdCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgZmlsdGVyU2l6ZSA9IGZpbHRlcnNbZmlsdGVyUHRyKytdO1xuICAgICAgc3JjUHRyID0gc3JjT2Zmc2V0ICsgZmlsdGVyU2hpZnQgKiA0IHwgMDtcbiAgICAgIHIgPSBnID0gYiA9IGEgPSAwOyAvLyBBcHBseSB0aGUgZmlsdGVyIHRvIHRoZSByb3cgdG8gZ2V0IHRoZSBkZXN0aW5hdGlvbiBwaXhlbCByLCBnLCBiLCBhXG5cbiAgICAgIGZvciAoOyBmaWx0ZXJTaXplID4gMDsgZmlsdGVyU2l6ZS0tKSB7XG4gICAgICAgIGZpbHRlclZhbCA9IGZpbHRlcnNbZmlsdGVyUHRyKytdOyAvLyBVc2UgcmV2ZXJzZSBvcmRlciB0byB3b3JrYXJvdW5kIGRlb3B0cyBpbiBvbGQgdjggKG5vZGUgdi4xMClcbiAgICAgICAgLy8gQmlnIHRoYW5rcyB0byBAbXJhbGVwaCAoVnlhY2hlc2xhdiBFZ29yb3YpIGZvciB0aGUgdGlwLlxuXG4gICAgICAgIGFscGhhID0gc3JjW3NyY1B0ciArIDNdO1xuICAgICAgICBhID0gYSArIGZpbHRlclZhbCAqIGFscGhhIHwgMDtcbiAgICAgICAgYiA9IGIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgMl0gKiBhbHBoYSB8IDA7XG4gICAgICAgIGcgPSBnICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDFdICogYWxwaGEgfCAwO1xuICAgICAgICByID0gciArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHJdICogYWxwaGEgfCAwO1xuICAgICAgICBzcmNQdHIgPSBzcmNQdHIgKyA0IHwgMDtcbiAgICAgIH0gLy8gUHJlbXVsdGlwbHkgaXMgKCogYWxwaGEgLyAyNTUpLlxuICAgICAgLy8gUG9zdHBvbmUgZGl2aXNpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXG5cbiAgICAgIGIgPSBiIC8gMjU1IHwgMDtcbiAgICAgIGcgPSBnIC8gMjU1IHwgMDtcbiAgICAgIHIgPSByIC8gMjU1IHwgMDsgLy8gU3RvcmUgMTUgYml0cyBiZXR3ZWVuIHBhc3NlcyBmb3IgYmV0dGVyIHByZWNpc2lvblxuICAgICAgLy8gSW5zdGVhZCBvZiBzaGlmdCB0byAxNCAoRklYRURfRlJBQ19CSVRTKSwgc2hpZnQgdG8gNyBvbmx5XG4gICAgICAvL1xuXG4gICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAzXSA9IGNsYW1wTmVnYXRpdmUoYSA+PiA3KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDJdID0gY2xhbXBOZWdhdGl2ZShiID4+IDcpO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMV0gPSBjbGFtcE5lZ2F0aXZlKGcgPj4gNyk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXRdID0gY2xhbXBOZWdhdGl2ZShyID4+IDcpO1xuICAgICAgZGVzdE9mZnNldCA9IGRlc3RPZmZzZXQgKyBzcmNIICogNCB8IDA7XG4gICAgfVxuXG4gICAgZGVzdE9mZnNldCA9IChzcmNZICsgMSkgKiA0IHwgMDtcbiAgICBzcmNPZmZzZXQgPSAoc3JjWSArIDEpICogc3JjVyAqIDQgfCAwO1xuICB9XG59IC8vIFN1cHBsZW1lbnRhcnkgbWV0aG9kIGZvciBgY29udm9sdmVIb3JXaXRoUHJlKClgXG4vL1xuXG5cbmZ1bmN0aW9uIGNvbnZvbHZlVmVydFdpdGhQcmUoc3JjLCBkZXN0LCBzcmNXLCBzcmNILCBkZXN0VywgZmlsdGVycykge1xuICB2YXIgciwgZywgYiwgYTtcbiAgdmFyIGZpbHRlclB0ciwgZmlsdGVyU2hpZnQsIGZpbHRlclNpemU7XG4gIHZhciBzcmNQdHIsIHNyY1ksIGRlc3RYLCBmaWx0ZXJWYWw7XG4gIHZhciBzcmNPZmZzZXQgPSAwLFxuICAgICAgZGVzdE9mZnNldCA9IDA7IC8vIEZvciBlYWNoIHJvd1xuXG4gIGZvciAoc3JjWSA9IDA7IHNyY1kgPCBzcmNIOyBzcmNZKyspIHtcbiAgICBmaWx0ZXJQdHIgPSAwOyAvLyBBcHBseSBwcmVjb21wdXRlZCBmaWx0ZXJzIHRvIGVhY2ggZGVzdGluYXRpb24gcm93IHBvaW50XG5cbiAgICBmb3IgKGRlc3RYID0gMDsgZGVzdFggPCBkZXN0VzsgZGVzdFgrKykge1xuICAgICAgLy8gR2V0IHRoZSBmaWx0ZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBjdXJyZW50IG91dHB1dCBwaXhlbC5cbiAgICAgIGZpbHRlclNoaWZ0ID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBmaWx0ZXJTaXplID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107XG4gICAgICBzcmNQdHIgPSBzcmNPZmZzZXQgKyBmaWx0ZXJTaGlmdCAqIDQgfCAwO1xuICAgICAgciA9IGcgPSBiID0gYSA9IDA7IC8vIEFwcGx5IHRoZSBmaWx0ZXIgdG8gdGhlIHJvdyB0byBnZXQgdGhlIGRlc3RpbmF0aW9uIHBpeGVsIHIsIGcsIGIsIGFcblxuICAgICAgZm9yICg7IGZpbHRlclNpemUgPiAwOyBmaWx0ZXJTaXplLS0pIHtcbiAgICAgICAgZmlsdGVyVmFsID0gZmlsdGVyc1tmaWx0ZXJQdHIrK107IC8vIFVzZSByZXZlcnNlIG9yZGVyIHRvIHdvcmthcm91bmQgZGVvcHRzIGluIG9sZCB2OCAobm9kZSB2LjEwKVxuICAgICAgICAvLyBCaWcgdGhhbmtzIHRvIEBtcmFsZXBoIChWeWFjaGVzbGF2IEVnb3JvdikgZm9yIHRoZSB0aXAuXG5cbiAgICAgICAgYSA9IGEgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyICsgM10gfCAwO1xuICAgICAgICBiID0gYiArIGZpbHRlclZhbCAqIHNyY1tzcmNQdHIgKyAyXSB8IDA7XG4gICAgICAgIGcgPSBnICsgZmlsdGVyVmFsICogc3JjW3NyY1B0ciArIDFdIHwgMDtcbiAgICAgICAgciA9IHIgKyBmaWx0ZXJWYWwgKiBzcmNbc3JjUHRyXSB8IDA7XG4gICAgICAgIHNyY1B0ciA9IHNyY1B0ciArIDQgfCAwO1xuICAgICAgfSAvLyBEb3duc2NhbGUgdG8gbGVhdmUgcm9vbSBmb3IgdW4tcHJlbXVsdGlwbHlcblxuXG4gICAgICByID4+PSA3O1xuICAgICAgZyA+Pj0gNztcbiAgICAgIGIgPj49IDc7XG4gICAgICBhID4+PSA3OyAvLyBVbi1wcmVtdWx0aXBseVxuXG4gICAgICBhID0gY2xhbXBUbzgoYSArICgxIDw8IDEzKSA+PiAxNCk7XG5cbiAgICAgIGlmIChhID4gMCkge1xuICAgICAgICByID0gciAqIDI1NSAvIGEgfCAwO1xuICAgICAgICBnID0gZyAqIDI1NSAvIGEgfCAwO1xuICAgICAgICBiID0gYiAqIDI1NSAvIGEgfCAwO1xuICAgICAgfSAvLyBCcmluZyB0aGlzIHZhbHVlIGJhY2sgaW4gcmFuZ2UgKyByb3VuZCByZXN1bHQuXG4gICAgICAvLyBTaGlmdCB2YWx1ZSA9IEZJWEVEX0ZSQUNfQklUUyArIDdcbiAgICAgIC8vXG5cblxuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBhO1xuICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMl0gPSBjbGFtcFRvOChiICsgKDEgPDwgMTMpID4+IDE0KTtcbiAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gY2xhbXBUbzgoZyArICgxIDw8IDEzKSA+PiAxNCk7XG4gICAgICBkZXN0W2Rlc3RPZmZzZXRdID0gY2xhbXBUbzgociArICgxIDw8IDEzKSA+PiAxNCk7XG4gICAgICBkZXN0T2Zmc2V0ID0gZGVzdE9mZnNldCArIHNyY0ggKiA0IHwgMDtcbiAgICB9XG5cbiAgICBkZXN0T2Zmc2V0ID0gKHNyY1kgKyAxKSAqIDQgfCAwO1xuICAgIHNyY09mZnNldCA9IChzcmNZICsgMSkgKiBzcmNXICogNCB8IDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZvbHZlSG9yOiBjb252b2x2ZUhvcixcbiAgY29udm9sdmVWZXJ0OiBjb252b2x2ZVZlcnQsXG4gIGNvbnZvbHZlSG9yV2l0aFByZTogY29udm9sdmVIb3JXaXRoUHJlLFxuICBjb252b2x2ZVZlcnRXaXRoUHJlOiBjb252b2x2ZVZlcnRXaXRoUHJlXG59O1xuXG59LHt9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlIGZyb20gbWF0aC53YXNtLCBkb24ndCBlZGl0LlxuLy9cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFBREFaa2VXeHBibXNBQUFBQUFBRVlBMkFHZjM5L2YzOS9BR0FBQUdBSWYzOS9mMzkvZjM4QUFnOEJBMlZ1ZGdadFpXMXZjbmtDQUFBREJ3WUJBQUFBQUFJR0JnRi9BRUVBQ3dlVUFRZ1JYMTkzWVhOdFgyTmhiR3hmWTNSdmNuTUFBQXRqYjI1MmIyeDJaVWh2Y2dBQkRHTnZiblp2YkhabFZtVnlkQUFDRW1OdmJuWnZiSFpsU0c5eVYybDBhRkJ5WlFBREUyTnZiblp2YkhabFZtVnlkRmRwZEdoUWNtVUFCQXBqYjI1MmIyeDJaVWhXQUFVTVgxOWtjMjlmYUdGdVpHeGxBd0FZWDE5M1lYTnRYMkZ3Y0d4NVgyUmhkR0ZmY21Wc2IyTnpBQUFLeUE0R0F3QUJDNHdEQVJCL0FrQWdBMFVOQUNBRVJRMEFJQU5CQW5RaEZRTkFRUUFoRTBFQUlRc0RRQ0FMUVFKcUlRY0NmeUFMUVFGMElBVnFJZ1l1QVFJaUMwVUVRRUVBSVFoQkFDRUdRUUFoQ1VFQUlRb2dCd3dCQ3lBU0lBWXVBUUJxSVFoQkFDRUpRUUFoQ2lBTElSUkJBQ0VPSUFjaEJrRUFJUThEUUNBRklBWkJBWFJxTGdFQUloQWdBQ0FJUVFKMGFpZ0NBQ0lSUVJoMmJDQVBhaUVQSUJGQi93RnhJQkJzSUFscUlRa2dFVUVRZGtIL0FYRWdFR3dnRG1vaERpQVJRUWgyUWY4QmNTQVFiQ0FLYWlFS0lBaEJBV29oQ0NBR1FRRnFJUVlnRkVFQmF5SVVEUUFMSUFsQkIzVWhDQ0FLUVFkMUlRWWdEa0VIZFNFSklBOUJCM1VoQ2lBSElBdHFDeUVMSUFFZ0RFRUJkQ0lIYWlBSVFRQWdDRUVBU2hzN0FRQWdBU0FIUVFKeWFpQUdRUUFnQmtFQVNoczdBUUFnQVNBSFFRUnlhaUFKUVFBZ0NVRUFTaHM3QVFBZ0FTQUhRUVp5YWlBS1FRQWdDa0VBU2hzN0FRQWdEQ0FWYWlFTUlCTkJBV29pRXlBRVJ3MEFDeUFOUVFGcUlnMGdBbXdoRWlBTlFRSjBJUXdnQXlBTlJ3MEFDd3NMMmdNQkQzOENRQ0FEUlEwQUlBUkZEUUFnQWtFQ2RDRVVBMEFnQ3lFTVFRQWhFMEVBSVFJRFFDQUNRUUpxSVFZQ2Z5QUNRUUYwSUFWcUlnY3VBUUlpQWtVRVFFRUFJUWhCQUNFSFFRQWhDa0VBSVFrZ0Jnd0JDeUFITGdFQVFRSjBJQkpxSVFoQkFDRUpJQUloQ2tFQUlRMGdCaUVIUVFBaERrRUFJUThEUUNBRklBZEJBWFJxTGdFQUloQWdBQ0FJUVFGMEloRnFMd0VBYkNBSmFpRUpJQUFnRVVFR2Ntb3ZBUUFnRUd3Z0Rtb2hEaUFBSUJGQkJISnFMd0VBSUJCc0lBOXFJUThnQUNBUlFRSnlhaThCQUNBUWJDQU5haUVOSUFoQkJHb2hDQ0FIUVFGcUlRY2dDa0VCYXlJS0RRQUxJQWxCQjNVaENDQU5RUWQxSVFjZ0RrRUhkU0VLSUE5QkIzVWhDU0FDSUFacUN5RUNJQUVnREVFQ2RHb2dCMEdBUUd0QkRuVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iUVFoMFFZRCtBM0VnQ1VHQVFHdEJEblVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYlFSQjBRWUNBL0FkeElBcEJnRUJyUVE1MUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHMEVZZEhKeUlBaEJnRUJyUVE1MUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHM0kyQWdBZ0F5QU1haUVNSUJOQkFXb2lFeUFFUncwQUN5QVVJQXRCQVdvaUMyd2hFaUFESUF0SERRQUxDd3VTQXdFUWZ3SkFJQU5GRFFBZ0JFVU5BQ0FEUVFKMElSVURRRUVBSVJOQkFDRUdBMEFnQmtFQ2FpRUlBbjhnQmtFQmRDQUZhaUlHTGdFQ0lnZEZCRUJCQUNFSlFRQWhERUVBSVExQkFDRU9JQWdNQVFzZ0VpQUdMZ0VBYWlFSlFRQWhEa0VBSVExQkFDRU1JQWNoRkVFQUlROGdDQ0VHQTBBZ0JTQUdRUUYwYWk0QkFDQUFJQWxCQW5ScUtBSUFJaEJCR0hac0loRWdEMm9oRHlBUklCQkJFSFpCL3dGeGJDQU1haUVNSUJFZ0VFRUlka0gvQVhGc0lBMXFJUTBnRVNBUVFmOEJjV3dnRG1vaERpQUpRUUZxSVFrZ0JrRUJhaUVHSUJSQkFXc2lGQTBBQ3lBUFFRZDFJUWtnQnlBSWFnc2hCaUFCSUFwQkFYUWlDR29nRGtIL0FXMUJCM1VpQjBFQUlBZEJBRW9iT3dFQUlBRWdDRUVDY21vZ0RVSC9BVzFCQjNVaUIwRUFJQWRCQUVvYk93RUFJQUVnQ0VFRWNtb2dERUgvQVcxQkIzVWlCMEVBSUFkQkFFb2JPd0VBSUFFZ0NFRUdjbW9nQ1VFQUlBbEJBRW9iT3dFQUlBb2dGV29oQ2lBVFFRRnFJaE1nQkVjTkFBc2dDMEVCYWlJTElBSnNJUklnQzBFQ2RDRUtJQU1nQzBjTkFBc0xDNElFQVE5L0FrQWdBMFVOQUNBRVJRMEFJQUpCQW5RaEZBTkFJQXNoREVFQUlSSkJBQ0VIQTBBZ0IwRUNhaUVLQW44Z0IwRUJkQ0FGYWlJQ0xnRUNJaE5GQkVCQkFDRUlRUUFoQ1VFQUlRWWdDaUVIUVFBTUFRc2dBaTRCQUVFQ2RDQVJhaUVKUVFBaEJ5QVRJUUpCQUNFTklBb2hCa0VBSVE1QkFDRVBBMEFnQlNBR1FRRjBhaTRCQUNJSUlBQWdDVUVCZENJUWFpOEJBR3dnQjJvaEJ5QUFJQkJCQm5KcUx3RUFJQWhzSUE1cUlRNGdBQ0FRUVFSeWFpOEJBQ0FJYkNBUGFpRVBJQUFnRUVFQ2Ntb3ZBUUFnQ0d3Z0RXb2hEU0FKUVFScUlRa2dCa0VCYWlFR0lBSkJBV3NpQWcwQUN5QUhRUWQxSVFnZ0RVRUhkU0VKSUE5QkIzVWhCaUFLSUJOcUlRY2dEa0VIZFF0QmdFQnJRUTUxSWdKQi93RWdBa0gvQVVnYklnSkJBQ0FDUVFCS0d5SUtRZjhCY1FSQUlBbEIvd0ZzSUFKdElRa2dDRUgvQVd3Z0FtMGhDQ0FHUWY4QmJDQUNiU0VHQ3lBQklBeEJBblJxSUFsQmdFQnJRUTUxSWdKQi93RWdBa0gvQVVnYklnSkJBQ0FDUVFCS0cwRUlkRUdBL2dOeElBWkJnRUJyUVE1MUlnSkIvd0VnQWtIL0FVZ2JJZ0pCQUNBQ1FRQktHMEVRZEVHQWdQd0hjU0FLUVJoMGNpQUlRWUJBYTBFT2RTSUNRZjhCSUFKQi93RklHeUlDUVFBZ0FrRUFTaHR5Y2pZQ0FDQURJQXhxSVF3Z0VrRUJhaUlTSUFSSERRQUxJQlFnQzBFQmFpSUxiQ0VSSUFNZ0MwY05BQXNMQzBBQUlBY0VRRUVBSUFJZ0F5QUVJQVVnQUJBRElBSkJBQ0FFSUFVZ0JpQUJFQVFQQzBFQUlBSWdBeUFFSUFVZ0FCQUJJQUpCQUNBRUlBVWdCaUFCRUFJTCc7XG5cbn0se31dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbmFtZTogJ3Jlc2l6ZScsXG4gIGZuOiBfZGVyZXFfKCcuL3Jlc2l6ZScpLFxuICB3YXNtX2ZuOiBfZGVyZXFfKCcuL3Jlc2l6ZV93YXNtJyksXG4gIHdhc21fc3JjOiBfZGVyZXFfKCcuL2NvbnZvbHZlX3dhc21fYmFzZTY0Jylcbn07XG5cbn0se1wiLi9jb252b2x2ZV93YXNtX2Jhc2U2NFwiOjMsXCIuL3Jlc2l6ZVwiOjUsXCIuL3Jlc2l6ZV93YXNtXCI6OH1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRmlsdGVycyA9IF9kZXJlcV8oJy4vcmVzaXplX2ZpbHRlcl9nZW4nKTtcblxudmFyIF9yZXF1aXJlID0gX2RlcmVxXygnLi9jb252b2x2ZScpLFxuICAgIGNvbnZvbHZlSG9yID0gX3JlcXVpcmUuY29udm9sdmVIb3IsXG4gICAgY29udm9sdmVWZXJ0ID0gX3JlcXVpcmUuY29udm9sdmVWZXJ0LFxuICAgIGNvbnZvbHZlSG9yV2l0aFByZSA9IF9yZXF1aXJlLmNvbnZvbHZlSG9yV2l0aFByZSxcbiAgICBjb252b2x2ZVZlcnRXaXRoUHJlID0gX3JlcXVpcmUuY29udm9sdmVWZXJ0V2l0aFByZTtcblxuZnVuY3Rpb24gaGFzQWxwaGEoc3JjLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBwdHIgPSAzLFxuICAgICAgbGVuID0gd2lkdGggKiBoZWlnaHQgKiA0IHwgMDtcblxuICB3aGlsZSAocHRyIDwgbGVuKSB7XG4gICAgaWYgKHNyY1twdHJdICE9PSAyNTUpIHJldHVybiB0cnVlO1xuICAgIHB0ciA9IHB0ciArIDQgfCAwO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiByZXNldEFscGhhKGRzdCwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgcHRyID0gMyxcbiAgICAgIGxlbiA9IHdpZHRoICogaGVpZ2h0ICogNCB8IDA7XG5cbiAgd2hpbGUgKHB0ciA8IGxlbikge1xuICAgIGRzdFtwdHJdID0gMHhGRjtcbiAgICBwdHIgPSBwdHIgKyA0IHwgMDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlc2l6ZShvcHRpb25zKSB7XG4gIHZhciBzcmMgPSBvcHRpb25zLnNyYztcbiAgdmFyIHNyY1cgPSBvcHRpb25zLndpZHRoO1xuICB2YXIgc3JjSCA9IG9wdGlvbnMuaGVpZ2h0O1xuICB2YXIgZGVzdFcgPSBvcHRpb25zLnRvV2lkdGg7XG4gIHZhciBkZXN0SCA9IG9wdGlvbnMudG9IZWlnaHQ7XG4gIHZhciBzY2FsZVggPSBvcHRpb25zLnNjYWxlWCB8fCBvcHRpb25zLnRvV2lkdGggLyBvcHRpb25zLndpZHRoO1xuICB2YXIgc2NhbGVZID0gb3B0aW9ucy5zY2FsZVkgfHwgb3B0aW9ucy50b0hlaWdodCAvIG9wdGlvbnMuaGVpZ2h0O1xuICB2YXIgb2Zmc2V0WCA9IG9wdGlvbnMub2Zmc2V0WCB8fCAwO1xuICB2YXIgb2Zmc2V0WSA9IG9wdGlvbnMub2Zmc2V0WSB8fCAwO1xuICB2YXIgZGVzdCA9IG9wdGlvbnMuZGVzdCB8fCBuZXcgVWludDhBcnJheShkZXN0VyAqIGRlc3RIICogNCk7XG4gIHZhciBmaWx0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICd1bmRlZmluZWQnID8gJ21rczIwMTMnIDogb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBmaWx0ZXJzWCA9IGNyZWF0ZUZpbHRlcnMoZmlsdGVyLCBzcmNXLCBkZXN0Vywgc2NhbGVYLCBvZmZzZXRYKSxcbiAgICAgIGZpbHRlcnNZID0gY3JlYXRlRmlsdGVycyhmaWx0ZXIsIHNyY0gsIGRlc3RILCBzY2FsZVksIG9mZnNldFkpO1xuICB2YXIgdG1wID0gbmV3IFVpbnQxNkFycmF5KGRlc3RXICogc3JjSCAqIDQpOyAvLyBBdXRvZGV0ZWN0IGlmIGFscGhhIGNoYW5uZWwgZXhpc3RzLCBhbmQgdXNlIGFwcHJvcHJpYXRlIG1ldGhvZFxuXG4gIGlmIChoYXNBbHBoYShzcmMsIHNyY1csIHNyY0gpKSB7XG4gICAgY29udm9sdmVIb3JXaXRoUHJlKHNyYywgdG1wLCBzcmNXLCBzcmNILCBkZXN0VywgZmlsdGVyc1gpO1xuICAgIGNvbnZvbHZlVmVydFdpdGhQcmUodG1wLCBkZXN0LCBzcmNILCBkZXN0VywgZGVzdEgsIGZpbHRlcnNZKTtcbiAgfSBlbHNlIHtcbiAgICBjb252b2x2ZUhvcihzcmMsIHRtcCwgc3JjVywgc3JjSCwgZGVzdFcsIGZpbHRlcnNYKTtcbiAgICBjb252b2x2ZVZlcnQodG1wLCBkZXN0LCBzcmNILCBkZXN0VywgZGVzdEgsIGZpbHRlcnNZKTtcbiAgICByZXNldEFscGhhKGRlc3QsIGRlc3RXLCBkZXN0SCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiLi9jb252b2x2ZVwiOjIsXCIuL3Jlc2l6ZV9maWx0ZXJfZ2VuXCI6Nn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ2FsY3VsYXRlIGNvbnZvbHV0aW9uIGZpbHRlcnMgZm9yIGVhY2ggZGVzdGluYXRpb24gcG9pbnQsXG4vLyBhbmQgcGFjayBkYXRhIHRvIEludDE2QXJyYXk6XG4vL1xuLy8gWyBzaGlmdCwgbGVuZ3RoLCBkYXRhLi4uLCBzaGlmdDIsIGxlbmd0aDIsIGRhdGEuLi4sIC4uLiBdXG4vL1xuLy8gLSBzaGlmdCAtIG9mZnNldCBpbiBzcmMgaW1hZ2Vcbi8vIC0gbGVuZ3RoIC0gZmlsdGVyIGxlbmd0aCAoaW4gc3JjIHBvaW50cylcbi8vIC0gZGF0YSAtIGZpbHRlciB2YWx1ZXMgc2VxdWVuY2Vcbi8vXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGSUxURVJfSU5GTyA9IF9kZXJlcV8oJy4vcmVzaXplX2ZpbHRlcl9pbmZvJyk7IC8vIFByZWNpc2lvbiBvZiBmaXhlZCBGUCB2YWx1ZXNcblxuXG52YXIgRklYRURfRlJBQ19CSVRTID0gMTQ7XG5cbmZ1bmN0aW9uIHRvRml4ZWRQb2ludChudW0pIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogKCgxIDw8IEZJWEVEX0ZSQUNfQklUUykgLSAxKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVzaXplRmlsdGVyR2VuKGZpbHRlciwgc3JjU2l6ZSwgZGVzdFNpemUsIHNjYWxlLCBvZmZzZXQpIHtcbiAgdmFyIGZpbHRlckZ1bmN0aW9uID0gRklMVEVSX0lORk8uZmlsdGVyW2ZpbHRlcl0uZm47XG4gIHZhciBzY2FsZUludmVydGVkID0gMS4wIC8gc2NhbGU7XG4gIHZhciBzY2FsZUNsYW1wZWQgPSBNYXRoLm1pbigxLjAsIHNjYWxlKTsgLy8gRm9yIHVwc2NhbGVcbiAgLy8gRmlsdGVyIHdpbmRvdyAoYXZlcmFnaW5nIGludGVydmFsKSwgc2NhbGVkIHRvIHNyYyBpbWFnZVxuXG4gIHZhciBzcmNXaW5kb3cgPSBGSUxURVJfSU5GTy5maWx0ZXJbZmlsdGVyXS53aW4gLyBzY2FsZUNsYW1wZWQ7XG4gIHZhciBkZXN0UGl4ZWwsIHNyY1BpeGVsLCBzcmNGaXJzdCwgc3JjTGFzdCwgZmlsdGVyRWxlbWVudFNpemUsIGZsb2F0RmlsdGVyLCBmeHBGaWx0ZXIsIHRvdGFsLCBweGwsIGlkeCwgZmxvYXRWYWwsIGZpbHRlclRvdGFsLCBmaWx0ZXJWYWw7XG4gIHZhciBsZWZ0Tm90RW1wdHksIHJpZ2h0Tm90RW1wdHksIGZpbHRlclNoaWZ0LCBmaWx0ZXJTaXplO1xuICB2YXIgbWF4RmlsdGVyRWxlbWVudFNpemUgPSBNYXRoLmZsb29yKChzcmNXaW5kb3cgKyAxKSAqIDIpO1xuICB2YXIgcGFja2VkRmlsdGVyID0gbmV3IEludDE2QXJyYXkoKG1heEZpbHRlckVsZW1lbnRTaXplICsgMikgKiBkZXN0U2l6ZSk7XG4gIHZhciBwYWNrZWRGaWx0ZXJQdHIgPSAwO1xuICB2YXIgc2xvd0NvcHkgPSAhcGFja2VkRmlsdGVyLnN1YmFycmF5IHx8ICFwYWNrZWRGaWx0ZXIuc2V0OyAvLyBGb3IgZWFjaCBkZXN0aW5hdGlvbiBwaXhlbCBjYWxjdWxhdGUgc291cmNlIHJhbmdlIGFuZCBidWlsdCBmaWx0ZXIgdmFsdWVzXG5cbiAgZm9yIChkZXN0UGl4ZWwgPSAwOyBkZXN0UGl4ZWwgPCBkZXN0U2l6ZTsgZGVzdFBpeGVsKyspIHtcbiAgICAvLyBTY2FsaW5nIHNob3VsZCBiZSBkb25lIHJlbGF0aXZlIHRvIGNlbnRyYWwgcGl4ZWwgcG9pbnRcbiAgICBzcmNQaXhlbCA9IChkZXN0UGl4ZWwgKyAwLjUpICogc2NhbGVJbnZlcnRlZCArIG9mZnNldDtcbiAgICBzcmNGaXJzdCA9IE1hdGgubWF4KDAsIE1hdGguZmxvb3Ioc3JjUGl4ZWwgLSBzcmNXaW5kb3cpKTtcbiAgICBzcmNMYXN0ID0gTWF0aC5taW4oc3JjU2l6ZSAtIDEsIE1hdGguY2VpbChzcmNQaXhlbCArIHNyY1dpbmRvdykpO1xuICAgIGZpbHRlckVsZW1lbnRTaXplID0gc3JjTGFzdCAtIHNyY0ZpcnN0ICsgMTtcbiAgICBmbG9hdEZpbHRlciA9IG5ldyBGbG9hdDMyQXJyYXkoZmlsdGVyRWxlbWVudFNpemUpO1xuICAgIGZ4cEZpbHRlciA9IG5ldyBJbnQxNkFycmF5KGZpbHRlckVsZW1lbnRTaXplKTtcbiAgICB0b3RhbCA9IDAuMDsgLy8gRmlsbCBmaWx0ZXIgdmFsdWVzIGZvciBjYWxjdWxhdGVkIHJhbmdlXG5cbiAgICBmb3IgKHB4bCA9IHNyY0ZpcnN0LCBpZHggPSAwOyBweGwgPD0gc3JjTGFzdDsgcHhsKyssIGlkeCsrKSB7XG4gICAgICBmbG9hdFZhbCA9IGZpbHRlckZ1bmN0aW9uKChweGwgKyAwLjUgLSBzcmNQaXhlbCkgKiBzY2FsZUNsYW1wZWQpO1xuICAgICAgdG90YWwgKz0gZmxvYXRWYWw7XG4gICAgICBmbG9hdEZpbHRlcltpZHhdID0gZmxvYXRWYWw7XG4gICAgfSAvLyBOb3JtYWxpemUgZmlsdGVyLCBjb252ZXJ0IHRvIGZpeGVkIHBvaW50IGFuZCBhY2N1bXVsYXRlIGNvbnZlcnNpb24gZXJyb3JcblxuXG4gICAgZmlsdGVyVG90YWwgPSAwO1xuXG4gICAgZm9yIChpZHggPSAwOyBpZHggPCBmbG9hdEZpbHRlci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBmaWx0ZXJWYWwgPSBmbG9hdEZpbHRlcltpZHhdIC8gdG90YWw7XG4gICAgICBmaWx0ZXJUb3RhbCArPSBmaWx0ZXJWYWw7XG4gICAgICBmeHBGaWx0ZXJbaWR4XSA9IHRvRml4ZWRQb2ludChmaWx0ZXJWYWwpO1xuICAgIH0gLy8gQ29tcGVuc2F0ZSBub3JtYWxpemF0aW9uIGVycm9yLCB0byBtaW5pbWl6ZSBicmlnaHRuZXNzIGRyaWZ0XG5cblxuICAgIGZ4cEZpbHRlcltkZXN0U2l6ZSA+PiAxXSArPSB0b0ZpeGVkUG9pbnQoMS4wIC0gZmlsdGVyVG90YWwpOyAvL1xuICAgIC8vIE5vdyBwYWNrIGZpbHRlciB0byB1c2VhYmxlIGZvcm1cbiAgICAvL1xuICAgIC8vIDEuIFRyaW0gaGVhZGluZyBhbmQgdGFpbGluZyB6ZXJvIHZhbHVlcywgYW5kIGNvbXBlbnNhdGUgc2hpdGYvbGVuZ3RoXG4gICAgLy8gMi4gUHV0IGFsbCB0byBzaW5nbGUgYXJyYXkgaW4gdGhpcyBmb3JtYXQ6XG4gICAgLy9cbiAgICAvLyAgICBbIHBvcyBzaGlmdCwgZGF0YSBsZW5ndGgsIHZhbHVlMSwgdmFsdWUyLCB2YWx1ZTMsIC4uLiBdXG4gICAgLy9cblxuICAgIGxlZnROb3RFbXB0eSA9IDA7XG5cbiAgICB3aGlsZSAobGVmdE5vdEVtcHR5IDwgZnhwRmlsdGVyLmxlbmd0aCAmJiBmeHBGaWx0ZXJbbGVmdE5vdEVtcHR5XSA9PT0gMCkge1xuICAgICAgbGVmdE5vdEVtcHR5Kys7XG4gICAgfVxuXG4gICAgaWYgKGxlZnROb3RFbXB0eSA8IGZ4cEZpbHRlci5sZW5ndGgpIHtcbiAgICAgIHJpZ2h0Tm90RW1wdHkgPSBmeHBGaWx0ZXIubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHJpZ2h0Tm90RW1wdHkgPiAwICYmIGZ4cEZpbHRlcltyaWdodE5vdEVtcHR5XSA9PT0gMCkge1xuICAgICAgICByaWdodE5vdEVtcHR5LS07XG4gICAgICB9XG5cbiAgICAgIGZpbHRlclNoaWZ0ID0gc3JjRmlyc3QgKyBsZWZ0Tm90RW1wdHk7XG4gICAgICBmaWx0ZXJTaXplID0gcmlnaHROb3RFbXB0eSAtIGxlZnROb3RFbXB0eSArIDE7XG4gICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gZmlsdGVyU2hpZnQ7IC8vIHNoaWZ0XG5cbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSBmaWx0ZXJTaXplOyAvLyBzaXplXG5cbiAgICAgIGlmICghc2xvd0NvcHkpIHtcbiAgICAgICAgcGFja2VkRmlsdGVyLnNldChmeHBGaWx0ZXIuc3ViYXJyYXkobGVmdE5vdEVtcHR5LCByaWdodE5vdEVtcHR5ICsgMSksIHBhY2tlZEZpbHRlclB0cik7XG4gICAgICAgIHBhY2tlZEZpbHRlclB0ciArPSBmaWx0ZXJTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgZm9yIG9sZCBJRSA8IDExLCB3aXRob3V0IHN1YmFycmF5L3NldCBtZXRob2RzXG4gICAgICAgIGZvciAoaWR4ID0gbGVmdE5vdEVtcHR5OyBpZHggPD0gcmlnaHROb3RFbXB0eTsgaWR4KyspIHtcbiAgICAgICAgICBwYWNrZWRGaWx0ZXJbcGFja2VkRmlsdGVyUHRyKytdID0gZnhwRmlsdGVyW2lkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gemVybyBkYXRhLCB3cml0ZSBoZWFkZXIgb25seVxuICAgICAgcGFja2VkRmlsdGVyW3BhY2tlZEZpbHRlclB0cisrXSA9IDA7IC8vIHNoaWZ0XG5cbiAgICAgIHBhY2tlZEZpbHRlcltwYWNrZWRGaWx0ZXJQdHIrK10gPSAwOyAvLyBzaXplXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhY2tlZEZpbHRlcjtcbn07XG5cbn0se1wiLi9yZXNpemVfZmlsdGVyX2luZm9cIjo3fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBGaWx0ZXIgZGVmaW5pdGlvbnMgdG8gYnVpbGQgdGFibGVzIGZvclxuLy8gcmVzaXppbmcgY29udm9sdmVycy5cbi8vXG4vLyBQcmVzZXRzIGZvciBxdWFsaXR5IDAuLjMuIEZpbHRlciBmdW5jdGlvbnMgKyB3aW5kb3cgc2l6ZVxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIGZpbHRlciA9IHtcbiAgLy8gTmVhcmVzdCBuZWlib3JcbiAgYm94OiB7XG4gICAgd2luOiAwLjUsXG4gICAgZm46IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIGlmICh4IDwgMCkgeCA9IC14O1xuICAgICAgcmV0dXJuIHggPCAwLjUgPyAxLjAgOiAwLjA7XG4gICAgfVxuICB9LFxuICAvLyAvLyBIYW1taW5nXG4gIGhhbW1pbmc6IHtcbiAgICB3aW46IDEuMCxcbiAgICBmbjogZnVuY3Rpb24gZm4oeCkge1xuICAgICAgaWYgKHggPCAwKSB4ID0gLXg7XG5cbiAgICAgIGlmICh4ID49IDEuMCkge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICAgIHJldHVybiAxLjA7XG4gICAgICB9XG5cbiAgICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICAgIHJldHVybiBNYXRoLnNpbih4cGkpIC8geHBpICogKDAuNTQgKyAwLjQ2ICogTWF0aC5jb3MoeHBpIC8gMS4wKSk7XG4gICAgfVxuICB9LFxuICAvLyBMYW5jem9zLCB3aW4gPSAyXG4gIGxhbmN6b3MyOiB7XG4gICAgd2luOiAyLjAsXG4gICAgZm46IGZ1bmN0aW9uIGZuKHgpIHtcbiAgICAgIGlmICh4IDwgMCkgeCA9IC14O1xuXG4gICAgICBpZiAoeCA+PSAyLjApIHtcbiAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHggPCAxLjE5MjA5MjkwRS0wNykge1xuICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgfVxuXG4gICAgICB2YXIgeHBpID0geCAqIE1hdGguUEk7XG4gICAgICByZXR1cm4gTWF0aC5zaW4oeHBpKSAvIHhwaSAqIE1hdGguc2luKHhwaSAvIDIuMCkgLyAoeHBpIC8gMi4wKTtcbiAgICB9XG4gIH0sXG4gIC8vIExhbmN6b3MsIHdpbiA9IDNcbiAgbGFuY3pvczM6IHtcbiAgICB3aW46IDMuMCxcbiAgICBmbjogZnVuY3Rpb24gZm4oeCkge1xuICAgICAgaWYgKHggPCAwKSB4ID0gLXg7XG5cbiAgICAgIGlmICh4ID49IDMuMCkge1xuICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IDEuMTkyMDkyOTBFLTA3KSB7XG4gICAgICAgIHJldHVybiAxLjA7XG4gICAgICB9XG5cbiAgICAgIHZhciB4cGkgPSB4ICogTWF0aC5QSTtcbiAgICAgIHJldHVybiBNYXRoLnNpbih4cGkpIC8geHBpICogTWF0aC5zaW4oeHBpIC8gMy4wKSAvICh4cGkgLyAzLjApO1xuICAgIH1cbiAgfSxcbiAgLy8gTWFnaWMgS2VybmVsIFNoYXJwIDIwMTMsIHdpbiA9IDIuNVxuICAvLyBodHRwOi8vam9obmNvc3RlbGxhLmNvbS9tYWdpYy9cbiAgbWtzMjAxMzoge1xuICAgIHdpbjogMi41LFxuICAgIGZuOiBmdW5jdGlvbiBmbih4KSB7XG4gICAgICBpZiAoeCA8IDApIHggPSAteDtcblxuICAgICAgaWYgKHggPj0gMi41KSB7XG4gICAgICAgIHJldHVybiAwLjA7XG4gICAgICB9XG5cbiAgICAgIGlmICh4ID49IDEuNSkge1xuICAgICAgICByZXR1cm4gLTAuMTI1ICogKHggLSAyLjUpICogKHggLSAyLjUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA+PSAwLjUpIHtcbiAgICAgICAgcmV0dXJuIDAuMjUgKiAoNCAqIHggKiB4IC0gMTEgKiB4ICsgNyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxLjA2MjUgLSAxLjc1ICogeCAqIHg7XG4gICAgfVxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbHRlcjogZmlsdGVyLFxuICAvLyBMZWdhY3kgbWFwcGluZ1xuICBmMnE6IHtcbiAgICBib3g6IDAsXG4gICAgaGFtbWluZzogMSxcbiAgICBsYW5jem9zMjogMixcbiAgICBsYW5jem9zMzogM1xuICB9LFxuICBxMmY6IFsnYm94JywgJ2hhbW1pbmcnLCAnbGFuY3pvczInLCAnbGFuY3pvczMnXVxufTtcblxufSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVGaWx0ZXJzID0gX2RlcmVxXygnLi9yZXNpemVfZmlsdGVyX2dlbicpO1xuXG5mdW5jdGlvbiBoYXNBbHBoYShzcmMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHB0ciA9IDMsXG4gICAgICBsZW4gPSB3aWR0aCAqIGhlaWdodCAqIDQgfCAwO1xuXG4gIHdoaWxlIChwdHIgPCBsZW4pIHtcbiAgICBpZiAoc3JjW3B0cl0gIT09IDI1NSkgcmV0dXJuIHRydWU7XG4gICAgcHRyID0gcHRyICsgNCB8IDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc2V0QWxwaGEoZHN0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBwdHIgPSAzLFxuICAgICAgbGVuID0gd2lkdGggKiBoZWlnaHQgKiA0IHwgMDtcblxuICB3aGlsZSAocHRyIDwgbGVuKSB7XG4gICAgZHN0W3B0cl0gPSAweEZGO1xuICAgIHB0ciA9IHB0ciArIDQgfCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzVWludDhBcnJheShzcmMpIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIDAsIHNyYy5ieXRlTGVuZ3RoKTtcbn1cblxudmFyIElTX0xFID0gdHJ1ZTsgLy8gc2hvdWxkIG5vdCBjcmFzaCBldmVyeXRoaW5nIG9uIG1vZHVsZSBsb2FkIGluIG9sZCBicm93c2Vyc1xuXG50cnkge1xuICBJU19MRSA9IG5ldyBVaW50MzJBcnJheShuZXcgVWludDhBcnJheShbMSwgMCwgMCwgMF0pLmJ1ZmZlcilbMF0gPT09IDE7XG59IGNhdGNoIChfXykge31cblxuZnVuY3Rpb24gY29weUludDE2YXNMRShzcmMsIHRhcmdldCwgdGFyZ2V0X29mZnNldCkge1xuICBpZiAoSVNfTEUpIHtcbiAgICB0YXJnZXQuc2V0KGFzVWludDhBcnJheShzcmMpLCB0YXJnZXRfb2Zmc2V0KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBwdHIgPSB0YXJnZXRfb2Zmc2V0LCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkYXRhID0gc3JjW2ldO1xuICAgIHRhcmdldFtwdHIrK10gPSBkYXRhICYgMHhGRjtcbiAgICB0YXJnZXRbcHRyKytdID0gZGF0YSA+PiA4ICYgMHhGRjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlc2l6ZV93YXNtKG9wdGlvbnMpIHtcbiAgdmFyIHNyYyA9IG9wdGlvbnMuc3JjO1xuICB2YXIgc3JjVyA9IG9wdGlvbnMud2lkdGg7XG4gIHZhciBzcmNIID0gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBkZXN0VyA9IG9wdGlvbnMudG9XaWR0aDtcbiAgdmFyIGRlc3RIID0gb3B0aW9ucy50b0hlaWdodDtcbiAgdmFyIHNjYWxlWCA9IG9wdGlvbnMuc2NhbGVYIHx8IG9wdGlvbnMudG9XaWR0aCAvIG9wdGlvbnMud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBvcHRpb25zLnNjYWxlWSB8fCBvcHRpb25zLnRvSGVpZ2h0IC8gb3B0aW9ucy5oZWlnaHQ7XG4gIHZhciBvZmZzZXRYID0gb3B0aW9ucy5vZmZzZXRYIHx8IDAuMDtcbiAgdmFyIG9mZnNldFkgPSBvcHRpb25zLm9mZnNldFkgfHwgMC4wO1xuICB2YXIgZGVzdCA9IG9wdGlvbnMuZGVzdCB8fCBuZXcgVWludDhBcnJheShkZXN0VyAqIGRlc3RIICogNCk7XG4gIHZhciBmaWx0ZXIgPSB0eXBlb2Ygb3B0aW9ucy5maWx0ZXIgPT09ICd1bmRlZmluZWQnID8gJ21rczIwMTMnIDogb3B0aW9ucy5maWx0ZXI7XG4gIHZhciBmaWx0ZXJzWCA9IGNyZWF0ZUZpbHRlcnMoZmlsdGVyLCBzcmNXLCBkZXN0Vywgc2NhbGVYLCBvZmZzZXRYKSxcbiAgICAgIGZpbHRlcnNZID0gY3JlYXRlRmlsdGVycyhmaWx0ZXIsIHNyY0gsIGRlc3RILCBzY2FsZVksIG9mZnNldFkpOyAvLyBkZXN0aW5hdGlvbiBpcyAwIHRvby5cblxuICB2YXIgc3JjX29mZnNldCA9IDA7XG4gIHZhciBzcmNfc2l6ZSA9IE1hdGgubWF4KHNyYy5ieXRlTGVuZ3RoLCBkZXN0LmJ5dGVMZW5ndGgpOyAvLyBidWZmZXIgYmV0d2VlbiBjb252b2x2ZSBwYXNzZXNcblxuICB2YXIgdG1wX29mZnNldCA9IHRoaXMuX19hbGlnbihzcmNfb2Zmc2V0ICsgc3JjX3NpemUpO1xuXG4gIHZhciB0bXBfc2l6ZSA9IHNyY0ggKiBkZXN0VyAqIDQgKiAyOyAvLyAyIGJ5dGVzIHBlciBjaGFubmVsXG5cbiAgdmFyIGZpbHRlcnNYX29mZnNldCA9IHRoaXMuX19hbGlnbih0bXBfb2Zmc2V0ICsgdG1wX3NpemUpO1xuXG4gIHZhciBmaWx0ZXJzWV9vZmZzZXQgPSB0aGlzLl9fYWxpZ24oZmlsdGVyc1hfb2Zmc2V0ICsgZmlsdGVyc1guYnl0ZUxlbmd0aCk7XG5cbiAgdmFyIGFsbG9jX2J5dGVzID0gZmlsdGVyc1lfb2Zmc2V0ICsgZmlsdGVyc1kuYnl0ZUxlbmd0aDtcblxuICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9faW5zdGFuY2UoJ3Jlc2l6ZScsIGFsbG9jX2J5dGVzKTsgLy9cbiAgLy8gRmlsbCBtZW1vcnkgYmxvY2sgd2l0aCBkYXRhIHRvIHByb2Nlc3NcbiAgLy9cblxuXG4gIHZhciBtZW0gPSBuZXcgVWludDhBcnJheSh0aGlzLl9fbWVtb3J5LmJ1ZmZlcik7XG4gIHZhciBtZW0zMiA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9fbWVtb3J5LmJ1ZmZlcik7IC8vIDMyLWJpdCBjb3B5IGlzIG11Y2ggZmFzdGVyIGluIGNocm9tZVxuXG4gIHZhciBzcmMzMiA9IG5ldyBVaW50MzJBcnJheShzcmMuYnVmZmVyKTtcbiAgbWVtMzIuc2V0KHNyYzMyKTsgLy8gV2Ugc2hvdWxkIGd1YXJhbnRlZSBMRSBieXRlcyBvcmRlci4gRmlsdGVycyBhcmUgbm90IGJpZywgc29cbiAgLy8gc3BlZWQgZGlmZmVyZW5jZSBpcyBub3Qgc2lnbmlmaWNhbnQgdnMgZGlyZWN0IC5zZXQoKVxuXG4gIGNvcHlJbnQxNmFzTEUoZmlsdGVyc1gsIG1lbSwgZmlsdGVyc1hfb2Zmc2V0KTtcbiAgY29weUludDE2YXNMRShmaWx0ZXJzWSwgbWVtLCBmaWx0ZXJzWV9vZmZzZXQpOyAvLyBOb3cgY2FsbCB3ZWJhc3NlbWJseSBtZXRob2RcbiAgLy8gZW1zZGsgZG9lcyBtZXRob2QgbmFtZXMgd2l0aCAnXydcblxuICB2YXIgZm4gPSBpbnN0YW5jZS5leHBvcnRzLmNvbnZvbHZlSFYgfHwgaW5zdGFuY2UuZXhwb3J0cy5fY29udm9sdmVIVjtcblxuICBpZiAoaGFzQWxwaGEoc3JjLCBzcmNXLCBzcmNIKSkge1xuICAgIGZuKGZpbHRlcnNYX29mZnNldCwgZmlsdGVyc1lfb2Zmc2V0LCB0bXBfb2Zmc2V0LCBzcmNXLCBzcmNILCBkZXN0VywgZGVzdEgsIDEpO1xuICB9IGVsc2Uge1xuICAgIGZuKGZpbHRlcnNYX29mZnNldCwgZmlsdGVyc1lfb2Zmc2V0LCB0bXBfb2Zmc2V0LCBzcmNXLCBzcmNILCBkZXN0VywgZGVzdEgsIDApO1xuICAgIHJlc2V0QWxwaGEoZGVzdCwgZGVzdFcsIGRlc3RIKTtcbiAgfSAvL1xuICAvLyBDb3B5IGRhdGEgYmFjayB0byB0eXBlZCBhcnJheVxuICAvL1xuICAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuXG4gIHZhciBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuICBkZXN0MzIuc2V0KG5ldyBVaW50MzJBcnJheSh0aGlzLl9fbWVtb3J5LmJ1ZmZlciwgMCwgZGVzdEggKiBkZXN0VykpO1xuICByZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiLi9yZXNpemVfZmlsdGVyX2dlblwiOjZ9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd1bnNoYXJwX21hc2snLFxuICBmbjogX2RlcmVxXygnLi91bnNoYXJwX21hc2snKSxcbiAgd2FzbV9mbjogX2RlcmVxXygnLi91bnNoYXJwX21hc2tfd2FzbScpLFxuICB3YXNtX3NyYzogX2RlcmVxXygnLi91bnNoYXJwX21hc2tfd2FzbV9iYXNlNjQnKVxufTtcblxufSx7XCIuL3Vuc2hhcnBfbWFza1wiOjEwLFwiLi91bnNoYXJwX21hc2tfd2FzbVwiOjExLFwiLi91bnNoYXJwX21hc2tfd2FzbV9iYXNlNjRcIjoxMn1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFVuc2hhcnAgbWFzayBmaWx0ZXJcbi8vXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzMyMjgyMC8xMDMxODA0XG4vLyBVU00oTykgPSBPICsgKDIgKiAoQW1vdW50IC8gMTAwKSAqIChPIC0gR0IpKVxuLy8gR0IgLSBnYXVzc2lhbiBibHVyLlxuLy9cbi8vIEltYWdlIGlzIGNvbnZlcnRlZCBmcm9tIFJHQiB0byBIU1YsIHVuc2hhcnAgbWFzayBpcyBhcHBsaWVkIHRvIHRoZVxuLy8gYnJpZ2h0bmVzcyBjaGFubmVsIGFuZCB0aGVuIGltYWdlIGlzIGNvbnZlcnRlZCBiYWNrIHRvIFJHQi5cbi8vXG4ndXNlIHN0cmljdCc7XG5cbnZhciBnbHVyX21vbm8xNiA9IF9kZXJlcV8oJ2dsdXIvbW9ubzE2Jyk7XG5cbmZ1bmN0aW9uIGhzdl92MTYoaW1nLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XG4gIHZhciBvdXQgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gIHZhciByLCBnLCBiLCBtYXg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICByID0gaW1nWzQgKiBpXTtcbiAgICBnID0gaW1nWzQgKiBpICsgMV07XG4gICAgYiA9IGltZ1s0ICogaSArIDJdO1xuICAgIG1heCA9IHIgPj0gZyAmJiByID49IGIgPyByIDogZyA+PSBiICYmIGcgPj0gciA/IGcgOiBiO1xuICAgIG91dFtpXSA9IG1heCA8PCA4O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bnNoYXJwKGltZywgd2lkdGgsIGhlaWdodCwgYW1vdW50LCByYWRpdXMsIHRocmVzaG9sZCkge1xuICB2YXIgdjEsIHYyLCB2bXVsO1xuICB2YXIgZGlmZiwgaVRpbWVzNDtcblxuICBpZiAoYW1vdW50ID09PSAwIHx8IHJhZGl1cyA8IDAuNSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyYWRpdXMgPiAyLjApIHtcbiAgICByYWRpdXMgPSAyLjA7XG4gIH1cblxuICB2YXIgYnJpZ2h0bmVzcyA9IGhzdl92MTYoaW1nLCB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIGJsdXJlZCA9IG5ldyBVaW50MTZBcnJheShicmlnaHRuZXNzKTsgLy8gY29weSwgYmVjYXVzZSBibHVyIG1vZGlmeSBzcmNcblxuICBnbHVyX21vbm8xNihibHVyZWQsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG4gIHZhciBhbW91bnRGcCA9IGFtb3VudCAvIDEwMCAqIDB4MTAwMCArIDAuNSB8IDA7XG4gIHZhciB0aHJlc2hvbGRGcCA9IHRocmVzaG9sZCA8PCA4O1xuICB2YXIgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAvKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHYxID0gYnJpZ2h0bmVzc1tpXTtcbiAgICBkaWZmID0gdjEgLSBibHVyZWRbaV07XG5cbiAgICBpZiAoTWF0aC5hYnMoZGlmZikgPj0gdGhyZXNob2xkRnApIHtcbiAgICAgIC8vIGFkZCB1bnNoYXJwIG1hc2sgdG8gdGhlIGJyaWdodG5lc3MgY2hhbm5lbFxuICAgICAgdjIgPSB2MSArIChhbW91bnRGcCAqIGRpZmYgKyAweDgwMCA+PiAxMik7IC8vIEJvdGggdjEgYW5kIHYyIGFyZSB3aXRoaW4gWzAuMCAuLiAyNTUuMF0gKDAwMDAtRkYwMCkgcmFuZ2UsIG5ldmVyIGdvaW5nIGludG9cbiAgICAgIC8vIFsyNTUuMDAzIC4uIDI1NS45OTZdIChGRjAxLUZGRkYpLiBUaGlzIGFsbG93cyB0byByb3VuZCB0aGlzIHZhbHVlIGFzICh4Ky41KXwwXG4gICAgICAvLyBsYXRlciB3aXRob3V0IG92ZXJmbG93aW5nLlxuXG4gICAgICB2MiA9IHYyID4gMHhmZjAwID8gMHhmZjAwIDogdjI7XG4gICAgICB2MiA9IHYyIDwgMHgwMDAwID8gMHgwMDAwIDogdjI7IC8vIEF2b2lkIGRpdmlzaW9uIGJ5IDAuIFY9MCBtZWFucyByZ2IoMCwwLDApLCB1bnNoYXJwIHdpdGggdW5zaGFycEFtb3VudD4wIGNhbm5vdFxuICAgICAgLy8gY2hhbmdlIHRoaXMgdmFsdWUgKGJlY2F1c2UgZGlmZiBiZXR3ZWVuIGNvbG9ycyBnZXRzIGluZmxhdGVkKSwgc28gbm8gbmVlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3MuXG5cbiAgICAgIHYxID0gdjEgIT09IDAgPyB2MSA6IDE7IC8vIE11bHRpcGx5aW5nIFYgaW4gSFNWIG1vZGVsIGJ5IGEgY29uc3RhbnQgaXMgZXF1aXZhbGVudCB0byBtdWx0aXBseWluZyBlYWNoIGNvbXBvbmVudFxuICAgICAgLy8gaW4gUkdCIGJ5IHRoZSBzYW1lIGNvbnN0YW50IChzYW1lIGZvciBIU0wpLCBzZWUgYWxzbzpcbiAgICAgIC8vIGh0dHBzOi8vYmVlc2J1enouYml6L2NvZGUvMTYtaHN2LWNvbG9yLXRyYW5zZm9ybXNcblxuICAgICAgdm11bCA9ICh2MiA8PCAxMikgLyB2MSB8IDA7IC8vIFJlc3VsdCB3aWxsIGJlIGluIFswLi4yNTVdIHJhbmdlIGJlY2F1c2U6XG4gICAgICAvLyAgLSBhbGwgbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICAgIC8vICAtIHIsZyxiIDw9ICh2MS8yNTYpXG4gICAgICAvLyAgLSByLGcsYiwodjEvMjU2KSwodjIvMjU2KSA8PSAyNTVcbiAgICAgIC8vIFNvIGhpZ2hlc3QgdGhpcyBudW1iZXIgY2FuIGdldCBpcyBYKjI1NS9YKzAuNT0yNTUuNSB3aGljaCBpcyA8IDI1NiBhbmQgcm91bmRzIGRvd24uXG5cbiAgICAgIGlUaW1lczQgPSBpICogNDtcbiAgICAgIGltZ1tpVGltZXM0XSA9IGltZ1tpVGltZXM0XSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gUlxuXG4gICAgICBpbWdbaVRpbWVzNCArIDFdID0gaW1nW2lUaW1lczQgKyAxXSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gR1xuXG4gICAgICBpbWdbaVRpbWVzNCArIDJdID0gaW1nW2lUaW1lczQgKyAyXSAqIHZtdWwgKyAweDgwMCA+PiAxMjsgLy8gQlxuICAgIH1cbiAgfVxufTtcblxufSx7XCJnbHVyL21vbm8xNlwiOjE4fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuc2hhcnAoaW1nLCB3aWR0aCwgaGVpZ2h0LCBhbW91bnQsIHJhZGl1cywgdGhyZXNob2xkKSB7XG4gIGlmIChhbW91bnQgPT09IDAgfHwgcmFkaXVzIDwgMC41KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJhZGl1cyA+IDIuMCkge1xuICAgIHJhZGl1cyA9IDIuMDtcbiAgfVxuXG4gIHZhciBwaXhlbHMgPSB3aWR0aCAqIGhlaWdodDtcbiAgdmFyIGltZ19ieXRlc19jbnQgPSBwaXhlbHMgKiA0O1xuICB2YXIgaHN2X2J5dGVzX2NudCA9IHBpeGVscyAqIDI7XG4gIHZhciBibHVyX2J5dGVzX2NudCA9IHBpeGVscyAqIDI7XG4gIHZhciBibHVyX2xpbmVfYnl0ZV9jbnQgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAqIDQ7IC8vIGZsb2F0MzIgYXJyYXlcblxuICB2YXIgYmx1cl9jb2VmZnNfYnl0ZV9jbnQgPSA4ICogNDsgLy8gZmxvYXQzMiBhcnJheVxuXG4gIHZhciBpbWdfb2Zmc2V0ID0gMDtcbiAgdmFyIGhzdl9vZmZzZXQgPSBpbWdfYnl0ZXNfY250O1xuICB2YXIgYmx1cl9vZmZzZXQgPSBoc3Zfb2Zmc2V0ICsgaHN2X2J5dGVzX2NudDtcbiAgdmFyIGJsdXJfdG1wX29mZnNldCA9IGJsdXJfb2Zmc2V0ICsgYmx1cl9ieXRlc19jbnQ7XG4gIHZhciBibHVyX2xpbmVfb2Zmc2V0ID0gYmx1cl90bXBfb2Zmc2V0ICsgYmx1cl9ieXRlc19jbnQ7XG4gIHZhciBibHVyX2NvZWZmc19vZmZzZXQgPSBibHVyX2xpbmVfb2Zmc2V0ICsgYmx1cl9saW5lX2J5dGVfY250O1xuXG4gIHZhciBpbnN0YW5jZSA9IHRoaXMuX19pbnN0YW5jZSgndW5zaGFycF9tYXNrJywgaW1nX2J5dGVzX2NudCArIGhzdl9ieXRlc19jbnQgKyBibHVyX2J5dGVzX2NudCAqIDIgKyBibHVyX2xpbmVfYnl0ZV9jbnQgKyBibHVyX2NvZWZmc19ieXRlX2NudCwge1xuICAgIGV4cDogTWF0aC5leHBcbiAgfSk7IC8vIDMyLWJpdCBjb3B5IGlzIG11Y2ggZmFzdGVyIGluIGNocm9tZVxuXG5cbiAgdmFyIGltZzMyID0gbmV3IFVpbnQzMkFycmF5KGltZy5idWZmZXIpO1xuICB2YXIgbWVtMzIgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX21lbW9yeS5idWZmZXIpO1xuICBtZW0zMi5zZXQoaW1nMzIpOyAvLyBIU0xcblxuICB2YXIgZm4gPSBpbnN0YW5jZS5leHBvcnRzLmhzdl92MTYgfHwgaW5zdGFuY2UuZXhwb3J0cy5faHN2X3YxNjtcbiAgZm4oaW1nX29mZnNldCwgaHN2X29mZnNldCwgd2lkdGgsIGhlaWdodCk7IC8vIEJMVVJcblxuICBmbiA9IGluc3RhbmNlLmV4cG9ydHMuYmx1ck1vbm8xNiB8fCBpbnN0YW5jZS5leHBvcnRzLl9ibHVyTW9ubzE2O1xuICBmbihoc3Zfb2Zmc2V0LCBibHVyX29mZnNldCwgYmx1cl90bXBfb2Zmc2V0LCBibHVyX2xpbmVfb2Zmc2V0LCBibHVyX2NvZWZmc19vZmZzZXQsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7IC8vIFVOU0hBUlBcblxuICBmbiA9IGluc3RhbmNlLmV4cG9ydHMudW5zaGFycCB8fCBpbnN0YW5jZS5leHBvcnRzLl91bnNoYXJwO1xuICBmbihpbWdfb2Zmc2V0LCBpbWdfb2Zmc2V0LCBoc3Zfb2Zmc2V0LCBibHVyX29mZnNldCwgd2lkdGgsIGhlaWdodCwgYW1vdW50LCB0aHJlc2hvbGQpOyAvLyAzMi1iaXQgY29weSBpcyBtdWNoIGZhc3RlciBpbiBjaHJvbWVcblxuICBpbWczMi5zZXQobmV3IFVpbnQzMkFycmF5KHRoaXMuX19tZW1vcnkuYnVmZmVyLCAwLCBwaXhlbHMpKTtcbn07XG5cbn0se31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlIGZyb20gbWF0aC53YXNtLCBkb24ndCBlZGl0LlxuLy9cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAnQUdGemJRRUFBQUFBREFaa2VXeHBibXNBQUFBQUFBRTBCMkFBQUdBRWYzOS9md0JnQm45L2YzOS9md0JnQ0g5L2YzOS9mMzkvQUdBSWYzOS9mMzkvZjMwQVlBSjlmd0JnQVh3QmZBSVpBZ05sYm5ZRFpYaHdBQVlEWlc1MkJtMWxiVzl5ZVFJQUFBTUhCZ0FGQWdRQkF3WUdBWDhBUVFBTEI0b0JDQkZmWDNkaGMyMWZZMkZzYkY5amRHOXljd0FCRmw5ZlluVnBiR1JmWjJGMWMzTnBZVzVmWTI5bFpuTUFBZzVmWDJkaGRYTnpNVFpmYkdsdVpRQURDbUpzZFhKTmIyNXZNVFlBQkFkb2MzWmZkakUyQUFVSGRXNXphR0Z5Y0FBR0RGOWZaSE52WDJoaGJtUnNaUU1BR0Y5ZmQyRnpiVjloY0hCc2VWOWtZWFJoWDNKbGJHOWpjd0FCQ3NVTUJnTUFBUXZXQVFFSGZDQUJSTnVHdWtPQ0d2cy9JQUM3b3lJQ1JBQUFBQUFBQUFEQW9oQUFJZ1cyakRnQ0ZDQUJJQUthRUFBaUF5QURvQ0lHdGpnQ0VDQUJSQUFBQUFBQUFQQS9JQU9oSWdRZ0JLSWdBeUFDSUFLZ29rUUFBQUFBQUFEd1A2QWdCYUdqSWdTMk9BSUFJQUVnQlNBRW1xSWlCN1k0QWd3Z0FTQURJQUpFQUFBQUFBQUE4RCtnSUFTaW9pSUl0amdDQ0NBQklBTWdBa1FBQUFBQUFBRHd2NkFnQktLaUlnSzJPQUlFSUFFZ0J5QUlvQ0FGUkFBQUFBQUFBUEEvSUFhaG9DSURvN1k0QWh3Z0FTQUVJQUtnSUFPanRqZ0NHQXVHQlFNR2Z3bDhBbjBnQXlvQ0RDRVZJQU1xQWdnaEZpQURLZ0lVdXlFUklBTXFBaEM3SVJBQ1FDQUVRUUZySWdoQkFFZ2lDUVJBSUFJaEJ5QUFJUVlNQVFzZ0FpQUFMd0VBdUNJUElBTXFBaGk3b2lJTUlCR2lJZzBnRENBUW9pQVBJQU1xQWdTN0loT2lJaFFnQXlvQ0FMc2lFaUFQb3FDZ29DSU90amdDQUNBQ1FRUnFJUWNnQUVFQ2FpRUdJQWhGRFFBZ0NFRUJJQWhCQVVnYklncEJmM01oQ3dKL0lBUWdDbXRCQVhGRkJFQWdEaUVOSUFnTUFRc2dBaUFOSUE0Z0VLSWdGQ0FTSUFBdkFRSzRJZytpb0tDZ0lnMjJPQUlFSUFKQkNHb2hCeUFBUVFScUlRWWdEaUVNSUFSQkFtc0xJUUlnQzBFQUlBUnJSZzBBQTBBZ0J5QU1JQkdpSUEwZ0VLSWdEeUFUb2lBU0lBWXZBUUM0SWc2aW9LQ2dJZ3kyT0FJQUlBY2dEU0FSb2lBTUlCQ2lJQTRnRTZJZ0VpQUdMd0VDdUNJUG9xQ2dvQ0lOdGpnQ0JDQUhRUWhxSVFjZ0JrRUVhaUVHSUFKQkFrb2hBQ0FDUVFKcklRSWdBQTBBQ3dzQ1FDQUpEUUFnQVNBRklBaHNRUUYwYWlJQUFuOGdCa0VDYXk4QkFDSUN1Q0lOSUJXN0loS2lJQTBnRnJzaUU2S2dJQTBnQXlvQ0hMdWlJZ3dnRUtLZ0lBd2dFYUtnSWc4Z0IwRUVheUlIS2dJQXU2QWlEa1FBQUFBQUFBRHdRV01nRGtRQUFBQUFBQUFBQUdaeEJFQWdEcXNNQVF0QkFBczdBUUFnQ0VVTkFDQUdRUVJySVFaQkFDQUZhMEVCZENFQkEwQUNmeUFOSUJLaUlBSkIvLzhEY2JnaURTQVRvcUFnRHlJT0lCQ2lvQ0FNSUJHaW9DSVBJQWRCQkdzaUJ5b0NBTHVnSWd4RUFBQUFBQUFBOEVGaklBeEVBQUFBQUFBQUFBQm1jUVJBSUF5ckRBRUxRUUFMSVFNZ0JpOEJBQ0VDSUFBZ0FXb2lBQ0FET3dFQUlBWkJBbXNoQmlBSVFRRktJUU1nRGlFTUlBaEJBV3NoQ0NBRERRQUxDd3ZSQWdJQmZ3ZDhBa0FnQjBNQUFBQUFXdzBBSUFSRTI0YTZRNElhK3o4Z0IwTUFBQUEvbDd1aklnbEVBQUFBQUFBQUFNQ2lFQUFpRExhTU9BSVVJQVFnQ1pvUUFDSUtJQXFnSWcyMk9BSVFJQVJFQUFBQUFBQUE4RDhnQ3FFaUN5QUxvaUFLSUFrZ0NhQ2lSQUFBQUFBQUFQQS9vQ0FNb2FNaUM3WTRBZ0FnQkNBTUlBdWFvaUlPdGpnQ0RDQUVJQW9nQ1VRQUFBQUFBQUR3UDZBZ0M2S2lJZysyT0FJSUlBUWdDaUFKUkFBQUFBQUFBUEMvb0NBTG9xSWlDYlk0QWdRZ0JDQU9JQStnSUF4RUFBQUFBQUFBOEQ4Z0RhR2dJZ3FqdGpnQ0hDQUVJQXNnQ2FBZ0NxTzJPQUlZSUFZRVFBTkFJQUFnQlNBSWJFRUJkR29nQWlBSVFRRjBhaUFESUFRZ0JTQUdFQU1nQ0VFQmFpSUlJQVpIRFFBTEN5QUZSUTBBUVFBaENBTkFJQUlnQmlBSWJFRUJkR29nQVNBSVFRRjBhaUFESUFRZ0JpQUZFQU1nQ0VFQmFpSUlJQVZIRFFBTEN3dHhBUU4vSUFJZ0Eyd2lCUVJBQTBBZ0FTQUFLQUlBSWdSQkVIWkIvd0Z4SWdJZ0FpQUVRUWgyUWY4QmNTSURJQU1nQkVIL0FYRWlCRWtiSUFJZ0Ewc2JJZ1lnQmlBRUlBSWdCRXNiSUFNZ0JFc2JRUWgwT3dFQUlBRkJBbW9oQVNBQVFRUnFJUUFnQlVFQmF5SUZEUUFMQ3d1WkFnSURmd0Y4SUFRZ0JXd2hCQUovSUFhelF3QUFnRVdVUXdBQXlFS1Z1MFFBQUFBQUFBRGdQNkFpQzVsRUFBQUFBQUFBNEVGakJFQWdDNm9NQVF0QmdJQ0FnSGdMSVFVZ0JBUkFJQWRCQ0hRaENVRUFJUVlEUUNBSklBSWdCa0VCZENJSGFpOEJBQ0lCSUFNZ0Iyb3ZBUUJySWdjZ0IwRWZkU0lJYWlBSWMwMEVRQ0FBSUFaQkFuUWlDR29pQ2lBRklBZHNRWUFRYWtFTWRTQUJhaUlIUVlEK0F5QUhRWUQrQTBnYklnZEJBQ0FIUVFCS0cwRU1kQ0FCUVFFZ0FSdHVJZ0VnQ2kwQUFHeEJnQkJxUVF4Mk9nQUFJQUFnQ0VFQmNtb2lCeUFCSUFjdEFBQnNRWUFRYWtFTWRqb0FBQ0FBSUFoQkFuSnFJZ2NnQVNBSExRQUFiRUdBRUdwQkRIWTZBQUFMSUFaQkFXb2lCaUFFUncwQUN3c0wnO1xuXG59LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBHQ19JTlRFUlZBTCA9IDEwMDtcblxuZnVuY3Rpb24gUG9vbChjcmVhdGUsIGlkbGUpIHtcbiAgdGhpcy5jcmVhdGUgPSBjcmVhdGU7XG4gIHRoaXMuYXZhaWxhYmxlID0gW107XG4gIHRoaXMuYWNxdWlyZWQgPSB7fTtcbiAgdGhpcy5sYXN0SWQgPSAxO1xuICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gIHRoaXMuaWRsZSA9IGlkbGUgfHwgMjAwMDtcbn1cblxuUG9vbC5wcm90b3R5cGUuYWNxdWlyZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVzb3VyY2U7XG5cbiAgaWYgKHRoaXMuYXZhaWxhYmxlLmxlbmd0aCAhPT0gMCkge1xuICAgIHJlc291cmNlID0gdGhpcy5hdmFpbGFibGUucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2UgPSB0aGlzLmNyZWF0ZSgpO1xuICAgIHJlc291cmNlLmlkID0gdGhpcy5sYXN0SWQrKztcblxuICAgIHJlc291cmNlLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVsZWFzZShyZXNvdXJjZSk7XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuYWNxdWlyZWRbcmVzb3VyY2UuaWRdID0gcmVzb3VyY2U7XG4gIHJldHVybiByZXNvdXJjZTtcbn07XG5cblBvb2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAocmVzb3VyY2UpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgZGVsZXRlIHRoaXMuYWNxdWlyZWRbcmVzb3VyY2UuaWRdO1xuICByZXNvdXJjZS5sYXN0VXNlZCA9IERhdGUubm93KCk7XG4gIHRoaXMuYXZhaWxhYmxlLnB1c2gocmVzb3VyY2UpO1xuXG4gIGlmICh0aGlzLnRpbWVvdXRJZCA9PT0gMCkge1xuICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMyLmdjKCk7XG4gICAgfSwgR0NfSU5URVJWQUwpO1xuICB9XG59O1xuXG5Qb29sLnByb3RvdHlwZS5nYyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gIHRoaXMuYXZhaWxhYmxlID0gdGhpcy5hdmFpbGFibGUuZmlsdGVyKGZ1bmN0aW9uIChyZXNvdXJjZSkge1xuICAgIGlmIChub3cgLSByZXNvdXJjZS5sYXN0VXNlZCA+IF90aGlzMy5pZGxlKSB7XG4gICAgICByZXNvdXJjZS5kZXN0cm95KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIGlmICh0aGlzLmF2YWlsYWJsZS5sZW5ndGggIT09IDApIHtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzMy5nYygpO1xuICAgIH0sIEdDX0lOVEVSVkFMKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQWRkIGludGVybWVkaWF0ZSByZXNpemluZyBzdGVwcyB3aGVuIHNjYWxpbmcgZG93biBieSBhIHZlcnkgbGFyZ2UgZmFjdG9yLlxuLy9cbi8vIEZvciBleGFtcGxlLCB3aGVuIHJlc2l6aW5nIDEwMDAweDEwMDAwIGRvd24gdG8gMTB4MTAsIGl0J2xsIHJlc2l6ZSBpdCB0b1xuLy8gMzAweDMwMCBmaXJzdC5cbi8vXG4vLyBJdCdzIG5lZWRlZCBiZWNhdXNlIHRpbGVyIGhhcyBpc3N1ZXMgd2hlbiB0aGUgZW50aXJlIHRpbGUgaXMgc2NhbGVkIGRvd25cbi8vIHRvIGEgZmV3IHBpeGVscyAoMTAyNHB4IHNvdXJjZSB0aWxlIHdpdGggYm9yZGVyIHNpemUgMyBzaG91bGQgcmVzdWx0IGluXG4vLyBhdCBsZWFzdCAzKzMrMiA9IDhweCB0YXJnZXQgdGlsZSwgc28gbWF4IHNjYWxlIGZhY3RvciBpcyAxMjggaGVyZSkuXG4vL1xuLy8gQWxzbywgYWRkaW5nIGludGVybWVkaWF0ZSBzdGVwcyBjYW4gc3BlZWQgdXAgcHJvY2Vzc2luZyBpZiB3ZSB1c2UgbG93ZXJcbi8vIHF1YWxpdHkgYWxnb3JpdGhtcyBmb3IgZmlyc3Qgc3RhZ2VzLlxuLy9cbid1c2Ugc3RyaWN0JzsgLy8gbWluIHNpemUgPSAwIHJlc3VsdHMgaW4gaW5maW5pdGUgbG9vcCxcbi8vIG1pbiBzaXplID0gMSBjYW4gY29uc3VtZSBsYXJnZSBhbW91bnQgb2YgbWVtb3J5XG5cbnZhciBNSU5fSU5ORVJfVElMRV9TSVpFID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTdGFnZXMoZnJvbVdpZHRoLCBmcm9tSGVpZ2h0LCB0b1dpZHRoLCB0b0hlaWdodCwgc3JjVGlsZVNpemUsIGRlc3RUaWxlQm9yZGVyKSB7XG4gIHZhciBzY2FsZVggPSB0b1dpZHRoIC8gZnJvbVdpZHRoO1xuICB2YXIgc2NhbGVZID0gdG9IZWlnaHQgLyBmcm9tSGVpZ2h0OyAvLyBkZXJpdmVkIGZyb20gY3JlYXRlUmVnaW9ucyBlcXVhdGlvbjpcbiAgLy8gaW5uZXJUaWxlV2lkdGggPSBwaXhlbEZsb29yKHNyY1RpbGVTaXplICogc2NhbGVYKSAtIDIgKiBkZXN0VGlsZUJvcmRlcjtcblxuICB2YXIgbWluU2NhbGUgPSAoMiAqIGRlc3RUaWxlQm9yZGVyICsgTUlOX0lOTkVSX1RJTEVfU0laRSArIDEpIC8gc3JjVGlsZVNpemU7IC8vIHJlZnVzZSB0byBzY2FsZSBpbWFnZSBtdWx0aXBsZSB0aW1lcyBieSBsZXNzIHRoYW4gdHdpY2UgZWFjaCB0aW1lLFxuICAvLyBpdCBjb3VsZCBvbmx5IGhhcHBlbiBiZWNhdXNlIG9mIGludmFsaWQgb3B0aW9uc1xuXG4gIGlmIChtaW5TY2FsZSA+IDAuNSkgcmV0dXJuIFtbdG9XaWR0aCwgdG9IZWlnaHRdXTtcbiAgdmFyIHN0YWdlQ291bnQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpKSAvIE1hdGgubG9nKG1pblNjYWxlKSk7IC8vIG5vIGFkZGl0aW9uYWwgcmVzaXplcyBhcmUgbmVjZXNzYXJ5LFxuICAvLyBzdGFnZUNvdW50IGNhbiBiZSB6ZXJvIG9yIGJlIG5lZ2F0aXZlIHdoZW4gZW5sYXJnaW5nIHRoZSBpbWFnZVxuXG4gIGlmIChzdGFnZUNvdW50IDw9IDEpIHJldHVybiBbW3RvV2lkdGgsIHRvSGVpZ2h0XV07XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWdlQ291bnQ7IGkrKykge1xuICAgIHZhciB3aWR0aCA9IE1hdGgucm91bmQoTWF0aC5wb3coTWF0aC5wb3coZnJvbVdpZHRoLCBzdGFnZUNvdW50IC0gaSAtIDEpICogTWF0aC5wb3codG9XaWR0aCwgaSArIDEpLCAxIC8gc3RhZ2VDb3VudCkpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgucG93KE1hdGgucG93KGZyb21IZWlnaHQsIHN0YWdlQ291bnQgLSBpIC0gMSkgKiBNYXRoLnBvdyh0b0hlaWdodCwgaSArIDEpLCAxIC8gc3RhZ2VDb3VudCkpO1xuICAgIHJlc3VsdC5wdXNoKFt3aWR0aCwgaGVpZ2h0XSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gU3BsaXQgb3JpZ2luYWwgaW1hZ2UgaW50byBtdWx0aXBsZSAxMDI0eDEwMjQgY2h1bmtzIHRvIHJlZHVjZSBtZW1vcnkgdXNhZ2Vcbi8vIChpbWFnZXMgaGF2ZSB0byBiZSB1bnBhY2tlZCBpbnRvIHR5cGVkIGFycmF5cyBmb3IgcmVzaXppbmcpIGFuZCBhbGxvd1xuLy8gcGFyYWxsZWwgcHJvY2Vzc2luZyBvZiBtdWx0aXBsZSB0aWxlcyBhdCBhIHRpbWUuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuLypcbiAqIHBpeGVsRmxvb3IgYW5kIHBpeGVsQ2VpbCBhcmUgbW9kaWZpZWQgdmVyc2lvbnMgb2YgTWF0aC5mbG9vciBhbmQgTWF0aC5jZWlsXG4gKiBmdW5jdGlvbnMgd2hpY2ggdGFrZSBpbnRvIGFjY291bnQgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBlcnJvcnMuXG4gKiBUaG9zZSBlcnJvcnMgY2FuIGNhdXNlIHVuZGVzaXJlZCBpbmNyZW1lbnRzL2RlY3JlbWVudHMgb2Ygc2l6ZXMgYW5kIG9mZnNldHM6XG4gKiBNYXRoLmNlaWwoMzYgLyAoMzYgLyA1MDApKSA9IDUwMVxuICogcGl4ZWxDZWlsKDM2IC8gKDM2IC8gNTAwKSkgPSA1MDBcbiAqL1xuXG52YXIgUElYRUxfRVBTSUxPTiA9IDFlLTU7XG5cbmZ1bmN0aW9uIHBpeGVsRmxvb3IoeCkge1xuICB2YXIgbmVhcmVzdCA9IE1hdGgucm91bmQoeCk7XG5cbiAgaWYgKE1hdGguYWJzKHggLSBuZWFyZXN0KSA8IFBJWEVMX0VQU0lMT04pIHtcbiAgICByZXR1cm4gbmVhcmVzdDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmZsb29yKHgpO1xufVxuXG5mdW5jdGlvbiBwaXhlbENlaWwoeCkge1xuICB2YXIgbmVhcmVzdCA9IE1hdGgucm91bmQoeCk7XG5cbiAgaWYgKE1hdGguYWJzKHggLSBuZWFyZXN0KSA8IFBJWEVMX0VQU0lMT04pIHtcbiAgICByZXR1cm4gbmVhcmVzdDtcbiAgfVxuXG4gIHJldHVybiBNYXRoLmNlaWwoeCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlUmVnaW9ucyhvcHRpb25zKSB7XG4gIHZhciBzY2FsZVggPSBvcHRpb25zLnRvV2lkdGggLyBvcHRpb25zLndpZHRoO1xuICB2YXIgc2NhbGVZID0gb3B0aW9ucy50b0hlaWdodCAvIG9wdGlvbnMuaGVpZ2h0O1xuICB2YXIgaW5uZXJUaWxlV2lkdGggPSBwaXhlbEZsb29yKG9wdGlvbnMuc3JjVGlsZVNpemUgKiBzY2FsZVgpIC0gMiAqIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXI7XG4gIHZhciBpbm5lclRpbGVIZWlnaHQgPSBwaXhlbEZsb29yKG9wdGlvbnMuc3JjVGlsZVNpemUgKiBzY2FsZVkpIC0gMiAqIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXI7IC8vIHByZXZlbnQgaW5maW5pdGUgbG9vcCwgdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG5cbiAgaWYgKGlubmVyVGlsZVdpZHRoIDwgMSB8fCBpbm5lclRpbGVIZWlnaHQgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciBpbiBwaWNhOiB0YXJnZXQgdGlsZSB3aWR0aC9oZWlnaHQgaXMgdG9vIHNtYWxsLicpO1xuICB9XG5cbiAgdmFyIHgsIHk7XG4gIHZhciBpbm5lclgsIGlubmVyWSwgdG9UaWxlV2lkdGgsIHRvVGlsZUhlaWdodDtcbiAgdmFyIHRpbGVzID0gW107XG4gIHZhciB0aWxlOyAvLyB3ZSBnbyB0b3AtdG8tZG93biBpbnN0ZWFkIG9mIGxlZnQtdG8tcmlnaHQgdG8gbWFrZSBpbWFnZSBkaXNwbGF5ZWQgZnJvbSB0b3AgdG9cbiAgLy8gZG9lc24gaW4gdGhlIGJyb3dzZXJcblxuICBmb3IgKGlubmVyWSA9IDA7IGlubmVyWSA8IG9wdGlvbnMudG9IZWlnaHQ7IGlubmVyWSArPSBpbm5lclRpbGVIZWlnaHQpIHtcbiAgICBmb3IgKGlubmVyWCA9IDA7IGlubmVyWCA8IG9wdGlvbnMudG9XaWR0aDsgaW5uZXJYICs9IGlubmVyVGlsZVdpZHRoKSB7XG4gICAgICB4ID0gaW5uZXJYIC0gb3B0aW9ucy5kZXN0VGlsZUJvcmRlcjtcblxuICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgfVxuXG4gICAgICB0b1RpbGVXaWR0aCA9IGlubmVyWCArIGlubmVyVGlsZVdpZHRoICsgb3B0aW9ucy5kZXN0VGlsZUJvcmRlciAtIHg7XG5cbiAgICAgIGlmICh4ICsgdG9UaWxlV2lkdGggPj0gb3B0aW9ucy50b1dpZHRoKSB7XG4gICAgICAgIHRvVGlsZVdpZHRoID0gb3B0aW9ucy50b1dpZHRoIC0geDtcbiAgICAgIH1cblxuICAgICAgeSA9IGlubmVyWSAtIG9wdGlvbnMuZGVzdFRpbGVCb3JkZXI7XG5cbiAgICAgIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH1cblxuICAgICAgdG9UaWxlSGVpZ2h0ID0gaW5uZXJZICsgaW5uZXJUaWxlSGVpZ2h0ICsgb3B0aW9ucy5kZXN0VGlsZUJvcmRlciAtIHk7XG5cbiAgICAgIGlmICh5ICsgdG9UaWxlSGVpZ2h0ID49IG9wdGlvbnMudG9IZWlnaHQpIHtcbiAgICAgICAgdG9UaWxlSGVpZ2h0ID0gb3B0aW9ucy50b0hlaWdodCAtIHk7XG4gICAgICB9XG5cbiAgICAgIHRpbGUgPSB7XG4gICAgICAgIHRvWDogeCxcbiAgICAgICAgdG9ZOiB5LFxuICAgICAgICB0b1dpZHRoOiB0b1RpbGVXaWR0aCxcbiAgICAgICAgdG9IZWlnaHQ6IHRvVGlsZUhlaWdodCxcbiAgICAgICAgdG9Jbm5lclg6IGlubmVyWCxcbiAgICAgICAgdG9Jbm5lclk6IGlubmVyWSxcbiAgICAgICAgdG9Jbm5lcldpZHRoOiBpbm5lclRpbGVXaWR0aCxcbiAgICAgICAgdG9Jbm5lckhlaWdodDogaW5uZXJUaWxlSGVpZ2h0LFxuICAgICAgICBvZmZzZXRYOiB4IC8gc2NhbGVYIC0gcGl4ZWxGbG9vcih4IC8gc2NhbGVYKSxcbiAgICAgICAgb2Zmc2V0WTogeSAvIHNjYWxlWSAtIHBpeGVsRmxvb3IoeSAvIHNjYWxlWSksXG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgeDogcGl4ZWxGbG9vcih4IC8gc2NhbGVYKSxcbiAgICAgICAgeTogcGl4ZWxGbG9vcih5IC8gc2NhbGVZKSxcbiAgICAgICAgd2lkdGg6IHBpeGVsQ2VpbCh0b1RpbGVXaWR0aCAvIHNjYWxlWCksXG4gICAgICAgIGhlaWdodDogcGl4ZWxDZWlsKHRvVGlsZUhlaWdodCAvIHNjYWxlWSlcbiAgICAgIH07XG4gICAgICB0aWxlcy5wdXNoKHRpbGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aWxlcztcbn07XG5cbn0se31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqQ2xhc3Mob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuaXNDYW52YXMgPSBmdW5jdGlvbiBpc0NhbnZhcyhlbGVtZW50KSB7XG4gIHZhciBjbmFtZSA9IG9iakNsYXNzKGVsZW1lbnQpO1xuICByZXR1cm4gY25hbWUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XSdcbiAgLyogYnJvd3NlciAqL1xuICB8fCBjbmFtZSA9PT0gJ1tvYmplY3QgT2Zmc2NyZWVuQ2FudmFzXScgfHwgY25hbWUgPT09ICdbb2JqZWN0IENhbnZhc10nXG4gIC8qIG5vZGUtY2FudmFzICovXG4gIDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmlzSW1hZ2UgPSBmdW5jdGlvbiBpc0ltYWdlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG9iakNsYXNzKGVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pc0ltYWdlQml0bWFwID0gZnVuY3Rpb24gaXNJbWFnZUJpdG1hcChlbGVtZW50KSB7XG4gIHJldHVybiBvYmpDbGFzcyhlbGVtZW50KSA9PT0gJ1tvYmplY3QgSW1hZ2VCaXRtYXBdJztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmxpbWl0ZXIgPSBmdW5jdGlvbiBsaW1pdGVyKGNvbmN1cnJlbmN5KSB7XG4gIHZhciBhY3RpdmUgPSAwLFxuICAgICAgcXVldWUgPSBbXTtcblxuICBmdW5jdGlvbiByb2xsKCkge1xuICAgIGlmIChhY3RpdmUgPCBjb25jdXJyZW5jeSAmJiBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGFjdGl2ZSsrO1xuICAgICAgcXVldWUuc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBsaW1pdChmbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBxdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4oKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgYWN0aXZlLS07XG4gICAgICAgICAgcm9sbCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgYWN0aXZlLS07XG4gICAgICAgICAgcm9sbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcm9sbCgpO1xuICAgIH0pO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMuY2liX3F1YWxpdHlfbmFtZSA9IGZ1bmN0aW9uIGNpYl9xdWFsaXR5X25hbWUobnVtKSB7XG4gIHN3aXRjaCAobnVtKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuICdwaXhlbGF0ZWQnO1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuICdsb3cnO1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuICdtZWRpdW0nO1xuICB9XG5cbiAgcmV0dXJuICdoaWdoJztcbn07XG5cbm1vZHVsZS5leHBvcnRzLmNpYl9zdXBwb3J0ID0gZnVuY3Rpb24gY2liX3N1cHBvcnQoY3JlYXRlQ2FudmFzKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjID0gY3JlYXRlQ2FudmFzKDEwMCwgMTAwKTtcbiAgICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoYywgMCwgMCwgMTAwLCAxMDAsIHtcbiAgICAgIHJlc2l6ZVdpZHRoOiAxMCxcbiAgICAgIHJlc2l6ZUhlaWdodDogMTAsXG4gICAgICByZXNpemVRdWFsaXR5OiAnaGlnaCdcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgIHZhciBzdGF0dXMgPSBiaXRtYXAud2lkdGggPT09IDEwOyAvLyBCcmFuY2ggYmVsb3cgaXMgZmlsdGVyZWQgb24gdXBwZXIgbGV2ZWwuIFdlIGRvIG5vdCBjYWxsIHJlc2l6ZVxuICAgICAgLy8gZGV0ZWN0aW9uIGZvciBiYXNpYyBJbWFnZUJpdG1hcC5cbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW1hZ2VCaXRtYXBcbiAgICAgIC8vIG9sZCBDcm9tZSA1MSBoYXMgSW1hZ2VCaXRtYXAgd2l0aG91dCAuY2xvc2UoKS4gVGhlbiB0aGlzIGNvZGVcbiAgICAgIC8vIHdpbGwgdGhyb3cgYW5kIHJldHVybiAnZmFsc2UnIGFzIGV4cGVjdGVkLlxuICAgICAgLy9cblxuICAgICAgYml0bWFwLmNsb3NlKCk7XG4gICAgICBjID0gbnVsbDtcbiAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy53b3JrZXJfb2Zmc2NyZWVuX2NhbnZhc19zdXBwb3J0ID0gZnVuY3Rpb24gd29ya2VyX29mZnNjcmVlbl9jYW52YXNfc3VwcG9ydCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGlmIE9mZnNjcmVlbkNhbnZhcyBpcyBwcmVzZW50LCB3ZSBhc3N1bWUgYnJvd3NlciBzdXBwb3J0cyBXb3JrZXIgYW5kIGJ1aWx0LWluIFByb21pc2UgYXMgd2VsbFxuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd29ya2VyUGF5bG9hZChzZWxmKSB7XG4gICAgICBpZiAodHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLnBvc3RNZXNzYWdlKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMTAsIDEwKTsgLy8gdGVzdCB0aGF0IDJkIGNvbnRleHQgY2FuIGJlIHVzZWQgaW4gd29ya2VyXG5cbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHgucmVjdCgwLCAwLCAxLCAxKTsgLy8gdGVzdCB0aGF0IGNpYiBjYW4gYmUgdXNlZCB0byByZXR1cm4gaW1hZ2UgYml0bWFwIGZyb20gd29ya2VyXG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKGNhbnZhcywgMCwgMCwgMSwgMSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYucG9zdE1lc3NhZ2UodHJ1ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnBvc3RNZXNzYWdlKGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gYnRvYShcIihcIi5jb25jYXQod29ya2VyUGF5bG9hZC50b1N0cmluZygpLCBcIikoc2VsZik7XCIpKTtcbiAgICB2YXIgdyA9IG5ldyBXb3JrZXIoXCJkYXRhOnRleHQvamF2YXNjcmlwdDtiYXNlNjQsXCIuY29uY2F0KGNvZGUpKTtcblxuICAgIHcub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZShldi5kYXRhKTtcbiAgICB9O1xuXG4gICAgdy5vbmVycm9yID0gcmVqZWN0O1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn07IC8vIENoZWNrIGlmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSBjYW4gYmUgdXNlZCxcbi8vIEZpcmVGb3ggcmFuZG9taXplcyB0aGUgb3V0cHV0IG9mIHRoYXQgZnVuY3Rpb24gaW4gYHByaXZhY3kucmVzaXN0RmluZ2VycHJpbnRpbmdgIG1vZGVcblxuXG5tb2R1bGUuZXhwb3J0cy5jYW5fdXNlX2NhbnZhcyA9IGZ1bmN0aW9uIGNhbl91c2VfY2FudmFzKGNyZWF0ZUNhbnZhcykge1xuICB2YXIgdXNhYmxlID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgY2FudmFzID0gY3JlYXRlQ2FudmFzKDIsIDEpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgZCA9IGN0eC5jcmVhdGVJbWFnZURhdGEoMiwgMSk7XG4gICAgZC5kYXRhWzBdID0gMTI7XG4gICAgZC5kYXRhWzFdID0gMjM7XG4gICAgZC5kYXRhWzJdID0gMzQ7XG4gICAgZC5kYXRhWzNdID0gMjU1O1xuICAgIGQuZGF0YVs0XSA9IDQ1O1xuICAgIGQuZGF0YVs1XSA9IDU2O1xuICAgIGQuZGF0YVs2XSA9IDY3O1xuICAgIGQuZGF0YVs3XSA9IDI1NTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGQsIDAsIDApO1xuICAgIGQgPSBudWxsO1xuICAgIGQgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDIsIDEpO1xuXG4gICAgaWYgKGQuZGF0YVswXSA9PT0gMTIgJiYgZC5kYXRhWzFdID09PSAyMyAmJiBkLmRhdGFbMl0gPT09IDM0ICYmIGQuZGF0YVszXSA9PT0gMjU1ICYmIGQuZGF0YVs0XSA9PT0gNDUgJiYgZC5kYXRhWzVdID09PSA1NiAmJiBkLmRhdGFbNl0gPT09IDY3ICYmIGQuZGF0YVs3XSA9PT0gMjU1KSB7XG4gICAgICB1c2FibGUgPSB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIHJldHVybiB1c2FibGU7XG59OyAvLyBDaGVjayBpZiBjcmVhdGVJbWFnZUJpdG1hcChpbWcsIHN4LCBzeSwgc3csIHNoKSBzaWduYXR1cmUgd29ya3MgY29ycmVjdGx5XG4vLyB3aXRoIEpQRUcgaW1hZ2VzIG9yaWVudGVkIHdpdGggRXhpZjtcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMjA2NzFcbi8vIFRPRE86IHJlbW92ZSBhZnRlciBpdCdzIGZpeGVkIGluIGNocm9tZSBmb3IgYXQgbGVhc3QgMiByZWxlYXNlc1xuXG5cbm1vZHVsZS5leHBvcnRzLmNpYl9jYW5fdXNlX3JlZ2lvbiA9IGZ1bmN0aW9uIGNpYl9jYW5fdXNlX3JlZ2lvbigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgLy8gYEltYWdlYCBjaGVjayByZXF1aXJlZCBmb3IgdXNlIGluIGBTZXJ2aWNlV29ya2VyYFxuICAgIGlmICh0eXBlb2YgSW1hZ2UgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCcgKyAnLzlqLzRRQmlSWGhwWmdBQVRVMEFLZ0FBQUFnQUJRRVNBQU1BQUFBQkFBWUFBQUVhQUFVQUFBQUJBQUFBU2dFYkFBVUFBJyArICdBQUJBQUFBVWdFb0FBTUFBQUFCQUFJQUFBSVRBQU1BQUFBQkFBRUFBQUFBQUFBQUFBQklBQUFBQVFBQUFFZ0FBQUFCLzknICsgJ3NBUXdBRUF3TUVBd01FQkFNRUJRUUVCUVlLQndZR0JnWU5DUW9JQ2c4TkVCQVBEUThPRVJNWUZCRVNGeElPRHhVY0ZSYycgKyAnWkdSc2JHeEFVSFI4ZEdoOFlHaHNhLzlzQVF3RUVCUVVHQlFZTUJ3Y01HaEVQRVJvYUdob2FHaG9hR2hvYUdob2FHaG9hJyArICdHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYUdob2FHaG9hR2hvYS84SUFFUWdBQVFBQ0F3RVJBQUlSQVFNUkEnICsgJ2YvRUFCUUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBZi94QUFVQVFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBLzlvQURBTUJBQScgKyAnSVFBeEFBQUFGL1AvL0VBQlFRQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRRUFBUVVDZi8vRUFCUVJBUUFBQUFBJyArICdBQUFBQUFBQUFBQUFBQUFELzJnQUlBUU1CQVQ4QmYvL0VBQlFSQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUQvMmdBSUFRSUInICsgJ0FUOEJmLy9FQUJRUUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUVBQmo4Q2YvL0VBQlFRQVFBQUFBQUFBQUFBQScgKyAnQUFBQUFBQUFBRC8yZ0FJQVFFQUFUOGhmLy9hQUF3REFRQUNBQU1BQUFBUUgvL0VBQlFSQVFBQUFBQUFBQUFBQUFBQUFBJyArICdBQUFBRC8yZ0FJQVFNQkFUOFFmLy9FQUJRUkFRQUFBQUFBQUFBQUFBQUFBQUFBQUFELzJnQUlBUUlCQVQ4UWYvL0VBQlEnICsgJ1FBUUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8yZ0FJQVFFQUFUOFFmLy9aJztcblxuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KS50aGVuKGZ1bmN0aW9uIChiaXRtYXApIHtcbiAgICAgICAgaWYgKGJpdG1hcC53aWR0aCA9PT0gaW1hZ2Uud2lkdGggJiYgYml0bWFwLmhlaWdodCA9PT0gaW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICB9O1xuICB9KTtcbn07XG5cbn0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFdlYiBXb3JrZXIgd3JhcHBlciBmb3IgaW1hZ2UgcmVzaXplIGZ1bmN0aW9uXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgTWF0aExpYiA9IF9kZXJlcV8oJy4vbWF0aGxpYicpO1xuXG4gIHZhciBtYXRoTGliO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIG9ubWVzc2FnZShldikge1xuICAgIHZhciB0aWxlT3B0cyA9IGV2LmRhdGEub3B0cztcbiAgICB2YXIgcmV0dXJuQml0bWFwID0gZmFsc2U7XG5cbiAgICBpZiAoIXRpbGVPcHRzLnNyYyAmJiB0aWxlT3B0cy5zcmNCaXRtYXApIHtcbiAgICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHRpbGVPcHRzLndpZHRoLCB0aWxlT3B0cy5oZWlnaHQpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aWxlT3B0cy5zcmNCaXRtYXAsIDAsIDApO1xuICAgICAgdGlsZU9wdHMuc3JjID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aWxlT3B0cy53aWR0aCwgdGlsZU9wdHMuaGVpZ2h0KS5kYXRhO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICBjYW52YXMgPSBudWxsO1xuICAgICAgdGlsZU9wdHMuc3JjQml0bWFwLmNsb3NlKCk7XG4gICAgICB0aWxlT3B0cy5zcmNCaXRtYXAgPSBudWxsOyAvLyBUZW1wb3JhcnkgZm9yY2Ugb3V0IGRhdGEgdG8gdHlwZWQgYXJyYXksIGJlY2F1c2UgQ2hyb21lIGhhdmUgYXJ0ZWZhY3RzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3BpY2EvaXNzdWVzLzIyM1xuICAgICAgLy8gcmV0dXJuQml0bWFwID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1hdGhMaWIpIG1hdGhMaWIgPSBuZXcgTWF0aExpYihldi5kYXRhLmZlYXR1cmVzKTsgLy8gVXNlIG11bHRpbWF0aCdzIHN5bmMgYXV0by1pbml0LiBBdm9pZCBQcm9taXNlIHVzZSBpbiBvbGQgYnJvd3NlcnMsXG4gICAgLy8gYmVjYXVzZSBwb2x5ZmlsbHMgYXJlIG5vdCBwcm9wYWdhdGVkIHRvIHdlYndvcmtlci5cblxuICAgIHZhciBkYXRhID0gbWF0aExpYi5yZXNpemVBbmRVbnNoYXJwKHRpbGVPcHRzKTtcblxuICAgIGlmIChyZXR1cm5CaXRtYXApIHtcbiAgICAgIHZhciB0b0ltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEpLCB0aWxlT3B0cy50b1dpZHRoLCB0aWxlT3B0cy50b0hlaWdodCk7XG5cbiAgICAgIHZhciBfY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh0aWxlT3B0cy50b1dpZHRoLCB0aWxlT3B0cy50b0hlaWdodCk7XG5cbiAgICAgIHZhciBfY3R4ID0gX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICBfY3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgIGNyZWF0ZUltYWdlQml0bWFwKF9jYW52YXMpLnRoZW4oZnVuY3Rpb24gKGJpdG1hcCkge1xuICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgYml0bWFwOiBiaXRtYXBcbiAgICAgICAgfSwgW2JpdG1hcF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSwgW2RhdGEuYnVmZmVyXSk7XG4gICAgfVxuICB9O1xufTtcblxufSx7XCIuL21hdGhsaWJcIjoxfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ2FsY3VsYXRlIEdhdXNzaWFuIGJsdXIgb2YgYW4gaW1hZ2UgdXNpbmcgSUlSIGZpbHRlclxuLy8gVGhlIG1ldGhvZCBpcyB0YWtlbiBmcm9tIEludGVsJ3Mgd2hpdGUgcGFwZXIgYW5kIGNvZGUgZXhhbXBsZSBhdHRhY2hlZCB0byBpdDpcbi8vIGh0dHBzOi8vc29mdHdhcmUuaW50ZWwuY29tL2VuLXVzL2FydGljbGVzL2lpci1nYXVzc2lhbi1ibHVyLWZpbHRlclxuLy8gLWltcGxlbWVudGF0aW9uLXVzaW5nLWludGVsLWFkdmFuY2VkLXZlY3Rvci1leHRlbnNpb25zXG5cbnZhciBhMCwgYTEsIGEyLCBhMywgYjEsIGIyLCBsZWZ0X2Nvcm5lciwgcmlnaHRfY29ybmVyO1xuXG5mdW5jdGlvbiBnYXVzc0NvZWYoc2lnbWEpIHtcbiAgaWYgKHNpZ21hIDwgMC41KSB7XG4gICAgc2lnbWEgPSAwLjU7XG4gIH1cblxuICB2YXIgYSA9IE1hdGguZXhwKDAuNzI2ICogMC43MjYpIC8gc2lnbWEsXG4gICAgICBnMSA9IE1hdGguZXhwKC1hKSxcbiAgICAgIGcyID0gTWF0aC5leHAoLTIgKiBhKSxcbiAgICAgIGsgPSAoMSAtIGcxKSAqICgxIC0gZzEpIC8gKDEgKyAyICogYSAqIGcxIC0gZzIpO1xuXG4gIGEwID0gaztcbiAgYTEgPSBrICogKGEgLSAxKSAqIGcxO1xuICBhMiA9IGsgKiAoYSArIDEpICogZzE7XG4gIGEzID0gLWsgKiBnMjtcbiAgYjEgPSAyICogZzE7XG4gIGIyID0gLWcyO1xuICBsZWZ0X2Nvcm5lciA9IChhMCArIGExKSAvICgxIC0gYjEgLSBiMik7XG4gIHJpZ2h0X2Nvcm5lciA9IChhMiArIGEzKSAvICgxIC0gYjEgLSBiMik7XG5cbiAgLy8gQXR0ZW1wdCB0byBmb3JjZSB0eXBlIHRvIEZQMzIuXG4gIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsgYTAsIGExLCBhMiwgYTMsIGIxLCBiMiwgbGVmdF9jb3JuZXIsIHJpZ2h0X2Nvcm5lciBdKTtcbn1cblxuZnVuY3Rpb24gY29udm9sdmVNb25vMTYoc3JjLCBvdXQsIGxpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIC8vIHRha2VzIHNyYyBpbWFnZSBhbmQgd3JpdGVzIHRoZSBibHVycmVkIGFuZCB0cmFuc3Bvc2VkIHJlc3VsdCBpbnRvIG91dFxuXG4gIHZhciBwcmV2X3NyYywgY3Vycl9zcmMsIGN1cnJfb3V0LCBwcmV2X291dCwgcHJldl9wcmV2X291dDtcbiAgdmFyIHNyY19pbmRleCwgb3V0X2luZGV4LCBsaW5lX2luZGV4O1xuICB2YXIgaSwgajtcbiAgdmFyIGNvZWZmX2EwLCBjb2VmZl9hMSwgY29lZmZfYjEsIGNvZWZmX2IyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIHNyY19pbmRleCA9IGkgKiB3aWR0aDtcbiAgICBvdXRfaW5kZXggPSBpO1xuICAgIGxpbmVfaW5kZXggPSAwO1xuXG4gICAgLy8gbGVmdCB0byByaWdodFxuICAgIHByZXZfc3JjID0gc3JjW3NyY19pbmRleF07XG4gICAgcHJldl9wcmV2X291dCA9IHByZXZfc3JjICogY29lZmZbNl07XG4gICAgcHJldl9vdXQgPSBwcmV2X3ByZXZfb3V0O1xuXG4gICAgY29lZmZfYTAgPSBjb2VmZlswXTtcbiAgICBjb2VmZl9hMSA9IGNvZWZmWzFdO1xuICAgIGNvZWZmX2IxID0gY29lZmZbNF07XG4gICAgY29lZmZfYjIgPSBjb2VmZls1XTtcblxuICAgIGZvciAoaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICBjdXJyX3NyYyA9IHNyY1tzcmNfaW5kZXhdO1xuXG4gICAgICBjdXJyX291dCA9IGN1cnJfc3JjICogY29lZmZfYTAgK1xuICAgICAgICAgICAgICAgICBwcmV2X3NyYyAqIGNvZWZmX2ExICtcbiAgICAgICAgICAgICAgICAgcHJldl9vdXQgKiBjb2VmZl9iMSArXG4gICAgICAgICAgICAgICAgIHByZXZfcHJldl9vdXQgKiBjb2VmZl9iMjtcblxuICAgICAgcHJldl9wcmV2X291dCA9IHByZXZfb3V0O1xuICAgICAgcHJldl9vdXQgPSBjdXJyX291dDtcbiAgICAgIHByZXZfc3JjID0gY3Vycl9zcmM7XG5cbiAgICAgIGxpbmVbbGluZV9pbmRleF0gPSBwcmV2X291dDtcbiAgICAgIGxpbmVfaW5kZXgrKztcbiAgICAgIHNyY19pbmRleCsrO1xuICAgIH1cblxuICAgIHNyY19pbmRleC0tO1xuICAgIGxpbmVfaW5kZXgtLTtcbiAgICBvdXRfaW5kZXggKz0gaGVpZ2h0ICogKHdpZHRoIC0gMSk7XG5cbiAgICAvLyByaWdodCB0byBsZWZ0XG4gICAgcHJldl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcbiAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9zcmMgKiBjb2VmZls3XTtcbiAgICBwcmV2X291dCA9IHByZXZfcHJldl9vdXQ7XG4gICAgY3Vycl9zcmMgPSBwcmV2X3NyYztcblxuICAgIGNvZWZmX2EwID0gY29lZmZbMl07XG4gICAgY29lZmZfYTEgPSBjb2VmZlszXTtcblxuICAgIGZvciAoaiA9IHdpZHRoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGN1cnJfb3V0ID0gY3Vycl9zcmMgKiBjb2VmZl9hMCArXG4gICAgICAgICAgICAgICAgIHByZXZfc3JjICogY29lZmZfYTEgK1xuICAgICAgICAgICAgICAgICBwcmV2X291dCAqIGNvZWZmX2IxICtcbiAgICAgICAgICAgICAgICAgcHJldl9wcmV2X291dCAqIGNvZWZmX2IyO1xuXG4gICAgICBwcmV2X3ByZXZfb3V0ID0gcHJldl9vdXQ7XG4gICAgICBwcmV2X291dCA9IGN1cnJfb3V0O1xuXG4gICAgICBwcmV2X3NyYyA9IGN1cnJfc3JjO1xuICAgICAgY3Vycl9zcmMgPSBzcmNbc3JjX2luZGV4XTtcblxuICAgICAgb3V0W291dF9pbmRleF0gPSBsaW5lW2xpbmVfaW5kZXhdICsgcHJldl9vdXQ7XG5cbiAgICAgIHNyY19pbmRleC0tO1xuICAgICAgbGluZV9pbmRleC0tO1xuICAgICAgb3V0X2luZGV4IC09IGhlaWdodDtcbiAgICB9XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBibHVyTW9ubzE2KHNyYywgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIC8vIFF1aWNrIGV4aXQgb24gemVybyByYWRpdXNcbiAgaWYgKCFyYWRpdXMpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIG91dCAgICAgID0gbmV3IFVpbnQxNkFycmF5KHNyYy5sZW5ndGgpLFxuICAgICAgdG1wX2xpbmUgPSBuZXcgRmxvYXQzMkFycmF5KE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcblxuICB2YXIgY29lZmYgPSBnYXVzc0NvZWYocmFkaXVzKTtcblxuICBjb252b2x2ZU1vbm8xNihzcmMsIG91dCwgdG1wX2xpbmUsIGNvZWZmLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICBjb252b2x2ZU1vbm8xNihvdXQsIHNyYywgdG1wX2xpbmUsIGNvZWZmLCBoZWlnaHQsIHdpZHRoLCByYWRpdXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJsdXJNb25vMTY7XG5cbn0se31dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgYXNzaWduICAgICAgICAgPSBfZGVyZXFfKCdvYmplY3QtYXNzaWduJyk7XG52YXIgYmFzZTY0ZGVjb2RlICAgPSBfZGVyZXFfKCcuL2xpYi9iYXNlNjRkZWNvZGUnKTtcbnZhciBoYXNXZWJBc3NlbWJseSA9IF9kZXJlcV8oJy4vbGliL3dhX2RldGVjdCcpO1xuXG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGpzOiB0cnVlLFxuICB3YXNtOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIE11bHRpTWF0aChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNdWx0aU1hdGgpKSByZXR1cm4gbmV3IE11bHRpTWF0aChvcHRpb25zKTtcblxuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcblxuICB0aGlzLm9wdGlvbnMgICAgICAgICA9IG9wdHM7XG5cbiAgdGhpcy5fX2NhY2hlICAgICAgICAgPSB7fTtcblxuICB0aGlzLl9faW5pdF9wcm9taXNlICA9IG51bGw7XG4gIHRoaXMuX19tb2R1bGVzICAgICAgID0gb3B0cy5tb2R1bGVzIHx8IHt9O1xuICB0aGlzLl9fbWVtb3J5ICAgICAgICA9IG51bGw7XG4gIHRoaXMuX193YXNtICAgICAgICAgID0ge307XG5cbiAgdGhpcy5fX2lzTEUgPSAoKG5ldyBVaW50MzJBcnJheSgobmV3IFVpbnQ4QXJyYXkoWyAxLCAwLCAwLCAwIF0pKS5idWZmZXIpKVswXSA9PT0gMSk7XG5cbiAgaWYgKCF0aGlzLm9wdGlvbnMuanMgJiYgIXRoaXMub3B0aW9ucy53YXNtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtYXRobGliOiBhdCBsZWFzdCBcImpzXCIgb3IgXCJ3YXNtXCIgc2hvdWxkIGJlIGVuYWJsZWQnKTtcbiAgfVxufVxuXG5cbk11bHRpTWF0aC5wcm90b3R5cGUuaGFzX3dhc20gPSBoYXNXZWJBc3NlbWJseTtcblxuXG5NdWx0aU1hdGgucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdGhpcy5fX21vZHVsZXNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuXG4gIC8vIFBpbiB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvblxuICBpZiAodGhpcy5vcHRpb25zLndhc20gJiYgdGhpcy5oYXNfd2FzbSgpICYmIG1vZHVsZS53YXNtX2ZuKSB7XG4gICAgdGhpc1ttb2R1bGUubmFtZV0gPSBtb2R1bGUud2FzbV9mbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzW21vZHVsZS5uYW1lXSA9IG1vZHVsZS5mbjtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuXG5NdWx0aU1hdGgucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9faW5pdF9wcm9taXNlKSByZXR1cm4gdGhpcy5fX2luaXRfcHJvbWlzZTtcblxuICBpZiAoIXRoaXMub3B0aW9ucy5qcyAmJiB0aGlzLm9wdGlvbnMud2FzbSAmJiAhdGhpcy5oYXNfd2FzbSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignbWF0aGxpYjogb25seSBcIndhc21cIiB3YXMgZW5hYmxlZCwgYnV0IGl0XFwncyBub3Qgc3VwcG9ydGVkJykpO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuX19pbml0X3Byb21pc2UgPSBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhzZWxmLl9fbW9kdWxlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IHNlbGYuX19tb2R1bGVzW25hbWVdO1xuXG4gICAgaWYgKCFzZWxmLm9wdGlvbnMud2FzbSB8fCAhc2VsZi5oYXNfd2FzbSgpIHx8ICFtb2R1bGUud2FzbV9mbikgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBJZiBhbHJlYWR5IGNvbXBpbGVkIC0gZXhpdFxuICAgIGlmIChzZWxmLl9fd2FzbVtuYW1lXSkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBDb21waWxlIHdhc20gc291cmNlXG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5LmNvbXBpbGUoc2VsZi5fX2Jhc2U2NGRlY29kZShtb2R1bGUud2FzbV9zcmMpKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKG0pIHsgc2VsZi5fX3dhc21bbmFtZV0gPSBtOyB9KTtcbiAgfSkpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZjsgfSk7XG5cbiAgcmV0dXJuIHRoaXMuX19pbml0X3Byb21pc2U7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNZXRob2RzIGJlbG93IGFyZSBmb3IgaW50ZXJuYWwgdXNlIGZyb20gcGx1Z2luc1xuXG5cbi8vIFNpbXBsZSBkZWNvZGUgYmFzZTY0IHRvIHR5cGVkIGFycmF5LiBVc2VmdWwgdG8gbG9hZCBlbWJlZGRlZCB3ZWJhc3NlbWJseVxuLy8gY29kZS4gWW91IHByb2JhYmx5IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fYmFzZTY0ZGVjb2RlID0gYmFzZTY0ZGVjb2RlO1xuXG5cbi8vIEluY3JlYXNlIGN1cnJlbnQgbWVtb3J5IHRvIGluY2x1ZGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcy4gRG8gbm90aGluZyBpZlxuLy8gc2l6ZSBpcyBhbHJlYWR5IG9rLiBZb3UgcHJvYmFibHkgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LFxuLy8gYmVjYXVzZSBpdCB3aWxsIGJlIGludm9rZWQgZnJvbSBgLl9faW5zdGFuY2UoKWAuXG4vL1xuTXVsdGlNYXRoLnByb3RvdHlwZS5fX3JlYWxsb2NhdGUgPSBmdW5jdGlvbiBtZW1fZ3Jvd190byhieXRlcykge1xuICBpZiAoIXRoaXMuX19tZW1vcnkpIHtcbiAgICB0aGlzLl9fbWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gICAgICBpbml0aWFsOiBNYXRoLmNlaWwoYnl0ZXMgLyAoNjQgKiAxMDI0KSlcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5fX21lbW9yeTtcbiAgfVxuXG4gIHZhciBtZW1fc2l6ZSA9IHRoaXMuX19tZW1vcnkuYnVmZmVyLmJ5dGVMZW5ndGg7XG5cbiAgaWYgKG1lbV9zaXplIDwgYnl0ZXMpIHtcbiAgICB0aGlzLl9fbWVtb3J5Lmdyb3coTWF0aC5jZWlsKChieXRlcyAtIG1lbV9zaXplKSAvICg2NCAqIDEwMjQpKSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX21lbW9yeTtcbn07XG5cblxuLy8gUmV0dXJucyBpbnN0YW50aW5hdGVkIHdlYmFzc2VtYmx5IGl0ZW0gYnkgbmFtZSwgd2l0aCBzcGVjaWZpZWQgbWVtb3J5IHNpemVcbi8vIGFuZCBlbnZpcm9ubWVudC5cbi8vIC0gdXNlIGNhY2hlIGlmIGF2YWlsYWJsZVxuLy8gLSBkbyBzeW5jIG1vZHVsZSBpbml0LCBpZiBhc3luYyBpbml0IHdhcyBub3QgY2FsbGVkIGVhcmxpZXJcbi8vIC0gYWxsb2NhdGUgbWVtb3J5IGlmIG5vdCBlbm91Z3RoXG4vLyAtIGNhbiBleHBvcnQgZnVuY3Rpb25zIHRvIHdlYmFzc2VtYmx5IHZpYSBcImVudl9leHRyYVwiLFxuLy8gICBmb3IgZXhhbXBsZSwgeyBleHA6IE1hdGguZXhwIH1cbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9faW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZShuYW1lLCBtZW1zaXplLCBlbnZfZXh0cmEpIHtcbiAgaWYgKG1lbXNpemUpIHRoaXMuX19yZWFsbG9jYXRlKG1lbXNpemUpO1xuXG4gIC8vIElmIC5pbml0KCkgd2FzIG5vdCBjYWxsZWQsIGRvIHN5bmMgY29tcGlsZVxuICBpZiAoIXRoaXMuX193YXNtW25hbWVdKSB7XG4gICAgdmFyIG1vZHVsZSA9IHRoaXMuX19tb2R1bGVzW25hbWVdO1xuICAgIHRoaXMuX193YXNtW25hbWVdID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh0aGlzLl9fYmFzZTY0ZGVjb2RlKG1vZHVsZS53YXNtX3NyYykpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9fY2FjaGVbbmFtZV0pIHtcbiAgICB2YXIgZW52X2Jhc2UgPSB7XG4gICAgICBtZW1vcnlCYXNlOiAwLFxuICAgICAgbWVtb3J5OiB0aGlzLl9fbWVtb3J5LFxuICAgICAgdGFibGVCYXNlOiAwLFxuICAgICAgdGFibGU6IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7IGluaXRpYWw6IDAsIGVsZW1lbnQ6ICdhbnlmdW5jJyB9KVxuICAgIH07XG5cbiAgICB0aGlzLl9fY2FjaGVbbmFtZV0gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UodGhpcy5fX3dhc21bbmFtZV0sIHtcbiAgICAgIGVudjogYXNzaWduKGVudl9iYXNlLCBlbnZfZXh0cmEgfHwge30pXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fX2NhY2hlW25hbWVdO1xufTtcblxuXG4vLyBIZWxwZXIgdG8gY2FsY3VsYXRlIG1lbW9yeSBhbGlnaCBmb3IgcG9pbnRlcnMuIFdlYmFzc2VtYmx5IGRvZXMgbm90IHJlcXVpcmVcbi8vIHRoaXMsIGJ1dCB5b3UgbWF5IHdpc2ggdG8gZXhwZXJpbWVudC4gRGVmYXVsdCBiYXNlID0gODtcbi8vXG5NdWx0aU1hdGgucHJvdG90eXBlLl9fYWxpZ24gPSBmdW5jdGlvbiBhbGlnbihudW1iZXIsIGJhc2UpIHtcbiAgYmFzZSA9IGJhc2UgfHwgODtcbiAgdmFyIHJlbWluZGVyID0gbnVtYmVyICUgYmFzZTtcbiAgcmV0dXJuIG51bWJlciArIChyZW1pbmRlciA/IGJhc2UgLSByZW1pbmRlciA6IDApO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpTWF0aDtcblxufSx7XCIuL2xpYi9iYXNlNjRkZWNvZGVcIjoyMCxcIi4vbGliL3dhX2RldGVjdFwiOjIxLFwib2JqZWN0LWFzc2lnblwiOjIyfV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gYmFzZTY0IGRlY29kZSBzdHIgLT4gVWludDhBcnJheSwgdG8gbG9hZCBXQSBtb2R1bGVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBCQVNFNjRfTUFQID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmFzZTY0ZGVjb2RlKHN0cikge1xuICB2YXIgaW5wdXQgPSBzdHIucmVwbGFjZSgvW1xcclxcbj1dL2csICcnKSwgLy8gcmVtb3ZlIENSL0xGICYgcGFkZGluZyB0byBzaW1wbGlmeSBzY2FuXG4gICAgICBtYXggICA9IGlucHV0Lmxlbmd0aDtcblxuICB2YXIgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoKG1heCAqIDMpID4+IDIpO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgdmFyIGJpdHMgPSAwO1xuICB2YXIgcHRyICA9IDA7XG5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGlmICgoaWR4ICUgNCA9PT0gMCkgJiYgaWR4KSB7XG4gICAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gMTYpICYgMHhGRjtcbiAgICAgIG91dFtwdHIrK10gPSAoYml0cyA+PiA4KSAmIDB4RkY7XG4gICAgICBvdXRbcHRyKytdID0gYml0cyAmIDB4RkY7XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDYpIHwgQkFTRTY0X01BUC5pbmRleE9mKGlucHV0LmNoYXJBdChpZHgpKTtcbiAgfVxuXG4gIC8vIER1bXAgdGFpbFxuXG4gIHZhciB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDE2KSAmIDB4RkY7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDgpICYgMHhGRjtcbiAgICBvdXRbcHRyKytdID0gYml0cyAmIDB4RkY7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDEwKSAmIDB4RkY7XG4gICAgb3V0W3B0cisrXSA9IChiaXRzID4+IDIpICYgMHhGRjtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICBvdXRbcHRyKytdID0gKGJpdHMgPj4gNCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbn0se31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIERldGVjdCBXZWJBc3NlbWJseSBzdXBwb3J0LlxuLy8gLSBDaGVjayBnbG9iYWwgV2ViQXNzZW1ibHkgb2JqZWN0XG4vLyAtIFRyeSB0byBsb2FkIHNpbXBsZSBtb2R1bGUgKGNhbiBiZSBkaXNhYmxlZCB2aWEgQ1NQKVxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgd2E7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNXZWJBc3NlbWJseSgpIHtcbiAgLy8gdXNlIGNhY2hlIGlmIGNhbGxlZCBiZWZvcmU7XG4gIGlmICh0eXBlb2Ygd2EgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2E7XG5cbiAgd2EgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIFdlYkFzc2VtYmx5ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIHdhO1xuXG4gIC8vIElmIFdlYkFzc2VuYmx5IGlzIGRpc2FibGVkLCBjb2RlIGNhbiB0aHJvdyBvbiBjb21waWxlXG4gIHRyeSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JyaW9uL21pbi13YXNtLWZhaWwvYmxvYi9tYXN0ZXIvbWluLXdhc20tZmFpbC5pbi5qc1xuICAgIC8vIEFkZGl0aW9uYWwgY2hlY2sgdGhhdCBXQSBpbnRlcm5hbHMgYXJlIGNvcnJlY3RcblxuICAgIC8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsIG1heC1sZW4gKi9cbiAgICB2YXIgYmluICAgICAgPSBuZXcgVWludDhBcnJheShbIDAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDEsMTI3LDEsMTI3LDMsMiwxLDAsNSwzLDEsMCwxLDcsOCwxLDQsMTE2LDEwMSwxMTUsMTE2LDAsMCwxMCwxNiwxLDE0LDAsMzIsMCw2NSwxLDU0LDIsMCwzMiwwLDQwLDIsMCwxMSBdKTtcbiAgICB2YXIgbW9kdWxlICAgPSBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKGJpbik7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwge30pO1xuXG4gICAgLy8gdGVzdCBzdG9yaW5nIHRvIGFuZCBsb2FkaW5nIGZyb20gYSBub24temVybyBsb2NhdGlvbiB2aWEgYSBwYXJhbWV0ZXIuXG4gICAgLy8gU2FmYXJpIG9uIGlPUyAxMS4yLjUgcmV0dXJucyAwIHVuZXhwZWN0ZWRseSBhdCBub24temVybyBsb2NhdGlvbnNcbiAgICBpZiAoaW5zdGFuY2UuZXhwb3J0cy50ZXN0KDQpICE9PSAwKSB3YSA9IHRydWU7XG5cbiAgICByZXR1cm4gd2E7XG4gIH0gY2F0Y2ggKF9fKSB7fVxuXG4gIHJldHVybiB3YTtcbn07XG5cbn0se31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbn0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBidW5kbGVGbiA9IGFyZ3VtZW50c1szXTtcbnZhciBzb3VyY2VzID0gYXJndW1lbnRzWzRdO1xudmFyIGNhY2hlID0gYXJndW1lbnRzWzVdO1xuXG52YXIgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBvcHRpb25zKSB7XG4gICAgdmFyIHdrZXk7XG4gICAgdmFyIGNhY2hlS2V5cyA9IE9iamVjdC5rZXlzKGNhY2hlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2FjaGVLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gY2FjaGVLZXlzW2ldO1xuICAgICAgICB2YXIgZXhwID0gY2FjaGVba2V5XS5leHBvcnRzO1xuICAgICAgICAvLyBVc2luZyBiYWJlbCBhcyBhIHRyYW5zcGlsZXIgdG8gdXNlIGVzbW9kdWxlLCB0aGUgZXhwb3J0IHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBkZWZhdWx0IGV4cG9ydCBhcyBhIHByb3BlcnR5IG9mIGl0LiBUbyBlbnN1cmVcbiAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGFwaSBhbmQgYmFiZWwgZXNtb2R1bGUgZXhwb3J0cyBhcmUgYm90aCBzdXBwb3J0ZWQgd2VcbiAgICAgICAgLy8gY2hlY2sgZm9yIGJvdGhcbiAgICAgICAgaWYgKGV4cCA9PT0gZm4gfHwgZXhwICYmIGV4cC5kZWZhdWx0ID09PSBmbikge1xuICAgICAgICAgICAgd2tleSA9IGtleTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF3a2V5KSB7XG4gICAgICAgIHdrZXkgPSBNYXRoLmZsb29yKE1hdGgucG93KDE2LCA4KSAqIE1hdGgucmFuZG9tKCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIHdjYWNoZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhY2hlS2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjYWNoZUtleXNbaV07XG4gICAgICAgICAgICB3Y2FjaGVba2V5XSA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VzW3drZXldID0gW1xuICAgICAgICAgICAgJ2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeycgKyBmbiArICcoc2VsZik7IH0nLFxuICAgICAgICAgICAgd2NhY2hlXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBza2V5ID0gTWF0aC5mbG9vcihNYXRoLnBvdygxNiwgOCkgKiBNYXRoLnJhbmRvbSgpKS50b1N0cmluZygxNik7XG5cbiAgICB2YXIgc2NhY2hlID0ge307IHNjYWNoZVt3a2V5XSA9IHdrZXk7XG4gICAgc291cmNlc1tza2V5XSA9IFtcbiAgICAgICAgJ2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpeycgK1xuICAgICAgICAgICAgLy8gdHJ5IHRvIGNhbGwgZGVmYXVsdCBpZiBkZWZpbmVkIHRvIGFsc28gc3VwcG9ydCBiYWJlbCBlc21vZHVsZSBleHBvcnRzXG4gICAgICAgICAgICAndmFyIGYgPSByZXF1aXJlKCcgKyBzdHJpbmdpZnkod2tleSkgKyAnKTsnICtcbiAgICAgICAgICAgICcoZi5kZWZhdWx0ID8gZi5kZWZhdWx0IDogZikoc2VsZik7JyArXG4gICAgICAgICd9JyxcbiAgICAgICAgc2NhY2hlXG4gICAgXTtcblxuICAgIHZhciB3b3JrZXJTb3VyY2VzID0ge307XG4gICAgcmVzb2x2ZVNvdXJjZXMoc2tleSk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlU291cmNlcyhrZXkpIHtcbiAgICAgICAgd29ya2VyU291cmNlc1trZXldID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBkZXBQYXRoIGluIHNvdXJjZXNba2V5XVsxXSkge1xuICAgICAgICAgICAgdmFyIGRlcEtleSA9IHNvdXJjZXNba2V5XVsxXVtkZXBQYXRoXTtcbiAgICAgICAgICAgIGlmICghd29ya2VyU291cmNlc1tkZXBLZXldKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVNvdXJjZXMoZGVwS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMgPSAnKCcgKyBidW5kbGVGbiArICcpKHsnXG4gICAgICAgICsgT2JqZWN0LmtleXMod29ya2VyU291cmNlcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KSArICc6WydcbiAgICAgICAgICAgICAgICArIHNvdXJjZXNba2V5XVswXVxuICAgICAgICAgICAgICAgICsgJywnICsgc3RyaW5naWZ5KHNvdXJjZXNba2V5XVsxXSkgKyAnXSdcbiAgICAgICAgICAgIDtcbiAgICAgICAgfSkuam9pbignLCcpXG4gICAgICAgICsgJ30se30sWycgKyBzdHJpbmdpZnkoc2tleSkgKyAnXSknXG4gICAgO1xuXG4gICAgdmFyIFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTCB8fCB3aW5kb3cubW96VVJMIHx8IHdpbmRvdy5tc1VSTDtcblxuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3NyY10sIHsgdHlwZTogJ3RleHQvamF2YXNjcmlwdCcgfSk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5iYXJlKSB7IHJldHVybiBibG9iOyB9XG4gICAgdmFyIHdvcmtlclVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICB3b3JrZXIub2JqZWN0VVJMID0gd29ya2VyVXJsO1xuICAgIHJldHVybiB3b3JrZXI7XG59O1xuXG59LHt9XSxcIi9pbmRleC5qc1wiOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9zLCBfZTsgdHJ5IHsgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG52YXIgYXNzaWduID0gX2RlcmVxXygnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgd2Vid29ya2lmeSA9IF9kZXJlcV8oJ3dlYndvcmtpZnknKTtcblxudmFyIE1hdGhMaWIgPSBfZGVyZXFfKCcuL2xpYi9tYXRobGliJyk7XG5cbnZhciBQb29sID0gX2RlcmVxXygnLi9saWIvcG9vbCcpO1xuXG52YXIgdXRpbHMgPSBfZGVyZXFfKCcuL2xpYi91dGlscycpO1xuXG52YXIgd29ya2VyID0gX2RlcmVxXygnLi9saWIvd29ya2VyJyk7XG5cbnZhciBjcmVhdGVTdGFnZXMgPSBfZGVyZXFfKCcuL2xpYi9zdGVwcGVyJyk7XG5cbnZhciBjcmVhdGVSZWdpb25zID0gX2RlcmVxXygnLi9saWIvdGlsZXInKTtcblxudmFyIGZpbHRlcl9pbmZvID0gX2RlcmVxXygnLi9saWIvbW1fcmVzaXplL3Jlc2l6ZV9maWx0ZXJfaW5mbycpOyAvLyBEZWR1cGxpY2F0ZSBwb29scyAmIGxpbWl0ZXJzIHdpdGggdGhlIHNhbWUgY29uZmlnc1xuLy8gd2hlbiB1c2VyIGNyZWF0ZXMgbXVsdGlwbGUgcGljYSBpbnN0YW5jZXMuXG5cblxudmFyIHNpbmdsZXRvbmVzID0ge307XG52YXIgTkVFRF9TQUZBUklfRklYID0gZmFsc2U7XG5cbnRyeSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgTkVFRF9TQUZBUklfRklYID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+PSAwO1xuICB9XG59IGNhdGNoIChlKSB7fVxuXG52YXIgY29uY3VycmVuY3kgPSAxO1xuXG5pZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgY29uY3VycmVuY3kgPSBNYXRoLm1pbihuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeSB8fCAxLCA0KTtcbn1cblxudmFyIERFRkFVTFRfUElDQV9PUFRTID0ge1xuICB0aWxlOiAxMDI0LFxuICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gIGZlYXR1cmVzOiBbJ2pzJywgJ3dhc20nLCAnd3cnXSxcbiAgaWRsZTogMjAwMCxcbiAgY3JlYXRlQ2FudmFzOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0bXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0bXBDYW52YXM7XG4gIH1cbn07XG52YXIgREVGQVVMVF9SRVNJWkVfT1BUUyA9IHtcbiAgZmlsdGVyOiAnbWtzMjAxMycsXG4gIHVuc2hhcnBBbW91bnQ6IDAsXG4gIHVuc2hhcnBSYWRpdXM6IDAuMCxcbiAgdW5zaGFycFRocmVzaG9sZDogMFxufTtcbnZhciBDQU5fTkVXX0lNQUdFX0RBVEEgPSBmYWxzZTtcbnZhciBDQU5fQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IGZhbHNlO1xudmFyIENBTl9VU0VfQ0FOVkFTX0dFVF9JTUFHRV9EQVRBID0gZmFsc2U7XG52YXIgQ0FOX1VTRV9PRkZTQ1JFRU5fQ0FOVkFTID0gZmFsc2U7XG52YXIgQ0FOX1VTRV9DSUJfUkVHSU9OX0ZPUl9JTUFHRSA9IGZhbHNlO1xuXG5mdW5jdGlvbiB3b3JrZXJGYWJyaWMoKSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHdlYndvcmtpZnkod29ya2VyKSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy52YWx1ZS50ZXJtaW5hdGUoKTtcblxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93Lm1velVSTCB8fCB3aW5kb3cubXNVUkw7XG5cbiAgICAgICAgaWYgKHVybCAmJiB1cmwucmV2b2tlT2JqZWN0VVJMICYmIHRoaXMudmFsdWUub2JqZWN0VVJMKSB7XG4gICAgICAgICAgdXJsLnJldm9rZU9iamVjdFVSTCh0aGlzLnZhbHVlLm9iamVjdFVSTCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBBUEkgbWV0aG9kc1xuXG5cbmZ1bmN0aW9uIFBpY2Eob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGljYSkpIHJldHVybiBuZXcgUGljYShvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUX1BJQ0FfT1BUUywgb3B0aW9ucyB8fCB7fSk7XG4gIHZhciBsaW1pdGVyX2tleSA9IFwibGtfXCIuY29uY2F0KHRoaXMub3B0aW9ucy5jb25jdXJyZW5jeSk7IC8vIFNoYXJlIGxpbWl0ZXJzIHRvIGF2b2lkIG11bHRpcGxlIHBhcmFsbGVsIHdvcmtlcnMgd2hlbiB1c2VyIGNyZWF0ZXNcbiAgLy8gbXVsdGlwbGUgcGljYSBpbnN0YW5jZXMuXG5cbiAgdGhpcy5fX2xpbWl0ID0gc2luZ2xldG9uZXNbbGltaXRlcl9rZXldIHx8IHV0aWxzLmxpbWl0ZXIodGhpcy5vcHRpb25zLmNvbmN1cnJlbmN5KTtcbiAgaWYgKCFzaW5nbGV0b25lc1tsaW1pdGVyX2tleV0pIHNpbmdsZXRvbmVzW2xpbWl0ZXJfa2V5XSA9IHRoaXMuX19saW1pdDsgLy8gTGlzdCBvZiBzdXBwb3J0ZWQgZmVhdHVyZXMsIGFjY29yZGluZyB0byBvcHRpb25zICYgYnJvd3Nlci9ub2RlLmpzXG5cbiAgdGhpcy5mZWF0dXJlcyA9IHtcbiAgICBqczogZmFsc2UsXG4gICAgLy8gcHVyZSBKUyBpbXBsZW1lbnRhdGlvbiwgY2FuIGJlIGRpc2FibGVkIGZvciB0ZXN0aW5nXG4gICAgd2FzbTogZmFsc2UsXG4gICAgLy8gd2ViYXNzZW1ibHkgaW1wbGVtZW50YXRpb24gZm9yIGhlYXZ5IGZ1bmN0aW9uc1xuICAgIGNpYjogZmFsc2UsXG4gICAgLy8gcmVzaXplIHZpYSBjcmVhdGVJbWFnZUJpdG1hcCAob25seSBGRiBhdCB0aGlzIG1vbWVudClcbiAgICB3dzogZmFsc2UgLy8gd2Vid29ya2Vyc1xuXG4gIH07XG4gIHRoaXMuX193b3JrZXJzUG9vbCA9IG51bGw7IC8vIFN0b3JlIHJlcXVlc3RlZCBmZWF0dXJlcyBmb3Igd2Vid29ya2Vyc1xuXG4gIHRoaXMuX19yZXF1ZXN0ZWRfZmVhdHVyZXMgPSBbXTtcbiAgdGhpcy5fX21hdGhsaWIgPSBudWxsO1xufVxuXG5QaWNhLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0aGlzLl9faW5pdFByb21pc2UpIHJldHVybiB0aGlzLl9faW5pdFByb21pc2U7IC8vIFRlc3QgaWYgd2UgY2FuIGNyZWF0ZSBJbWFnZURhdGEgd2l0aG91dCBjYW52YXMgYW5kIG1lbW9yeSBjb3B5XG5cbiAgaWYgKHR5cGVvZiBJbWFnZURhdGEgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgICBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheSg0MDApLCAxMCwgMTApO1xuICAgICAgQ0FOX05FV19JTUFHRV9EQVRBID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChfXykge31cbiAgfSAvLyBJbWFnZUJpdG1hcCBjYW4gYmUgZWZmZWN0aXZlIGluIDIgcGxhY2VzOlxuICAvL1xuICAvLyAxLiBUaHJlYWRlZCBqcGVnIHVucGFjayAoYmFzaWMpXG4gIC8vIDIuIEJ1aWx0LWluIHJlc2l6ZSAoYmxvY2tlZCBkdWUgcHJvYmxlbSBpbiBjaHJvbWUsIHNlZSBpc3N1ZSAjODkpXG4gIC8vXG4gIC8vIEZvciBiYXNpYyB1c2Ugd2UgYWxzbyBuZWVkIEltYWdlQml0bWFwIHdvIHN1cHBvcnQgLmNsb3NlKCkgbWV0aG9kLFxuICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvcnUvZG9jcy9XZWIvQVBJL0ltYWdlQml0bWFwXG5cblxuICBpZiAodHlwZW9mIEltYWdlQml0bWFwICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChJbWFnZUJpdG1hcC5wcm90b3R5cGUgJiYgSW1hZ2VCaXRtYXAucHJvdG90eXBlLmNsb3NlKSB7XG4gICAgICBDQU5fQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoJ0ltYWdlQml0bWFwIGRvZXMgbm90IHN1cHBvcnQgLmNsb3NlKCksIGRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZlYXR1cmVzID0gdGhpcy5vcHRpb25zLmZlYXR1cmVzLnNsaWNlKCk7XG5cbiAgaWYgKGZlYXR1cmVzLmluZGV4T2YoJ2FsbCcpID49IDApIHtcbiAgICBmZWF0dXJlcyA9IFsnY2liJywgJ3dhc20nLCAnanMnLCAnd3cnXTtcbiAgfVxuXG4gIHRoaXMuX19yZXF1ZXN0ZWRfZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgdGhpcy5fX21hdGhsaWIgPSBuZXcgTWF0aExpYihmZWF0dXJlcyk7IC8vIENoZWNrIFdlYldvcmtlciBzdXBwb3J0IGlmIHJlcXVlc3RlZFxuXG4gIGlmIChmZWF0dXJlcy5pbmRleE9mKCd3dycpID49IDApIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1dvcmtlcicgaW4gd2luZG93KSB7XG4gICAgICAvLyBJRSA8PSAxMSBkb24ndCBhbGxvdyB0byBjcmVhdGUgd2Vid29ya2VycyBmcm9tIHN0cmluZy4gV2Ugc2hvdWxkIGNoZWNrIGl0LlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MDE4MTAvd2ViLXdvcmtlcnMtZnJvbS1ibG9iLXVybHMtaW4taWUtMTAtYW5kLTExXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgd2tyID0gX2RlcmVxXygnd2Vid29ya2lmeScpKGZ1bmN0aW9uICgpIHt9KTtcblxuICAgICAgICB3a3IudGVybWluYXRlKCk7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMud3cgPSB0cnVlOyAvLyBwb29sIHVuaXF1ZW5lc3MgZGVwZW5kcyBvbiBwb29sIGNvbmZpZyArIHdlYndvcmtlciBjb25maWdcblxuICAgICAgICB2YXIgd3Bvb2xfa2V5ID0gXCJ3cF9cIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zKSk7XG5cbiAgICAgICAgaWYgKHNpbmdsZXRvbmVzW3dwb29sX2tleV0pIHtcbiAgICAgICAgICB0aGlzLl9fd29ya2Vyc1Bvb2wgPSBzaW5nbGV0b25lc1t3cG9vbF9rZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX193b3JrZXJzUG9vbCA9IG5ldyBQb29sKHdvcmtlckZhYnJpYywgdGhpcy5vcHRpb25zLmlkbGUpO1xuICAgICAgICAgIHNpbmdsZXRvbmVzW3dwb29sX2tleV0gPSB0aGlzLl9fd29ya2Vyc1Bvb2w7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF9fKSB7fVxuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0TWF0aCA9IHRoaXMuX19tYXRobGliLmluaXQoKS50aGVuKGZ1bmN0aW9uIChtYXRobGliKSB7XG4gICAgLy8gQ29weSBkZXRlY3RlZCBmZWF0dXJlc1xuICAgIGFzc2lnbihfdGhpcy5mZWF0dXJlcywgbWF0aGxpYi5mZWF0dXJlcyk7XG4gIH0pO1xuXG4gIHZhciBjaGVja0NpYlJlc2l6ZTtcblxuICBpZiAoIUNBTl9DUkVBVEVfSU1BR0VfQklUTUFQKSB7XG4gICAgY2hlY2tDaWJSZXNpemUgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGNoZWNrQ2liUmVzaXplID0gdXRpbHMuY2liX3N1cHBvcnQodGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcykudGhlbihmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICBpZiAoX3RoaXMuZmVhdHVyZXMuY2liICYmIGZlYXR1cmVzLmluZGV4T2YoJ2NpYicpIDwgMCkge1xuICAgICAgICBfdGhpcy5kZWJ1ZygnY3JlYXRlSW1hZ2VCaXRtYXAoKSByZXNpemUgc3VwcG9ydGVkLCBidXQgZGlzYWJsZWQgYnkgY29uZmlnJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmVhdHVyZXMuaW5kZXhPZignY2liJykgPj0gMCkgX3RoaXMuZmVhdHVyZXMuY2liID0gc3RhdHVzO1xuICAgIH0pO1xuICB9XG5cbiAgQ0FOX1VTRV9DQU5WQVNfR0VUX0lNQUdFX0RBVEEgPSB1dGlscy5jYW5fdXNlX2NhbnZhcyh0aGlzLm9wdGlvbnMuY3JlYXRlQ2FudmFzKTtcbiAgdmFyIGNoZWNrT2Zmc2NyZWVuQ2FudmFzO1xuXG4gIGlmIChDQU5fQ1JFQVRFX0lNQUdFX0JJVE1BUCAmJiBDQU5fTkVXX0lNQUdFX0RBVEEgJiYgZmVhdHVyZXMuaW5kZXhPZignd3cnKSAhPT0gLTEpIHtcbiAgICBjaGVja09mZnNjcmVlbkNhbnZhcyA9IHV0aWxzLndvcmtlcl9vZmZzY3JlZW5fY2FudmFzX3N1cHBvcnQoKTtcbiAgfSBlbHNlIHtcbiAgICBjaGVja09mZnNjcmVlbkNhbnZhcyA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gIH1cblxuICBjaGVja09mZnNjcmVlbkNhbnZhcyA9IGNoZWNrT2Zmc2NyZWVuQ2FudmFzLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIENBTl9VU0VfT0ZGU0NSRUVOX0NBTlZBUyA9IHJlc3VsdDtcbiAgfSk7IC8vIHdlIHVzZSBjcmVhdGVJbWFnZUJpdG1hcCB0byBjcm9wIGltYWdlIGRhdGEgYW5kIHBhc3MgaXQgdG8gd29ya2VycyxcbiAgLy8gc28gbmVlZCB0byBjaGVjayB3aGV0aGVyIGZ1bmN0aW9uIHdvcmtzIGNvcnJlY3RseTtcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTIyMDY3MVxuXG4gIHZhciBjaGVja0NpYlJlZ2lvbiA9IHV0aWxzLmNpYl9jYW5fdXNlX3JlZ2lvbigpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIENBTl9VU0VfQ0lCX1JFR0lPTl9GT1JfSU1BR0UgPSByZXN1bHQ7XG4gIH0pOyAvLyBJbml0IG1hdGggbGliLiBUaGF0J3MgYXN5bmMgYmVjYXVzZSBjYW4gbG9hZCBzb21lXG5cbiAgdGhpcy5fX2luaXRQcm9taXNlID0gUHJvbWlzZS5hbGwoW2luaXRNYXRoLCBjaGVja0NpYlJlc2l6ZSwgY2hlY2tPZmZzY3JlZW5DYW52YXMsIGNoZWNrQ2liUmVnaW9uXSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9KTtcbiAgcmV0dXJuIHRoaXMuX19pbml0UHJvbWlzZTtcbn07IC8vIENhbGwgcmVzaXplciBpbiB3ZWJ3b3JrZXIgb3IgbG9jYWxseSwgZGVwZW5kaW5nIG9uIGNvbmZpZ1xuXG5cblBpY2EucHJvdG90eXBlLl9faW52b2tlUmVzaXplID0gZnVuY3Rpb24gKHRpbGVPcHRzLCBvcHRzKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIFNoYXJlIGNhY2hlIGJldHdlZW4gY2FsbHM6XG4gIC8vXG4gIC8vIC0gd2FzbSBpbnN0YW5jZVxuICAvLyAtIHdhc20gbWVtb3J5IG9iamVjdFxuICAvL1xuICBvcHRzLl9fbWF0aENhY2hlID0gb3B0cy5fX21hdGhDYWNoZSB8fCB7fTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3RoaXMyLmZlYXR1cmVzLnd3KSB7XG4gICAgICAvLyBub3QgcG9zc2libGUgdG8gaGF2ZSBJbWFnZUJpdG1hcCBoZXJlIGlmIHVzZXIgZGlzYWJsZWQgV1dcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IF90aGlzMi5fX21hdGhsaWIucmVzaXplQW5kVW5zaGFycCh0aWxlT3B0cywgb3B0cy5fX21hdGhDYWNoZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciB3ID0gX3RoaXMyLl9fd29ya2Vyc1Bvb2wuYWNxdWlyZSgpO1xuXG4gICAgICBpZiAob3B0cy5jYW5jZWxUb2tlbikgb3B0cy5jYW5jZWxUb2tlbltcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIHcudmFsdWUub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIHcucmVsZWFzZSgpO1xuICAgICAgICBpZiAoZXYuZGF0YS5lcnIpIHJlamVjdChldi5kYXRhLmVycik7ZWxzZSByZXNvbHZlKGV2LmRhdGEpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRyYW5zZmVyID0gW107XG4gICAgICBpZiAodGlsZU9wdHMuc3JjKSB0cmFuc2Zlci5wdXNoKHRpbGVPcHRzLnNyYy5idWZmZXIpO1xuICAgICAgaWYgKHRpbGVPcHRzLnNyY0JpdG1hcCkgdHJhbnNmZXIucHVzaCh0aWxlT3B0cy5zcmNCaXRtYXApO1xuICAgICAgdy52YWx1ZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIG9wdHM6IHRpbGVPcHRzLFxuICAgICAgICBmZWF0dXJlczogX3RoaXMyLl9fcmVxdWVzdGVkX2ZlYXR1cmVzLFxuICAgICAgICBwcmVsb2FkOiB7XG4gICAgICAgICAgd2FzbV9ub2R1bGU6IF90aGlzMi5fX21hdGhsaWIuX19cbiAgICAgICAgfVxuICAgICAgfSwgdHJhbnNmZXIpO1xuICAgIH0pO1xuICB9KTtcbn07IC8vIHRoaXMgZnVuY3Rpb24gY2FuIHJldHVybiBwcm9taXNlIGlmIGNyZWF0ZUltYWdlQml0bWFwIGlzIHVzZWRcblxuXG5QaWNhLnByb3RvdHlwZS5fX2V4dHJhY3RUaWxlRGF0YSA9IGZ1bmN0aW9uICh0aWxlLCBmcm9tLCBvcHRzLCBzdGFnZUVudiwgZXh0cmFjdFRvKSB7XG4gIGlmICh0aGlzLmZlYXR1cmVzLnd3ICYmIENBTl9VU0VfT0ZGU0NSRUVOX0NBTlZBUyAmJiAoIC8vIGNyZWF0ZUltYWdlQml0bWFwIGRvZXNuJ3Qgd29yayBmb3IgaW1hZ2VzIChJbWFnZSwgSW1hZ2VCaXRtYXApIHdpdGggRXhpZiBvcmllbnRhdGlvbiBpbiBDaHJvbWUsXG4gIC8vIGNhbiB1c2UgY2FudmFzIGJlY2F1c2UgY2FudmFzIGRvZXNuJ3QgaGF2ZSBvcmllbnRhdGlvbjtcbiAgLy8gc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMjA2NzFcbiAgdXRpbHMuaXNDYW52YXMoZnJvbSkgfHwgQ0FOX1VTRV9DSUJfUkVHSU9OX0ZPUl9JTUFHRSkpIHtcbiAgICB0aGlzLmRlYnVnKCdDcmVhdGUgdGlsZSBmb3IgT2Zmc2NyZWVuQ2FudmFzJyk7XG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKHN0YWdlRW52LnNyY0ltYWdlQml0bWFwIHx8IGZyb20sIHRpbGUueCwgdGlsZS55LCB0aWxlLndpZHRoLCB0aWxlLmhlaWdodCkudGhlbihmdW5jdGlvbiAoYml0bWFwKSB7XG4gICAgICBleHRyYWN0VG8uc3JjQml0bWFwID0gYml0bWFwO1xuICAgICAgcmV0dXJuIGV4dHJhY3RUbztcbiAgICB9KTtcbiAgfSAvLyBFeHRyYWN0IHRpbGUgUkdCQSBidWZmZXIsIGRlcGVuZGluZyBvbiBpbnB1dCB0eXBlXG5cblxuICBpZiAodXRpbHMuaXNDYW52YXMoZnJvbSkpIHtcbiAgICBpZiAoIXN0YWdlRW52LnNyY0N0eCkgc3RhZ2VFbnYuc3JjQ3R4ID0gZnJvbS5nZXRDb250ZXh0KCcyZCcpOyAvLyBJZiBpbnB1dCBpcyBDYW52YXMgLSBleHRyYWN0IHJlZ2lvbiBkYXRhIGRpcmVjdGx5XG5cbiAgICB0aGlzLmRlYnVnKCdHZXQgdGlsZSBwaXhlbCBkYXRhJyk7XG4gICAgZXh0cmFjdFRvLnNyYyA9IHN0YWdlRW52LnNyY0N0eC5nZXRJbWFnZURhdGEodGlsZS54LCB0aWxlLnksIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KS5kYXRhO1xuICAgIHJldHVybiBleHRyYWN0VG87XG4gIH0gLy8gSWYgaW5wdXQgaXMgSW1hZ2Ugb3IgZGVjb2RlZCB0byBJbWFnZUJpdG1hcCxcbiAgLy8gZHJhdyByZWdpb24gdG8gdGVtcG9yYXJ5IGNhbnZhcyBhbmQgZXh0cmFjdCBkYXRhIGZyb20gaXRcbiAgLy9cbiAgLy8gTm90ZSEgQXR0ZW1wdCB0byByZXVzZSB0aGlzIGNhbnZhcyBjYXVzZXMgc2lnbmlmaWNhbnQgc2xvd2Rvd24gaW4gY2hyb21lXG4gIC8vXG5cblxuICB0aGlzLmRlYnVnKCdEcmF3IHRpbGUgaW1hZ2VCaXRtYXAvaW1hZ2UgdG8gdGVtcG9yYXJ5IGNhbnZhcycpO1xuICB2YXIgdG1wQ2FudmFzID0gdGhpcy5vcHRpb25zLmNyZWF0ZUNhbnZhcyh0aWxlLndpZHRoLCB0aWxlLmhlaWdodCk7XG4gIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5JztcbiAgdG1wQ3R4LmRyYXdJbWFnZShzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCB8fCBmcm9tLCB0aWxlLngsIHRpbGUueSwgdGlsZS53aWR0aCwgdGlsZS5oZWlnaHQsIDAsIDAsIHRpbGUud2lkdGgsIHRpbGUuaGVpZ2h0KTtcbiAgdGhpcy5kZWJ1ZygnR2V0IHRpbGUgcGl4ZWwgZGF0YScpO1xuICBleHRyYWN0VG8uc3JjID0gdG1wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aWxlLndpZHRoLCB0aWxlLmhlaWdodCkuZGF0YTsgLy8gU2FmYXJpIDEyIHdvcmthcm91bmRcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9waWNhL2lzc3Vlcy8xOTlcblxuICB0bXBDYW52YXMud2lkdGggPSB0bXBDYW52YXMuaGVpZ2h0ID0gMDtcbiAgcmV0dXJuIGV4dHJhY3RUbztcbn07XG5cblBpY2EucHJvdG90eXBlLl9fbGFuZFRpbGVEYXRhID0gZnVuY3Rpb24gKHRpbGUsIHJlc3VsdCwgc3RhZ2VFbnYpIHtcbiAgdmFyIHRvSW1hZ2VEYXRhO1xuICB0aGlzLmRlYnVnKCdDb252ZXJ0IHJhdyByZ2JhIHRpbGUgcmVzdWx0IHRvIEltYWdlRGF0YScpO1xuXG4gIGlmIChyZXN1bHQuYml0bWFwKSB7XG4gICAgc3RhZ2VFbnYudG9DdHguZHJhd0ltYWdlKHJlc3VsdC5iaXRtYXAsIHRpbGUudG9YLCB0aWxlLnRvWSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoQ0FOX05FV19JTUFHRV9EQVRBKSB7XG4gICAgLy8gdGhpcyBicmFuY2ggaXMgZm9yIG1vZGVybiBicm93c2Vyc1xuICAgIC8vIElmIGBuZXcgSW1hZ2VEYXRhKClgICYgVWludDhDbGFtcGVkQXJyYXkgc3Vwb3J0ZWRcbiAgICB0b0ltYWdlRGF0YSA9IG5ldyBJbWFnZURhdGEobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHJlc3VsdC5kYXRhKSwgdGlsZS50b1dpZHRoLCB0aWxlLnRvSGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayBmb3IgYG5vZGUtY2FudmFzYCBhbmQgb2xkIGJyb3dzZXJzXG4gICAgLy8gKElFMTEgaGFzIEltYWdlRGF0YSBidXQgZG9lcyBub3Qgc3VwcG9ydCBgbmV3IEltYWdlRGF0YSgpYClcbiAgICB0b0ltYWdlRGF0YSA9IHN0YWdlRW52LnRvQ3R4LmNyZWF0ZUltYWdlRGF0YSh0aWxlLnRvV2lkdGgsIHRpbGUudG9IZWlnaHQpO1xuXG4gICAgaWYgKHRvSW1hZ2VEYXRhLmRhdGEuc2V0KSB7XG4gICAgICB0b0ltYWdlRGF0YS5kYXRhLnNldChyZXN1bHQuZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElFOSBkb24ndCBoYXZlIGAuc2V0KClgXG4gICAgICBmb3IgKHZhciBpID0gdG9JbWFnZURhdGEuZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0b0ltYWdlRGF0YS5kYXRhW2ldID0gcmVzdWx0LmRhdGFbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5kZWJ1ZygnRHJhdyB0aWxlJyk7XG5cbiAgaWYgKE5FRURfU0FGQVJJX0ZJWCkge1xuICAgIC8vIFNhZmFyaSBkcmF3cyB0aGluIHdoaXRlIHN0cmlwZXMgYmV0d2VlbiB0aWxlcyB3aXRob3V0IHRoaXMgZml4XG4gICAgc3RhZ2VFbnYudG9DdHgucHV0SW1hZ2VEYXRhKHRvSW1hZ2VEYXRhLCB0aWxlLnRvWCwgdGlsZS50b1ksIHRpbGUudG9Jbm5lclggLSB0aWxlLnRvWCwgdGlsZS50b0lubmVyWSAtIHRpbGUudG9ZLCB0aWxlLnRvSW5uZXJXaWR0aCArIDFlLTUsIHRpbGUudG9Jbm5lckhlaWdodCArIDFlLTUpO1xuICB9IGVsc2Uge1xuICAgIHN0YWdlRW52LnRvQ3R4LnB1dEltYWdlRGF0YSh0b0ltYWdlRGF0YSwgdGlsZS50b1gsIHRpbGUudG9ZLCB0aWxlLnRvSW5uZXJYIC0gdGlsZS50b1gsIHRpbGUudG9Jbm5lclkgLSB0aWxlLnRvWSwgdGlsZS50b0lubmVyV2lkdGgsIHRpbGUudG9Jbm5lckhlaWdodCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblBpY2EucHJvdG90eXBlLl9fdGlsZUFuZFJlc2l6ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0cykge1xuICB2YXIgX3RoaXMzID0gdGhpcztcblxuICB2YXIgc3RhZ2VFbnYgPSB7XG4gICAgc3JjQ3R4OiBudWxsLFxuICAgIHNyY0ltYWdlQml0bWFwOiBudWxsLFxuICAgIGlzSW1hZ2VCaXRtYXBSZXVzZWQ6IGZhbHNlLFxuICAgIHRvQ3R4OiBudWxsXG4gIH07XG5cbiAgdmFyIHByb2Nlc3NUaWxlID0gZnVuY3Rpb24gcHJvY2Vzc1RpbGUodGlsZSkge1xuICAgIHJldHVybiBfdGhpczMuX19saW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAob3B0cy5jYW5jZWxlZCkgcmV0dXJuIG9wdHMuY2FuY2VsVG9rZW47XG4gICAgICB2YXIgdGlsZU9wdHMgPSB7XG4gICAgICAgIHdpZHRoOiB0aWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRpbGUuaGVpZ2h0LFxuICAgICAgICB0b1dpZHRoOiB0aWxlLnRvV2lkdGgsXG4gICAgICAgIHRvSGVpZ2h0OiB0aWxlLnRvSGVpZ2h0LFxuICAgICAgICBzY2FsZVg6IHRpbGUuc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHRpbGUuc2NhbGVZLFxuICAgICAgICBvZmZzZXRYOiB0aWxlLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IHRpbGUub2Zmc2V0WSxcbiAgICAgICAgZmlsdGVyOiBvcHRzLmZpbHRlcixcbiAgICAgICAgdW5zaGFycEFtb3VudDogb3B0cy51bnNoYXJwQW1vdW50LFxuICAgICAgICB1bnNoYXJwUmFkaXVzOiBvcHRzLnVuc2hhcnBSYWRpdXMsXG4gICAgICAgIHVuc2hhcnBUaHJlc2hvbGQ6IG9wdHMudW5zaGFycFRocmVzaG9sZFxuICAgICAgfTtcblxuICAgICAgX3RoaXMzLmRlYnVnKCdJbnZva2UgcmVzaXplIG1hdGgnKTtcblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aWxlT3B0cykudGhlbihmdW5jdGlvbiAodGlsZU9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fX2V4dHJhY3RUaWxlRGF0YSh0aWxlLCBmcm9tLCBvcHRzLCBzdGFnZUVudiwgdGlsZU9wdHMpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodGlsZU9wdHMpIHtcbiAgICAgICAgX3RoaXMzLmRlYnVnKCdJbnZva2UgcmVzaXplIG1hdGgnKTtcblxuICAgICAgICByZXR1cm4gX3RoaXMzLl9faW52b2tlUmVzaXplKHRpbGVPcHRzLCBvcHRzKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAob3B0cy5jYW5jZWxlZCkgcmV0dXJuIG9wdHMuY2FuY2VsVG9rZW47XG4gICAgICAgIHN0YWdlRW52LnNyY0ltYWdlRGF0YSA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpczMuX19sYW5kVGlsZURhdGEodGlsZSwgcmVzdWx0LCBzdGFnZUVudik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTsgLy8gTmVlZCB0byBub3JtYWxpemUgZGF0YSBzb3VyY2UgZmlyc3QuIEl0IGNhbiBiZSBjYW52YXMgb3IgaW1hZ2UuXG4gIC8vIElmIGltYWdlIC0gdHJ5IHRvIGRlY29kZSBpbiBiYWNrZ3JvdW5kIGlmIHBvc3NpYmxlXG5cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgc3RhZ2VFbnYudG9DdHggPSB0by5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmICh1dGlscy5pc0NhbnZhcyhmcm9tKSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZUJpdG1hcChmcm9tKSkge1xuICAgICAgc3RhZ2VFbnYuc3JjSW1hZ2VCaXRtYXAgPSBmcm9tO1xuICAgICAgc3RhZ2VFbnYuaXNJbWFnZUJpdG1hcFJldXNlZCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNJbWFnZShmcm9tKSkge1xuICAgICAgLy8gdHJ5IGRvIGRlY29kZSBpbWFnZSBpbiBiYWNrZ3JvdW5kIGZvciBmYXN0ZXIgbmV4dCBvcGVyYXRpb25zO1xuICAgICAgLy8gaWYgd2UncmUgdXNpbmcgb2Zmc2NyZWVuIGNhbnZhcywgY2liIGlzIGNhbGxlZCBwZXIgdGlsZSwgc28gbm90IG5lZWRlZCBoZXJlXG4gICAgICBpZiAoIUNBTl9DUkVBVEVfSU1BR0VfQklUTUFQKSByZXR1cm4gbnVsbDtcblxuICAgICAgX3RoaXMzLmRlYnVnKCdEZWNvZGUgaW1hZ2UgdmlhIGNyZWF0ZUltYWdlQml0bWFwJyk7XG5cbiAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChmcm9tKS50aGVuKGZ1bmN0aW9uIChpbWFnZUJpdG1hcCkge1xuICAgICAgICBzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCA9IGltYWdlQml0bWFwO1xuICAgICAgfSkgLy8gU3VwcHJlc3MgZXJyb3IgdG8gdXNlIGZhbGxiYWNrLCBpZiBtZXRob2QgZmFpbHNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTkwXG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICBbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignUGljYTogXCIuZnJvbVwiIHNob3VsZCBiZSBJbWFnZSwgQ2FudmFzIG9yIEltYWdlQml0bWFwJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICAgIF90aGlzMy5kZWJ1ZygnQ2FsY3VsYXRlIHRpbGVzJyk7IC8vXG4gICAgLy8gSGVyZSB3ZSBhcmUgd2l0aCBcIm5vcm1hbGl6ZWRcIiBzb3VyY2UsXG4gICAgLy8gZm9sbG93IHRvIHRpbGluZ1xuICAgIC8vXG5cblxuICAgIHZhciByZWdpb25zID0gY3JlYXRlUmVnaW9ucyh7XG4gICAgICB3aWR0aDogb3B0cy53aWR0aCxcbiAgICAgIGhlaWdodDogb3B0cy5oZWlnaHQsXG4gICAgICBzcmNUaWxlU2l6ZTogX3RoaXMzLm9wdGlvbnMudGlsZSxcbiAgICAgIHRvV2lkdGg6IG9wdHMudG9XaWR0aCxcbiAgICAgIHRvSGVpZ2h0OiBvcHRzLnRvSGVpZ2h0LFxuICAgICAgZGVzdFRpbGVCb3JkZXI6IG9wdHMuX19kZXN0VGlsZUJvcmRlclxuICAgIH0pO1xuICAgIHZhciBqb2JzID0gcmVnaW9ucy5tYXAoZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzVGlsZSh0aWxlKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoc3RhZ2VFbnYpIHtcbiAgICAgIGlmIChzdGFnZUVudi5zcmNJbWFnZUJpdG1hcCkge1xuICAgICAgICBpZiAoIXN0YWdlRW52LmlzSW1hZ2VCaXRtYXBSZXVzZWQpIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwLmNsb3NlKCk7XG4gICAgICAgIHN0YWdlRW52LnNyY0ltYWdlQml0bWFwID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpczMuZGVidWcoJ1Byb2Nlc3MgdGlsZXMnKTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChqb2JzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgcmV0dXJuIHRvO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGNsZWFudXAoc3RhZ2VFbnYpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLl9fcHJvY2Vzc1N0YWdlcyA9IGZ1bmN0aW9uIChzdGFnZXMsIGZyb20sIHRvLCBvcHRzKSB7XG4gIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjtcblxuICB2YXIgX3N0YWdlcyRzaGlmdCA9IHN0YWdlcy5zaGlmdCgpLFxuICAgICAgX3N0YWdlcyRzaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc3RhZ2VzJHNoaWZ0LCAyKSxcbiAgICAgIHRvV2lkdGggPSBfc3RhZ2VzJHNoaWZ0MlswXSxcbiAgICAgIHRvSGVpZ2h0ID0gX3N0YWdlcyRzaGlmdDJbMV07XG5cbiAgdmFyIGlzTGFzdFN0YWdlID0gc3RhZ2VzLmxlbmd0aCA9PT0gMDsgLy8gT3B0aW1pemF0aW9uIGZvciBsZWdhY3kgZmlsdGVycyAtXG4gIC8vIG9ubHkgdXNlIHVzZXItZGVmaW5lZCBxdWFsaXR5IGZvciB0aGUgbGFzdCBzdGFnZSxcbiAgLy8gdXNlIHNpbXBsZXIgKEhhbW1pbmcpIGZpbHRlciBmb3IgdGhlIGZpcnN0IHN0YWdlcyB3aGVyZVxuICAvLyBzY2FsZSBmYWN0b3IgaXMgbGFyZ2UgZW5vdWdoIChtb3JlIHRoYW4gMi0zKVxuICAvL1xuICAvLyBGb3IgYWR2YW5jZWQgZmlsdGVycyAobWtzMjAxMyBhbmQgY3VzdG9tKSAtIHNraXAgb3B0aW1pemF0aW9uLFxuICAvLyBiZWNhdXNlIG5lZWQgdG8gYXBwbHkgc2hhcnBlbmluZyBldmVyeSB0aW1lXG5cbiAgdmFyIGZpbHRlcjtcbiAgaWYgKGlzTGFzdFN0YWdlIHx8IGZpbHRlcl9pbmZvLnEyZi5pbmRleE9mKG9wdHMuZmlsdGVyKSA8IDApIGZpbHRlciA9IG9wdHMuZmlsdGVyO2Vsc2UgaWYgKG9wdHMuZmlsdGVyID09PSAnYm94JykgZmlsdGVyID0gJ2JveCc7ZWxzZSBmaWx0ZXIgPSAnaGFtbWluZyc7XG4gIG9wdHMgPSBhc3NpZ24oe30sIG9wdHMsIHtcbiAgICB0b1dpZHRoOiB0b1dpZHRoLFxuICAgIHRvSGVpZ2h0OiB0b0hlaWdodCxcbiAgICBmaWx0ZXI6IGZpbHRlclxuICB9KTtcbiAgdmFyIHRtcENhbnZhcztcblxuICBpZiAoIWlzTGFzdFN0YWdlKSB7XG4gICAgLy8gY3JlYXRlIHRlbXBvcmFyeSBjYW52YXNcbiAgICB0bXBDYW52YXMgPSB0aGlzLm9wdGlvbnMuY3JlYXRlQ2FudmFzKHRvV2lkdGgsIHRvSGVpZ2h0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9fdGlsZUFuZFJlc2l6ZShmcm9tLCBpc0xhc3RTdGFnZSA/IHRvIDogdG1wQ2FudmFzLCBvcHRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNMYXN0U3RhZ2UpIHJldHVybiB0bztcbiAgICBvcHRzLndpZHRoID0gdG9XaWR0aDtcbiAgICBvcHRzLmhlaWdodCA9IHRvSGVpZ2h0O1xuICAgIHJldHVybiBfdGhpczQuX19wcm9jZXNzU3RhZ2VzKHN0YWdlcywgdG1wQ2FudmFzLCB0bywgb3B0cyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIGlmICh0bXBDYW52YXMpIHtcbiAgICAgIC8vIFNhZmFyaSAxMiB3b3JrYXJvdW5kXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3BpY2EvaXNzdWVzLzE5OVxuICAgICAgdG1wQ2FudmFzLndpZHRoID0gdG1wQ2FudmFzLmhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfSk7XG59O1xuXG5QaWNhLnByb3RvdHlwZS5fX3Jlc2l6ZVZpYUNyZWF0ZUltYWdlQml0bWFwID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRzKSB7XG4gIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gIHZhciB0b0N0eCA9IHRvLmdldENvbnRleHQoJzJkJyk7XG4gIHRoaXMuZGVidWcoJ1Jlc2l6ZSB2aWEgY3JlYXRlSW1hZ2VCaXRtYXAoKScpO1xuICByZXR1cm4gY3JlYXRlSW1hZ2VCaXRtYXAoZnJvbSwge1xuICAgIHJlc2l6ZVdpZHRoOiBvcHRzLnRvV2lkdGgsXG4gICAgcmVzaXplSGVpZ2h0OiBvcHRzLnRvSGVpZ2h0LFxuICAgIHJlc2l6ZVF1YWxpdHk6IHV0aWxzLmNpYl9xdWFsaXR5X25hbWUoZmlsdGVyX2luZm8uZjJxW29wdHMuZmlsdGVyXSlcbiAgfSkudGhlbihmdW5jdGlvbiAoaW1hZ2VCaXRtYXApIHtcbiAgICBpZiAob3B0cy5jYW5jZWxlZCkgcmV0dXJuIG9wdHMuY2FuY2VsVG9rZW47IC8vIGlmIG5vIHVuc2hhcnAgLSBkcmF3IGRpcmVjdGx5IHRvIG91dHB1dCBjYW52YXNcblxuICAgIGlmICghb3B0cy51bnNoYXJwQW1vdW50KSB7XG4gICAgICB0b0N0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICAgICAgaW1hZ2VCaXRtYXAuY2xvc2UoKTtcbiAgICAgIHRvQ3R4ID0gbnVsbDtcblxuICAgICAgX3RoaXM1LmRlYnVnKCdGaW5pc2hlZCEnKTtcblxuICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIF90aGlzNS5kZWJ1ZygnVW5zaGFycCByZXN1bHQnKTtcblxuICAgIHZhciB0bXBDYW52YXMgPSBfdGhpczUub3B0aW9ucy5jcmVhdGVDYW52YXMob3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0KTtcblxuICAgIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0bXBDdHguZHJhd0ltYWdlKGltYWdlQml0bWFwLCAwLCAwKTtcbiAgICBpbWFnZUJpdG1hcC5jbG9zZSgpO1xuICAgIHZhciBpRGF0YSA9IHRtcEN0eC5nZXRJbWFnZURhdGEoMCwgMCwgb3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0KTtcblxuICAgIF90aGlzNS5fX21hdGhsaWIudW5zaGFycF9tYXNrKGlEYXRhLmRhdGEsIG9wdHMudG9XaWR0aCwgb3B0cy50b0hlaWdodCwgb3B0cy51bnNoYXJwQW1vdW50LCBvcHRzLnVuc2hhcnBSYWRpdXMsIG9wdHMudW5zaGFycFRocmVzaG9sZCk7XG5cbiAgICB0b0N0eC5wdXRJbWFnZURhdGEoaURhdGEsIDAsIDApOyAvLyBTYWZhcmkgMTIgd29ya2Fyb3VuZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYS9pc3N1ZXMvMTk5XG5cbiAgICB0bXBDYW52YXMud2lkdGggPSB0bXBDYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBpRGF0YSA9IHRtcEN0eCA9IHRtcENhbnZhcyA9IHRvQ3R4ID0gbnVsbDtcblxuICAgIF90aGlzNS5kZWJ1ZygnRmluaXNoZWQhJyk7XG5cbiAgICByZXR1cm4gdG87XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gIHRoaXMuZGVidWcoJ1N0YXJ0IHJlc2l6ZS4uLicpO1xuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9SRVNJWkVfT1BUUyk7XG5cbiAgaWYgKCFpc05hTihvcHRpb25zKSkge1xuICAgIG9wdHMgPSBhc3NpZ24ob3B0cywge1xuICAgICAgcXVhbGl0eTogb3B0aW9uc1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICBvcHRzID0gYXNzaWduKG9wdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgb3B0cy50b1dpZHRoID0gdG8ud2lkdGg7XG4gIG9wdHMudG9IZWlnaHQgPSB0by5oZWlnaHQ7XG4gIG9wdHMud2lkdGggPSBmcm9tLm5hdHVyYWxXaWR0aCB8fCBmcm9tLndpZHRoO1xuICBvcHRzLmhlaWdodCA9IGZyb20ubmF0dXJhbEhlaWdodCB8fCBmcm9tLmhlaWdodDsgLy8gTGVnYWN5IGAucXVhbGl0eWAgb3B0aW9uXG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAncXVhbGl0eScpKSB7XG4gICAgaWYgKG9wdHMucXVhbGl0eSA8IDAgfHwgb3B0cy5xdWFsaXR5ID4gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGljYTogLnF1YWxpdHkgc2hvdWxkIGJlIFswLi4zXSwgZ290IFwiLmNvbmNhdChvcHRzLnF1YWxpdHkpKTtcbiAgICB9XG5cbiAgICBvcHRzLmZpbHRlciA9IGZpbHRlcl9pbmZvLnEyZltvcHRzLnF1YWxpdHldO1xuICB9IC8vIFByZXZlbnQgc3RlcHBlciBmcm9tIGluZmluaXRlIGxvb3BcblxuXG4gIGlmICh0by53aWR0aCA9PT0gMCB8fCB0by5oZWlnaHQgPT09IDApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBvdXRwdXQgc2l6ZTogXCIuY29uY2F0KHRvLndpZHRoLCBcInhcIikuY29uY2F0KHRvLmhlaWdodCkpKTtcbiAgfVxuXG4gIGlmIChvcHRzLnVuc2hhcnBSYWRpdXMgPiAyKSBvcHRzLnVuc2hhcnBSYWRpdXMgPSAyO1xuICBvcHRzLmNhbmNlbGVkID0gZmFsc2U7XG5cbiAgaWYgKG9wdHMuY2FuY2VsVG9rZW4pIHtcbiAgICAvLyBXcmFwIGNhbmNlbFRva2VuIHRvIGF2b2lkIHN1Y2Nlc3NpdmUgcmVzb2x2ZSAmIHNldCBmbGFnXG4gICAgb3B0cy5jYW5jZWxUb2tlbiA9IG9wdHMuY2FuY2VsVG9rZW4udGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgb3B0cy5jYW5jZWxlZCA9IHRydWU7XG4gICAgICB0aHJvdyBkYXRhO1xuICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIG9wdHMuY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIERFU1RfVElMRV9CT1JERVIgPSAzOyAvLyBNYXggcG9zc2libGUgZmlsdGVyIHdpbmRvdyBzaXplXG5cbiAgb3B0cy5fX2Rlc3RUaWxlQm9yZGVyID0gTWF0aC5jZWlsKE1hdGgubWF4KERFU1RfVElMRV9CT1JERVIsIDIuNSAqIG9wdHMudW5zaGFycFJhZGl1cyB8IDApKTtcbiAgcmV0dXJuIHRoaXMuaW5pdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmIChvcHRzLmNhbmNlbGVkKSByZXR1cm4gb3B0cy5jYW5jZWxUb2tlbjsgLy8gaWYgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydHMgcmVzaXplLCBqdXN0IGRvIGl0IGFuZCByZXR1cm5cblxuICAgIGlmIChfdGhpczYuZmVhdHVyZXMuY2liKSB7XG4gICAgICBpZiAoZmlsdGVyX2luZm8ucTJmLmluZGV4T2Yob3B0cy5maWx0ZXIpID49IDApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNi5fX3Jlc2l6ZVZpYUNyZWF0ZUltYWdlQml0bWFwKGZyb20sIHRvLCBvcHRzKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXM2LmRlYnVnKCdjaWIgaXMgZW5hYmxlZCwgYnV0IG5vdCBzdXBwb3J0cyBwcm92aWRlZCBmaWx0ZXIsIGZhbGxiYWNrIHRvIG1hbnVhbCBtYXRoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFDQU5fVVNFX0NBTlZBU19HRVRfSU1BR0VfREFUQSkge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignUGljYTogY2Fubm90IHVzZSBnZXRJbWFnZURhdGEgb24gY2FudmFzLCAnICsgXCJtYWtlIHN1cmUgZmluZ2VycHJpbnRpbmcgcHJvdGVjdGlvbiBpc24ndCBlbmFibGVkXCIpO1xuICAgICAgZXJyLmNvZGUgPSAnRVJSX0dFVF9JTUFHRV9EQVRBJztcbiAgICAgIHRocm93IGVycjtcbiAgICB9IC8vXG4gICAgLy8gTm8gZWFzeSB3YXksIGxldCdzIHJlc2l6ZSBtYW51YWxseSB2aWEgYXJyYXlzXG4gICAgLy9cblxuXG4gICAgdmFyIHN0YWdlcyA9IGNyZWF0ZVN0YWdlcyhvcHRzLndpZHRoLCBvcHRzLmhlaWdodCwgb3B0cy50b1dpZHRoLCBvcHRzLnRvSGVpZ2h0LCBfdGhpczYub3B0aW9ucy50aWxlLCBvcHRzLl9fZGVzdFRpbGVCb3JkZXIpO1xuICAgIHJldHVybiBfdGhpczYuX19wcm9jZXNzU3RhZ2VzKHN0YWdlcywgZnJvbSwgdG8sIG9wdHMpO1xuICB9KTtcbn07IC8vIFJHQkEgYnVmZmVyIHJlc2l6ZVxuLy9cblxuXG5QaWNhLnByb3RvdHlwZS5yZXNpemVCdWZmZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICB2YXIgb3B0cyA9IGFzc2lnbih7fSwgREVGQVVMVF9SRVNJWkVfT1BUUywgb3B0aW9ucyk7IC8vIExlZ2FjeSBgLnF1YWxpdHlgIG9wdGlvblxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ3F1YWxpdHknKSkge1xuICAgIGlmIChvcHRzLnF1YWxpdHkgPCAwIHx8IG9wdHMucXVhbGl0eSA+IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBpY2E6IC5xdWFsaXR5IHNob3VsZCBiZSBbMC4uM10sIGdvdCBcIi5jb25jYXQob3B0cy5xdWFsaXR5KSk7XG4gICAgfVxuXG4gICAgb3B0cy5maWx0ZXIgPSBmaWx0ZXJfaW5mby5xMmZbb3B0cy5xdWFsaXR5XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmluaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RoaXM3Ll9fbWF0aGxpYi5yZXNpemVBbmRVbnNoYXJwKG9wdHMpO1xuICB9KTtcbn07XG5cblBpY2EucHJvdG90eXBlLnRvQmxvYiA9IGZ1bmN0aW9uIChjYW52YXMsIG1pbWVUeXBlLCBxdWFsaXR5KSB7XG4gIG1pbWVUeXBlID0gbWltZVR5cGUgfHwgJ2ltYWdlL3BuZyc7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIGlmIChjYW52YXMudG9CbG9iKSB7XG4gICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKGJsb2IpO1xuICAgICAgfSwgbWltZVR5cGUsIHF1YWxpdHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjYW52YXMuY29udmVydFRvQmxvYikge1xuICAgICAgcmVzb2x2ZShjYW52YXMuY29udmVydFRvQmxvYih7XG4gICAgICAgIHR5cGU6IG1pbWVUeXBlLFxuICAgICAgICBxdWFsaXR5OiBxdWFsaXR5XG4gICAgICB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBGYWxsYmFjayBmb3Igb2xkIGJyb3dzZXJzXG5cblxuICAgIHZhciBhc1N0cmluZyA9IGF0b2IoY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSkuc3BsaXQoJywnKVsxXSk7XG4gICAgdmFyIGxlbiA9IGFzU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgYXNCdWZmZXIgPSBuZXcgVWludDhBcnJheShsZW4pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXNCdWZmZXJbaV0gPSBhc1N0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJlc29sdmUobmV3IEJsb2IoW2FzQnVmZmVyXSwge1xuICAgICAgdHlwZTogbWltZVR5cGVcbiAgICB9KSk7XG4gIH0pO1xufTtcblxuUGljYS5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWNhO1xuXG59LHtcIi4vbGliL21hdGhsaWJcIjoxLFwiLi9saWIvbW1fcmVzaXplL3Jlc2l6ZV9maWx0ZXJfaW5mb1wiOjcsXCIuL2xpYi9wb29sXCI6MTMsXCIuL2xpYi9zdGVwcGVyXCI6MTQsXCIuL2xpYi90aWxlclwiOjE1LFwiLi9saWIvdXRpbHNcIjoxNixcIi4vbGliL3dvcmtlclwiOjE3LFwib2JqZWN0LWFzc2lnblwiOjIyLFwid2Vid29ya2lmeVwiOjIzfV19LHt9LFtdKShcIi9pbmRleC5qc1wiKVxufSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pica/dist/pica.js\n"));

/***/ }),

/***/ "./node_modules/ssim.js/dist/ssim.web.js":
/*!***********************************************!*\
  !*** ./node_modules/ssim.js/dist/ssim.web.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(t,r){ true?module.exports=r():0}(self,(function(){return(()=>{\"use strict\";var t={132:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.bezkrovnySsim=void 0;var a=e(490),i=e(971);function d(t,r,e){var i=t.data,d=r.data,n=e.bitDepth,o=e.k1,h=e.k2,u=Math.pow(2,n)-1,f=Math.pow(o*u,2),v=Math.pow(h*u,2),l=a.average(i),w=a.average(d),s=a.variance(i,l),g=a.variance(d,w);return(2*l*w+f)*(2*a.covariance(i,d,l,w)+v)/((Math.pow(l,2)+Math.pow(w,2)+f)*(s+g+v))}r.bezkrovnySsim=function(t,r,e){for(var a=e.windowSize,n=Math.ceil(t.width/a),o=Math.ceil(t.height/a),h=new Array(n*o),u=0,f=0;f<t.height;f+=a)for(var v=0;v<t.width;v+=a){var l=Math.min(a,t.width-v),w=Math.min(a,t.height-f),s=i.sub(t,v,w,f,l),g=i.sub(r,v,w,f,l);h[u++]=d(s,g,e)}return{data:h,width:n,height:o}}},63:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.defaults=void 0,r.defaults={windowSize:11,k1:.01,k2:.03,bitDepth:8,downsample:\"original\",ssim:\"weber\",maxSize:256,rgb2grayVersion:\"integer\"}},441:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.downsample=void 0;var a=e(490),i=e(971);function d(t,r,e){var a=i.imfilter(t,r,\"symmetric\",\"same\");return i.skip2d(a,[0,e,a.height],[0,e,a.width])}r.downsample=function(t,r){return\"original\"===r.downsample?function(t,r,e){void 0===e&&(e=256);var n=Math.min(t.width,r.height)/e,o=Math.round(n);if(o>1){var h=i.ones(o);t=d(t,h=a.divide2d(h,a.sum2d(h)),o),r=d(r,h,o)}return[t,r]}(t[0],t[1],r.maxSize):t}},607:function(t,r,e){var a=this&&this.__assign||function(){return(a=Object.assign||function(t){for(var r,e=1,a=arguments.length;e<a;e++)for(var i in r=arguments[e])Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i]);return t}).apply(this,arguments)};Object.defineProperty(r,\"__esModule\",{value:!0}),r.ssim=r.getOptions=void 0;var i=e(971),d=e(490),n=e(773),o=e(595),h=e(132),u=e(441),f=e(63),v=e(535),l={fast:n.ssim,original:o.originalSsim,bezkrovny:h.bezkrovnySsim,weber:v.weberSsim};function w(t){var r=a(a({},f.defaults),t);return function(t){if(Object.keys(t).forEach((function(t){if(!(t in f.defaults))throw new Error('\"'+t+'\" is not a valid option')})),\"k1\"in t&&(\"number\"!=typeof t.k1||t.k1<0))throw new Error(\"Invalid k1 value. Default is \"+f.defaults.k1);if(\"k2\"in t&&(\"number\"!=typeof t.k2||t.k2<0))throw new Error(\"Invalid k2 value. Default is \"+f.defaults.k2);if(!(t.ssim in l))throw new Error(\"Invalid ssim option (use: \"+Object.keys(l).join(\", \")+\")\")}(r),r}function s(t,r,e){var a,n,o,h,f=(new Date).getTime(),v=function(t){var r=t[0],e=t[1],a=t[2];return l[a.ssim](r,e,a)}(function(t){var r=t[0],e=t[1],a=t[2],i=u.downsample([r,e],a);return[i[0],i[1],a]}((a=function(t){var r=t[0],e=t[1],a=t[2];if(r.width!==e.width||r.height!==e.height)throw new Error(\"Image dimensions do not match\");return[r,e,a]}([t,r,w(e)]),n=a[0],o=a[1],\"original\"===(h=a[2]).rgb2grayVersion?[i.rgb2gray(n),i.rgb2gray(o),h]:[i.rgb2grayInteger(n),i.rgb2grayInteger(o),h])));return{mssim:void 0!==v.mssim?v.mssim:d.mean2d(v),ssim_map:v,performance:(new Date).getTime()-f}}r.getOptions=w,r.ssim=s,r.default=s},490:(t,r)=>{function e(t){return a(t)/t.length}function a(t){for(var r=0,e=0;e<t.length;e++)r+=t[e];return r}function i(t){for(var r=t.data,e=0,a=0;a<r.length;a++)e+=r[a];return e}function d(t,r){for(var e=t.data,a=t.width,i=t.height,d=new Array(e.length),n=0;n<e.length;n++)d[n]=e[n]+r;return{data:d,width:a,height:i}}function n(t,r){return\"number\"==typeof r?function(t,r){for(var e=t.data,a=t.width,i=t.height,d=new Array(e.length),n=0;n<e.length;n++)d[n]=e[n]*r;return{data:d,width:a,height:i}}(t,r):function(t,r){for(var e=t.data,a=t.width,i=t.height,d=r.data,n=new Array(e.length),o=0;o<e.length;o++)n[o]=e[o]*d[o];return{data:n,width:a,height:i}}(t,r)}Object.defineProperty(r,\"__esModule\",{value:!0}),r.covariance=r.variance=r.mean2d=r.square2d=r.multiply2d=r.divide2d=r.subtract2d=r.add2d=r.sum2d=r.floor=r.sum=r.average=void 0,r.average=e,r.sum=a,r.floor=function(t){for(var r=new Array(t.length),e=0;e<t.length;e++)r[e]=Math.floor(t[e]);return r},r.sum2d=i,r.add2d=function(t,r){return\"number\"==typeof r?d(t,r):function(t,r){for(var e=t.data,a=t.width,i=t.height,d=r.data,n=new Array(e.length),o=0;o<i;o++)for(var h=o*a,u=0;u<a;u++)n[h+u]=e[h+u]+d[h+u];return{data:n,width:a,height:i}}(t,r)},r.subtract2d=function(t,r){return\"number\"==typeof r?d(t,-r):function(t,r){for(var e=t.data,a=t.width,i=t.height,d=r.data,n=new Array(e.length),o=0;o<i;o++)for(var h=o*a,u=0;u<a;u++)n[h+u]=e[h+u]-d[h+u];return{data:n,width:a,height:i}}(t,r)},r.divide2d=function(t,r){return\"number\"==typeof r?function(t,r){for(var e=t.data,a=t.width,i=t.height,d=new Array(e.length),n=0;n<e.length;n++)d[n]=e[n]/r;return{data:d,width:a,height:i}}(t,r):function(t,r){for(var e=t.data,a=t.width,i=t.height,d=r.data,n=new Array(e.length),o=0;o<e.length;o++)n[o]=e[o]/d[o];return{data:n,width:a,height:i}}(t,r)},r.multiply2d=n,r.square2d=function(t){return n(t,t)},r.mean2d=function(t){return i(t)/t.data.length},r.variance=function(t,r){void 0===r&&(r=e(t));for(var a=0,i=t.length;i--;)a+=Math.pow(t[i]-r,2);return a/t.length},r.covariance=function(t,r,a,i){void 0===a&&(a=e(t)),void 0===i&&(i=e(r));for(var d=0,n=t.length;n--;)d+=(t[n]-a)*(r[n]-i);return d/t.length}},687:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.conv2=void 0;var a=e(490),i=e(298),d=e(118),n=e(799);function o(t,r,e){var a=t.data,i=t.width,d=t.height;void 0===e&&(e=\"full\");for(var o=i+r.width-1,h=d+r.height-1,u=n.zeros(h,o).data,f=0;f<r.height;f++)for(var l=0;l<r.width;l++){var w=r.data[f*r.width+l];if(w)for(var s=0;s<d;s++)for(var g=0;g<i;g++)u[(s+f)*o+g+l]+=a[s*i+g]*w}return v({data:u,width:o,height:h},e,d,r.height,i,r.width)}function h(t,r,e){var d=r.data,n=r.width,o=r.height;void 0===e&&(e=\"full\");var h=f(t,i.ones(o,1),i.ones(1,n),e);return a.multiply2d(h,d[0])}function u(t){for(var r=t.data,e=r[0],a=1;a<r.length;a++)if(r[a]!==e)return!1;return!0}function f(t,r,e,a){void 0===a&&(a=\"full\");var i=Math.max(r.height,r.width),d=Math.max(e.height,e.width),n=o(t,r,\"full\");return v(o(n,e,\"full\"),a,t.height,i,t.width,d)}function v(t,r,e,a,i,n){if(\"full\"===r)return t;if(\"same\"===r){var o=Math.ceil((t.height-e)/2),h=Math.ceil((t.width-i)/2);return d.sub(t,o,e,h,i)}return d.sub(t,a-1,e-a+1,n-1,i-n+1)}r.conv2=function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];return t[2]&&t[2].data?f.apply(void 0,t):u(t[1])?h.apply(void 0,t):o.apply(void 0,t)}},346:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.filter2=void 0;var a=e(687);r.filter2=function(t,r,e){return void 0===e&&(e=\"same\"),a.conv2(r,function(t){for(var r=t.data,e=t.width,a=t.height,i=new Array(r.length),d=0;d<a;d++)for(var n=0;n<e;n++)i[d*e+n]=r[(a-1-d)*e+e-1-n];return{data:i,width:e,height:a}}(t),e)}},470:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.fspecial=void 0;var a=e(490);r.fspecial=function(t,r,e){void 0===r&&(r=3),void 0===e&&(e=1.5);var i=function(t,r){for(var e=t.data,a=t.width,i=t.height,d=new Array(e.length),n=0;n<e.length;n++)d[n]=Math.exp(-e[n]/(2*Math.pow(r,2)));return{data:d,width:a,height:i}}(function(t){for(var r=2*t+1,e=new Array(Math.pow(r,2)),a=0;a<r;a++)for(var i=0;i<r;i++)e[a*r+i]=Math.pow(a-t,2)+Math.pow(i-t,2);return{data:e,width:r,height:r}}(r=(r-1)/2),e),d=a.sum2d(i);return a.divide2d(i,d)}},521:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.imfilter=void 0;var a=e(20),i=e(389),d=e(490),n=e(346);r.imfilter=function(t,r,e,o){return void 0===e&&(e=\"symmetric\"),void 0===o&&(o=\"same\"),t=function(t,r,e,n){if(t=i.padarray(t,d.floor([r/2,e/2]),n),0===a.mod(r,2)&&(t.data=t.data.slice(0,-t.width),t.height--),0===a.mod(e,2)){for(var o=[],h=0;h<t.data.length;h++)(h+1)%t.width!=0&&o.push(t.data[h]);t.data=o,t.width--}return t}(t,r.width,r.height,e),o=function(t){return\"same\"===t&&(t=\"valid\"),t}(o),n.filter2(r,t,o)}},971:function(t,r,e){var a=this&&this.__createBinding||(Object.create?function(t,r,e,a){void 0===a&&(a=e),Object.defineProperty(t,a,{enumerable:!0,get:function(){return r[e]}})}:function(t,r,e,a){void 0===a&&(a=e),t[a]=r[e]}),i=this&&this.__exportStar||function(t,r){for(var e in t)\"default\"===e||Object.prototype.hasOwnProperty.call(r,e)||a(r,t,e)};Object.defineProperty(r,\"__esModule\",{value:!0}),i(e(687),r),i(e(346),r),i(e(470),r),i(e(521),r),i(e(150),r),i(e(298),r),i(e(389),r),i(e(582),r),i(e(439),r),i(e(118),r),i(e(240),r),i(e(799),r)},928:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.numbers=void 0,r.numbers=function(t,r,e){for(var a=r*t,i=new Array(a),d=0;d<a;d++)i[d]=e;return{data:i,width:r,height:t}}},20:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.mod=void 0,r.mod=function(t,r){return t-r*Math.floor(t/r)}},150:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.normpdf=void 0,r.normpdf=function(t,r,e){var a=t.data,i=t.width,d=t.height;void 0===r&&(r=0),void 0===e&&(e=1);for(var n=new Array(a.length),o=0;o<a.length;o++){var h=(a[o]-r)/e;n[o]=Math.exp(-Math.pow(h,2)/2)/(2.5066282746310007*e)}return{data:n,width:i,height:d}}},298:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.ones=void 0;var a=e(928);r.ones=function(t,r){return void 0===r&&(r=t),a.numbers(t,r,1)}},389:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.padarray=void 0;var a=e(20);r.padarray=function(t,r,e,i){var d=r[0],n=r[1];return t.height>=d&&t.width>=n?function(t,r){for(var e=r[0],a=r[1],i=t.width+2*a,d=t.height+2*e,n=new Array(i*d),o=-e;o<0;o++){for(var h=-a;h<0;h++)n[(o+e)*i+h+a]=t.data[(Math.abs(o)-1)*t.width+Math.abs(h)-1];for(h=0;h<t.width;h++)n[(o+e)*i+h+a]=t.data[(Math.abs(o)-1)*t.width+h];for(h=t.width;h<t.width+a;h++)n[(o+e)*i+h+a]=t.data[(Math.abs(o)-1)*t.width+2*t.width-h-1]}for(o=0;o<t.height;o++){for(h=-a;h<0;h++)n[(o+e)*i+h+a]=t.data[o*t.width+Math.abs(h)-1];for(h=0;h<t.width;h++)n[(o+e)*i+h+a]=t.data[o*t.width+h];for(h=t.width;h<t.width+a;h++)n[(o+e)*i+h+a]=t.data[o*t.width+2*t.width-h-1]}for(o=t.height;o<t.height+e;o++){for(h=-a;h<0;h++)n[(o+e)*i+h+a]=t.data[(2*t.height-o-1)*t.width+Math.abs(h)-1];for(h=0;h<t.width;h++)n[(o+e)*i+h+a]=t.data[(2*t.height-o-1)*t.width+h];for(h=t.width;h<t.width+a;h++)n[(o+e)*i+h+a]=t.data[(2*t.height-o-1)*t.width+2*t.width-h-1]}return{data:n,width:i,height:d}}(t,[d,n]):function(t,r){for(var e=function(t,r){return{data:t.data.concat(r.data),height:t.height+r.height,width:t.width}}(t,function(t){for(var r=t.data,e=t.width,a=t.height,i=new Array(r.length),d=0;d<a;d++)for(var n=0;n<e;n++)i[d*e+n]=r[(a-1-d)*e+n];return{data:i,width:e,height:a}}(t)),i=t.height+2*r,d=new Array(t.width*i),n=-r;n<t.height+r;n++)for(var o=0;o<t.width;o++)d[(n+r)*t.width+o]=e.data[a.mod(n,e.height)*t.width+o];return{data:d,width:t.width,height:i}}(function(t,r){for(var e=t.width+2*r,i=new Array(e*t.height),d=function(t,r){for(var e=t.width+r.width,a=new Array(t.height*e),i=0;i<t.height;i++){for(var d=0;d<t.width;d++)a[i*e+d]=t.data[i*t.width+d];for(d=0;d<r.width;d++)a[i*e+d+t.width]=r.data[i*r.width+d]}return{data:a,width:e,height:t.height}}(t,function(t){for(var r=t.data,e=t.width,a=t.height,i=new Array(r.length),d=0;d<a;d++)for(var n=0;n<e;n++)i[d*e+n]=r[d*e+e-1-n];return{data:i,width:e,height:a}}(t)),n=0;n<t.height;n++)for(var o=-r;o<t.width+r;o++)i[n*e+o+r]=d.data[n*d.width+a.mod(o,d.width)];return{data:i,width:e,height:t.height}}(t,n),d)}},582:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.rgb2grayInteger=r.rgb2gray=void 0,r.rgb2gray=function(t){for(var r=t.data,e=t.width,a=t.height,i=new Uint8Array(e*a),d=0;d<r.length;d+=4)i[d/4]=.29894*r[d]+.58704*r[d+1]+.11402*r[d+2]+.5;return{data:Array.from(i),width:e,height:a}},r.rgb2grayInteger=function(t){for(var r=t.data,e=t.width,a=t.height,i=new Array(e*a),d=0;d<r.length;d+=4)i[d/4]=77*r[d]+150*r[d+1]+29*r[d+2]+128>>8;return{data:i,width:e,height:a}}},439:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.skip2d=void 0,r.skip2d=function(t,r,e){for(var a=r[0],i=r[1],d=r[2],n=e[0],o=e[1],h=e[2],u=Math.ceil((h-n)/o),f=Math.ceil((d-a)/i),v=new Array(u*f),l=0;l<f;l++)for(var w=0;w<u;w++){var s=a+l*i,g=n+w*o;v[l*u+w]=t.data[s*t.width+g]}return{data:v,width:u,height:f}}},118:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.sub=void 0,r.sub=function(t,r,e,a,i){for(var d=t.data,n=t.width,o=new Array(i*e),h=0;h<e;h++)for(var u=0;u<i;u++)o[h*i+u]=d[(a+h)*n+r+u];return{data:o,width:i,height:e}}},240:(t,r)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.transpose=void 0,r.transpose=function(t){for(var r=t.data,e=t.width,a=t.height,i=new Array(e*a),d=0;d<a;d++)for(var n=0;n<e;n++)i[n*a+d]=r[d*e+n];return{data:i,height:e,width:a}}},799:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.zeros=void 0;var a=e(928);r.zeros=function(t,r){return void 0===r&&(r=t),a.numbers(t,r,0)}},595:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.originalSsim=void 0;var a=e(490),i=e(971);r.originalSsim=function(t,r,e){var d=i.fspecial(\"gaussian\",e.windowSize,1.5),n=Math.pow(2,e.bitDepth)-1,o=Math.pow(e.k1*n,2),h=Math.pow(e.k2*n,2);d=a.divide2d(d,a.sum2d(d));var u=i.filter2(d,t,\"valid\"),f=i.filter2(d,r,\"valid\"),v=a.square2d(u),l=a.square2d(f),w=a.multiply2d(u,f),s=a.square2d(t),g=a.square2d(r),c=a.subtract2d(i.filter2(d,s,\"valid\"),v),p=a.subtract2d(i.filter2(d,g,\"valid\"),l),m=a.subtract2d(i.filter2(d,a.multiply2d(t,r),\"valid\"),w);if(o>0&&h>0){var y=a.add2d(a.multiply2d(w,2),o),b=a.add2d(a.multiply2d(m,2),h),M=a.add2d(a.add2d(v,l),o),_=a.add2d(a.add2d(c,p),h);return a.divide2d(a.multiply2d(y,b),a.multiply2d(M,_))}var O=a.multiply2d(w,2),j=a.multiply2d(m,2),A=a.add2d(v,l),k=a.add2d(c,p);return a.divide2d(a.multiply2d(O,j),a.multiply2d(A,k))}},773:(t,r,e)=>{Object.defineProperty(r,\"__esModule\",{value:!0}),r.ssim=void 0;var a=e(490),i=e(971);r.ssim=function(t,r,e){var d=i.normpdf(function(t){for(var r=Math.floor(t/2),e=new Array(2*r+1),a=-r;a<=r;a++)e[a+r]=Math.abs(a);return{data:e,width:e.length,height:1}}(e.windowSize),0,1.5),n=Math.pow(2,e.bitDepth)-1,o=Math.pow(e.k1*n,2),h=Math.pow(e.k2*n,2);d=a.divide2d(d,a.sum2d(d));var u=i.transpose(d),f=i.conv2(t,d,u,\"valid\"),v=i.conv2(r,d,u,\"valid\"),l=a.square2d(f),w=a.square2d(v),s=a.multiply2d(f,v),g=a.square2d(t),c=a.square2d(r),p=a.subtract2d(i.conv2(g,d,u,\"valid\"),l),m=a.subtract2d(i.conv2(c,d,u,\"valid\"),w),y=a.subtract2d(i.conv2(a.multiply2d(t,r),d,u,\"valid\"),s);return o>0&&h>0?function(t,r,e,i,d,n,o,h){var u=a.add2d(a.multiply2d(t,2),o),f=a.add2d(a.multiply2d(r,2),h),v=a.add2d(a.add2d(e,i),o),l=a.add2d(a.add2d(d,n),h);return a.divide2d(a.multiply2d(u,f),a.multiply2d(v,l))}(s,y,l,w,p,m,o,h):function(t,r,e,i,d,n){var o=a.multiply2d(t,2),h=a.multiply2d(r,2),u=a.add2d(e,i),f=a.add2d(d,n);return a.divide2d(a.multiply2d(o,h),a.multiply2d(u,f))}(s,y,l,w,p,m)}},535:function(t,r){var e=this&&this.__assign||function(){return(e=Object.assign||function(t){for(var r,e=1,a=arguments.length;e<a;e++)for(var i in r=arguments[e])Object.prototype.hasOwnProperty.call(r,i)&&(t[i]=r[i]);return t}).apply(this,arguments)};function a(t,r,e,a){return{rightEdge:e[r*a+t+1],bottomEdge:e[(r+1)*a+t],bottomRightEdge:e[(r+1)*a+t+1]}}function i(t,r){for(var e=t.width,i=t.height,d=t.data,n=e+1,o=i+1,h=new Int32Array(n*o),u=i-1;u>=0;--u)for(var f=e-1;f>=0;--f){var v=a(f,u,h,n),l=v.rightEdge,w=v.bottomEdge,s=v.bottomRightEdge;h[u*n+f]=r(d[u*e+f],f,u)+l+w-s}return{data:h,height:o,width:n}}function d(t,r,e){for(var i=t.width,d=t.height,n=t.data,o=r.data,h=i+1,u=d+1,f=new Int32Array(h*u),v=d-1;v>=0;--v)for(var l=i-1;l>=0;--l){var w=a(l,v,f,h),s=w.rightEdge,g=w.bottomEdge,c=w.bottomRightEdge,p=v*i+l;f[v*h+l]=e(n[p],o[p],l,v)+s+g-c}return{data:f,height:u,width:h}}function n(t,r,e){for(var a=t.width,i=t.height,d=t.data,n=a-1,o=i-1,h=n-r+1,u=o-r+1,f=new Int32Array(h*u),v=0;v<o;++v)for(var l=0;l<n;++l)if(l<h&&v<u){var w=d[a*v+l]-d[a*v+l+r]-d[a*(v+r)+l]+d[a*(v+r)+l+r];f[v*h+l]=w/e}return{height:u,width:h,data:f}}function o(t,r){return n(i(t,(function(t){return t})),r,1)}function h(t,r,e){for(var a=e*e,d=n(i(t,(function(t){return t*t})),e,1),o=0;o<r.data.length;++o){var h=r.data[o]/a,u=d.data[o]/a,f=h*h;d.data[o]=1024*(u-f)}return d}function u(t,r,e,a,i){for(var o=i*i,h=n(d(t,r,(function(t,r){return t*r})),i,1),u=0;u<e.data.length;++u)h.data[u]=1024*(h.data[u]/o-e.data[u]/o*(a.data[u]/o));return h}Object.defineProperty(r,\"__esModule\",{value:!0}),r.weberSsim=r.windowCovariance=r.windowVariance=r.windowSums=r.windowMatrix=r.partialSumMatrix2=r.partialSumMatrix1=void 0,r.partialSumMatrix1=i,r.partialSumMatrix2=d,r.windowMatrix=n,r.windowSums=o,r.windowVariance=h,r.windowCovariance=u,r.weberSsim=function(t,r,a){for(var i=a.bitDepth,d=a.k1,n=a.k2,f=a.windowSize,v=Math.pow(2,i)-1,l=d*v*(d*v),w=n*v*(n*v),s=f*f,g=e(e({},t),{data:Int32Array.from(t.data,(function(t){return t+.5}))}),c=e(e({},r),{data:Int32Array.from(r.data,(function(t){return t+.5}))}),p=o(g,f),m=h(g,p,f),y=o(c,f),b=h(c,y,f),M=u(g,c,p,y,f),_=p.data.length,O=0,j=new Array(_),A=0;A<_;++A){var k=p.data[A]/s,P=y.data[A]/s,S=m.data[A]/1024,x=b.data[A]/1024,E=(2*k*P+l)*(M.data[A]/1024*2+w)/(k*k+P*P+l)/(S+x+w);j[A]=E,0==A?O=E:O+=(E-O)/(A+1)}return{data:j,width:p.width,height:p.height,mssim:O}}}},r={};return function e(a){if(r[a])return r[a].exports;var i=r[a]={exports:{}};return t[a].call(i.exports,i,i.exports,e),i.exports}(607)})()}));\n//# sourceMappingURL=ssim.web.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBc0IsdUNBQXVDLFdBQVcsWUFBWSxnQkFBZ0IsMkRBQTJELFNBQVMsc0NBQXNDLFNBQVMsNlFBQTZRLDBHQUEwRyxLQUFLLHlDQUF5QyxZQUFZLEdBQUcsVUFBVSxLQUFLLHlDQUF5QyxZQUFZLEdBQUcsZ0dBQWdHLElBQUksS0FBSyx1SEFBdUgsK0JBQStCLE9BQU8sZ0RBQWdELE1BQU0scUJBQXFCLDRCQUE0QixZQUFZLFlBQVksb0RBQW9ELE1BQU0sSUFBSTtBQUN0N2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zc2ltLmpzL2Rpc3Qvc3NpbS53ZWIuanM/M2U2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxyKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1yKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxyKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLnNzaW09cigpOnQuc3NpbT1yKCl9KHNlbGYsKGZ1bmN0aW9uKCl7cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezEzMjoodCxyLGUpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5iZXprcm92bnlTc2ltPXZvaWQgMDt2YXIgYT1lKDQ5MCksaT1lKDk3MSk7ZnVuY3Rpb24gZCh0LHIsZSl7dmFyIGk9dC5kYXRhLGQ9ci5kYXRhLG49ZS5iaXREZXB0aCxvPWUuazEsaD1lLmsyLHU9TWF0aC5wb3coMixuKS0xLGY9TWF0aC5wb3cobyp1LDIpLHY9TWF0aC5wb3coaCp1LDIpLGw9YS5hdmVyYWdlKGkpLHc9YS5hdmVyYWdlKGQpLHM9YS52YXJpYW5jZShpLGwpLGc9YS52YXJpYW5jZShkLHcpO3JldHVybigyKmwqdytmKSooMiphLmNvdmFyaWFuY2UoaSxkLGwsdykrdikvKChNYXRoLnBvdyhsLDIpK01hdGgucG93KHcsMikrZikqKHMrZyt2KSl9ci5iZXprcm92bnlTc2ltPWZ1bmN0aW9uKHQscixlKXtmb3IodmFyIGE9ZS53aW5kb3dTaXplLG49TWF0aC5jZWlsKHQud2lkdGgvYSksbz1NYXRoLmNlaWwodC5oZWlnaHQvYSksaD1uZXcgQXJyYXkobipvKSx1PTAsZj0wO2Y8dC5oZWlnaHQ7Zis9YSlmb3IodmFyIHY9MDt2PHQud2lkdGg7dis9YSl7dmFyIGw9TWF0aC5taW4oYSx0LndpZHRoLXYpLHc9TWF0aC5taW4oYSx0LmhlaWdodC1mKSxzPWkuc3ViKHQsdix3LGYsbCksZz1pLnN1YihyLHYsdyxmLGwpO2hbdSsrXT1kKHMsZyxlKX1yZXR1cm57ZGF0YTpoLHdpZHRoOm4saGVpZ2h0Om99fX0sNjM6KHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmRlZmF1bHRzPXZvaWQgMCxyLmRlZmF1bHRzPXt3aW5kb3dTaXplOjExLGsxOi4wMSxrMjouMDMsYml0RGVwdGg6OCxkb3duc2FtcGxlOlwib3JpZ2luYWxcIixzc2ltOlwid2ViZXJcIixtYXhTaXplOjI1NixyZ2IyZ3JheVZlcnNpb246XCJpbnRlZ2VyXCJ9fSw0NDE6KHQscixlKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuZG93bnNhbXBsZT12b2lkIDA7dmFyIGE9ZSg0OTApLGk9ZSg5NzEpO2Z1bmN0aW9uIGQodCxyLGUpe3ZhciBhPWkuaW1maWx0ZXIodCxyLFwic3ltbWV0cmljXCIsXCJzYW1lXCIpO3JldHVybiBpLnNraXAyZChhLFswLGUsYS5oZWlnaHRdLFswLGUsYS53aWR0aF0pfXIuZG93bnNhbXBsZT1mdW5jdGlvbih0LHIpe3JldHVyblwib3JpZ2luYWxcIj09PXIuZG93bnNhbXBsZT9mdW5jdGlvbih0LHIsZSl7dm9pZCAwPT09ZSYmKGU9MjU2KTt2YXIgbj1NYXRoLm1pbih0LndpZHRoLHIuaGVpZ2h0KS9lLG89TWF0aC5yb3VuZChuKTtpZihvPjEpe3ZhciBoPWkub25lcyhvKTt0PWQodCxoPWEuZGl2aWRlMmQoaCxhLnN1bTJkKGgpKSxvKSxyPWQocixoLG8pfXJldHVyblt0LHJdfSh0WzBdLHRbMV0sci5tYXhTaXplKTp0fX0sNjA3OmZ1bmN0aW9uKHQscixlKXt2YXIgYT10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3JldHVybihhPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgcixlPTEsYT1hcmd1bWVudHMubGVuZ3RoO2U8YTtlKyspZm9yKHZhciBpIGluIHI9YXJndW1lbnRzW2VdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGkpJiYodFtpXT1yW2ldKTtyZXR1cm4gdH0pLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5zc2ltPXIuZ2V0T3B0aW9ucz12b2lkIDA7dmFyIGk9ZSg5NzEpLGQ9ZSg0OTApLG49ZSg3NzMpLG89ZSg1OTUpLGg9ZSgxMzIpLHU9ZSg0NDEpLGY9ZSg2Myksdj1lKDUzNSksbD17ZmFzdDpuLnNzaW0sb3JpZ2luYWw6by5vcmlnaW5hbFNzaW0sYmV6a3Jvdm55OmguYmV6a3Jvdm55U3NpbSx3ZWJlcjp2LndlYmVyU3NpbX07ZnVuY3Rpb24gdyh0KXt2YXIgcj1hKGEoe30sZi5kZWZhdWx0cyksdCk7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCEodCBpbiBmLmRlZmF1bHRzKSl0aHJvdyBuZXcgRXJyb3IoJ1wiJyt0KydcIiBpcyBub3QgYSB2YWxpZCBvcHRpb24nKX0pKSxcImsxXCJpbiB0JiYoXCJudW1iZXJcIiE9dHlwZW9mIHQuazF8fHQuazE8MCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrMSB2YWx1ZS4gRGVmYXVsdCBpcyBcIitmLmRlZmF1bHRzLmsxKTtpZihcImsyXCJpbiB0JiYoXCJudW1iZXJcIiE9dHlwZW9mIHQuazJ8fHQuazI8MCkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrMiB2YWx1ZS4gRGVmYXVsdCBpcyBcIitmLmRlZmF1bHRzLmsyKTtpZighKHQuc3NpbSBpbiBsKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNzaW0gb3B0aW9uICh1c2U6IFwiK09iamVjdC5rZXlzKGwpLmpvaW4oXCIsIFwiKStcIilcIil9KHIpLHJ9ZnVuY3Rpb24gcyh0LHIsZSl7dmFyIGEsbixvLGgsZj0obmV3IERhdGUpLmdldFRpbWUoKSx2PWZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sZT10WzFdLGE9dFsyXTtyZXR1cm4gbFthLnNzaW1dKHIsZSxhKX0oZnVuY3Rpb24odCl7dmFyIHI9dFswXSxlPXRbMV0sYT10WzJdLGk9dS5kb3duc2FtcGxlKFtyLGVdLGEpO3JldHVybltpWzBdLGlbMV0sYV19KChhPWZ1bmN0aW9uKHQpe3ZhciByPXRbMF0sZT10WzFdLGE9dFsyXTtpZihyLndpZHRoIT09ZS53aWR0aHx8ci5oZWlnaHQhPT1lLmhlaWdodCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaFwiKTtyZXR1cm5bcixlLGFdfShbdCxyLHcoZSldKSxuPWFbMF0sbz1hWzFdLFwib3JpZ2luYWxcIj09PShoPWFbMl0pLnJnYjJncmF5VmVyc2lvbj9baS5yZ2IyZ3JheShuKSxpLnJnYjJncmF5KG8pLGhdOltpLnJnYjJncmF5SW50ZWdlcihuKSxpLnJnYjJncmF5SW50ZWdlcihvKSxoXSkpKTtyZXR1cm57bXNzaW06dm9pZCAwIT09di5tc3NpbT92Lm1zc2ltOmQubWVhbjJkKHYpLHNzaW1fbWFwOnYscGVyZm9ybWFuY2U6KG5ldyBEYXRlKS5nZXRUaW1lKCktZn19ci5nZXRPcHRpb25zPXcsci5zc2ltPXMsci5kZWZhdWx0PXN9LDQ5MDoodCxyKT0+e2Z1bmN0aW9uIGUodCl7cmV0dXJuIGEodCkvdC5sZW5ndGh9ZnVuY3Rpb24gYSh0KXtmb3IodmFyIHI9MCxlPTA7ZTx0Lmxlbmd0aDtlKyspcis9dFtlXTtyZXR1cm4gcn1mdW5jdGlvbiBpKHQpe2Zvcih2YXIgcj10LmRhdGEsZT0wLGE9MDthPHIubGVuZ3RoO2ErKyllKz1yW2FdO3JldHVybiBlfWZ1bmN0aW9uIGQodCxyKXtmb3IodmFyIGU9dC5kYXRhLGE9dC53aWR0aCxpPXQuaGVpZ2h0LGQ9bmV3IEFycmF5KGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aDtuKyspZFtuXT1lW25dK3I7cmV0dXJue2RhdGE6ZCx3aWR0aDphLGhlaWdodDppfX1mdW5jdGlvbiBuKHQscil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/ZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9dC5kYXRhLGE9dC53aWR0aCxpPXQuaGVpZ2h0LGQ9bmV3IEFycmF5KGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aDtuKyspZFtuXT1lW25dKnI7cmV0dXJue2RhdGE6ZCx3aWR0aDphLGhlaWdodDppfX0odCxyKTpmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10LmRhdGEsYT10LndpZHRoLGk9dC5oZWlnaHQsZD1yLmRhdGEsbj1uZXcgQXJyYXkoZS5sZW5ndGgpLG89MDtvPGUubGVuZ3RoO28rKyluW29dPWVbb10qZFtvXTtyZXR1cm57ZGF0YTpuLHdpZHRoOmEsaGVpZ2h0Oml9fSh0LHIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuY292YXJpYW5jZT1yLnZhcmlhbmNlPXIubWVhbjJkPXIuc3F1YXJlMmQ9ci5tdWx0aXBseTJkPXIuZGl2aWRlMmQ9ci5zdWJ0cmFjdDJkPXIuYWRkMmQ9ci5zdW0yZD1yLmZsb29yPXIuc3VtPXIuYXZlcmFnZT12b2lkIDAsci5hdmVyYWdlPWUsci5zdW09YSxyLmZsb29yPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1uZXcgQXJyYXkodC5sZW5ndGgpLGU9MDtlPHQubGVuZ3RoO2UrKylyW2VdPU1hdGguZmxvb3IodFtlXSk7cmV0dXJuIHJ9LHIuc3VtMmQ9aSxyLmFkZDJkPWZ1bmN0aW9uKHQscil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/ZCh0LHIpOmZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXQuZGF0YSxhPXQud2lkdGgsaT10LmhlaWdodCxkPXIuZGF0YSxuPW5ldyBBcnJheShlLmxlbmd0aCksbz0wO288aTtvKyspZm9yKHZhciBoPW8qYSx1PTA7dTxhO3UrKyluW2grdV09ZVtoK3VdK2RbaCt1XTtyZXR1cm57ZGF0YTpuLHdpZHRoOmEsaGVpZ2h0Oml9fSh0LHIpfSxyLnN1YnRyYWN0MmQ9ZnVuY3Rpb24odCxyKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2Ygcj9kKHQsLXIpOmZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXQuZGF0YSxhPXQud2lkdGgsaT10LmhlaWdodCxkPXIuZGF0YSxuPW5ldyBBcnJheShlLmxlbmd0aCksbz0wO288aTtvKyspZm9yKHZhciBoPW8qYSx1PTA7dTxhO3UrKyluW2grdV09ZVtoK3VdLWRbaCt1XTtyZXR1cm57ZGF0YTpuLHdpZHRoOmEsaGVpZ2h0Oml9fSh0LHIpfSxyLmRpdmlkZTJkPWZ1bmN0aW9uKHQscil7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHI/ZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9dC5kYXRhLGE9dC53aWR0aCxpPXQuaGVpZ2h0LGQ9bmV3IEFycmF5KGUubGVuZ3RoKSxuPTA7bjxlLmxlbmd0aDtuKyspZFtuXT1lW25dL3I7cmV0dXJue2RhdGE6ZCx3aWR0aDphLGhlaWdodDppfX0odCxyKTpmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10LmRhdGEsYT10LndpZHRoLGk9dC5oZWlnaHQsZD1yLmRhdGEsbj1uZXcgQXJyYXkoZS5sZW5ndGgpLG89MDtvPGUubGVuZ3RoO28rKyluW29dPWVbb10vZFtvXTtyZXR1cm57ZGF0YTpuLHdpZHRoOmEsaGVpZ2h0Oml9fSh0LHIpfSxyLm11bHRpcGx5MmQ9bixyLnNxdWFyZTJkPWZ1bmN0aW9uKHQpe3JldHVybiBuKHQsdCl9LHIubWVhbjJkPWZ1bmN0aW9uKHQpe3JldHVybiBpKHQpL3QuZGF0YS5sZW5ndGh9LHIudmFyaWFuY2U9ZnVuY3Rpb24odCxyKXt2b2lkIDA9PT1yJiYocj1lKHQpKTtmb3IodmFyIGE9MCxpPXQubGVuZ3RoO2ktLTspYSs9TWF0aC5wb3codFtpXS1yLDIpO3JldHVybiBhL3QubGVuZ3RofSxyLmNvdmFyaWFuY2U9ZnVuY3Rpb24odCxyLGEsaSl7dm9pZCAwPT09YSYmKGE9ZSh0KSksdm9pZCAwPT09aSYmKGk9ZShyKSk7Zm9yKHZhciBkPTAsbj10Lmxlbmd0aDtuLS07KWQrPSh0W25dLWEpKihyW25dLWkpO3JldHVybiBkL3QubGVuZ3RofX0sNjg3Oih0LHIsZSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmNvbnYyPXZvaWQgMDt2YXIgYT1lKDQ5MCksaT1lKDI5OCksZD1lKDExOCksbj1lKDc5OSk7ZnVuY3Rpb24gbyh0LHIsZSl7dmFyIGE9dC5kYXRhLGk9dC53aWR0aCxkPXQuaGVpZ2h0O3ZvaWQgMD09PWUmJihlPVwiZnVsbFwiKTtmb3IodmFyIG89aStyLndpZHRoLTEsaD1kK3IuaGVpZ2h0LTEsdT1uLnplcm9zKGgsbykuZGF0YSxmPTA7ZjxyLmhlaWdodDtmKyspZm9yKHZhciBsPTA7bDxyLndpZHRoO2wrKyl7dmFyIHc9ci5kYXRhW2Yqci53aWR0aCtsXTtpZih3KWZvcih2YXIgcz0wO3M8ZDtzKyspZm9yKHZhciBnPTA7ZzxpO2crKyl1WyhzK2YpKm8rZytsXSs9YVtzKmkrZ10qd31yZXR1cm4gdih7ZGF0YTp1LHdpZHRoOm8saGVpZ2h0Omh9LGUsZCxyLmhlaWdodCxpLHIud2lkdGgpfWZ1bmN0aW9uIGgodCxyLGUpe3ZhciBkPXIuZGF0YSxuPXIud2lkdGgsbz1yLmhlaWdodDt2b2lkIDA9PT1lJiYoZT1cImZ1bGxcIik7dmFyIGg9Zih0LGkub25lcyhvLDEpLGkub25lcygxLG4pLGUpO3JldHVybiBhLm11bHRpcGx5MmQoaCxkWzBdKX1mdW5jdGlvbiB1KHQpe2Zvcih2YXIgcj10LmRhdGEsZT1yWzBdLGE9MTthPHIubGVuZ3RoO2ErKylpZihyW2FdIT09ZSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBmKHQscixlLGEpe3ZvaWQgMD09PWEmJihhPVwiZnVsbFwiKTt2YXIgaT1NYXRoLm1heChyLmhlaWdodCxyLndpZHRoKSxkPU1hdGgubWF4KGUuaGVpZ2h0LGUud2lkdGgpLG49byh0LHIsXCJmdWxsXCIpO3JldHVybiB2KG8obixlLFwiZnVsbFwiKSxhLHQuaGVpZ2h0LGksdC53aWR0aCxkKX1mdW5jdGlvbiB2KHQscixlLGEsaSxuKXtpZihcImZ1bGxcIj09PXIpcmV0dXJuIHQ7aWYoXCJzYW1lXCI9PT1yKXt2YXIgbz1NYXRoLmNlaWwoKHQuaGVpZ2h0LWUpLzIpLGg9TWF0aC5jZWlsKCh0LndpZHRoLWkpLzIpO3JldHVybiBkLnN1Yih0LG8sZSxoLGkpfXJldHVybiBkLnN1Yih0LGEtMSxlLWErMSxuLTEsaS1uKzEpfXIuY29udjI9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10scj0wO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspdFtyXT1hcmd1bWVudHNbcl07cmV0dXJuIHRbMl0mJnRbMl0uZGF0YT9mLmFwcGx5KHZvaWQgMCx0KTp1KHRbMV0pP2guYXBwbHkodm9pZCAwLHQpOm8uYXBwbHkodm9pZCAwLHQpfX0sMzQ2Oih0LHIsZSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmZpbHRlcjI9dm9pZCAwO3ZhciBhPWUoNjg3KTtyLmZpbHRlcjI9ZnVuY3Rpb24odCxyLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1cInNhbWVcIiksYS5jb252MihyLGZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10LmRhdGEsZT10LndpZHRoLGE9dC5oZWlnaHQsaT1uZXcgQXJyYXkoci5sZW5ndGgpLGQ9MDtkPGE7ZCsrKWZvcih2YXIgbj0wO248ZTtuKyspaVtkKmUrbl09clsoYS0xLWQpKmUrZS0xLW5dO3JldHVybntkYXRhOmksd2lkdGg6ZSxoZWlnaHQ6YX19KHQpLGUpfX0sNDcwOih0LHIsZSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLmZzcGVjaWFsPXZvaWQgMDt2YXIgYT1lKDQ5MCk7ci5mc3BlY2lhbD1mdW5jdGlvbih0LHIsZSl7dm9pZCAwPT09ciYmKHI9Myksdm9pZCAwPT09ZSYmKGU9MS41KTt2YXIgaT1mdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10LmRhdGEsYT10LndpZHRoLGk9dC5oZWlnaHQsZD1uZXcgQXJyYXkoZS5sZW5ndGgpLG49MDtuPGUubGVuZ3RoO24rKylkW25dPU1hdGguZXhwKC1lW25dLygyKk1hdGgucG93KHIsMikpKTtyZXR1cm57ZGF0YTpkLHdpZHRoOmEsaGVpZ2h0Oml9fShmdW5jdGlvbih0KXtmb3IodmFyIHI9Mip0KzEsZT1uZXcgQXJyYXkoTWF0aC5wb3cociwyKSksYT0wO2E8cjthKyspZm9yKHZhciBpPTA7aTxyO2krKyllW2EqcitpXT1NYXRoLnBvdyhhLXQsMikrTWF0aC5wb3coaS10LDIpO3JldHVybntkYXRhOmUsd2lkdGg6cixoZWlnaHQ6cn19KHI9KHItMSkvMiksZSksZD1hLnN1bTJkKGkpO3JldHVybiBhLmRpdmlkZTJkKGksZCl9fSw1MjE6KHQscixlKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuaW1maWx0ZXI9dm9pZCAwO3ZhciBhPWUoMjApLGk9ZSgzODkpLGQ9ZSg0OTApLG49ZSgzNDYpO3IuaW1maWx0ZXI9ZnVuY3Rpb24odCxyLGUsbyl7cmV0dXJuIHZvaWQgMD09PWUmJihlPVwic3ltbWV0cmljXCIpLHZvaWQgMD09PW8mJihvPVwic2FtZVwiKSx0PWZ1bmN0aW9uKHQscixlLG4pe2lmKHQ9aS5wYWRhcnJheSh0LGQuZmxvb3IoW3IvMixlLzJdKSxuKSwwPT09YS5tb2QociwyKSYmKHQuZGF0YT10LmRhdGEuc2xpY2UoMCwtdC53aWR0aCksdC5oZWlnaHQtLSksMD09PWEubW9kKGUsMikpe2Zvcih2YXIgbz1bXSxoPTA7aDx0LmRhdGEubGVuZ3RoO2grKykoaCsxKSV0LndpZHRoIT0wJiZvLnB1c2godC5kYXRhW2hdKTt0LmRhdGE9byx0LndpZHRoLS19cmV0dXJuIHR9KHQsci53aWR0aCxyLmhlaWdodCxlKSxvPWZ1bmN0aW9uKHQpe3JldHVyblwic2FtZVwiPT09dCYmKHQ9XCJ2YWxpZFwiKSx0fShvKSxuLmZpbHRlcjIocix0LG8pfX0sOTcxOmZ1bmN0aW9uKHQscixlKXt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24odCxyLGUsYSl7dm9pZCAwPT09YSYmKGE9ZSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsYSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcltlXX19KX06ZnVuY3Rpb24odCxyLGUsYSl7dm9pZCAwPT09YSYmKGE9ZSksdFthXT1yW2VdfSksaT10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24odCxyKXtmb3IodmFyIGUgaW4gdClcImRlZmF1bHRcIj09PWV8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpfHxhKHIsdCxlKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksaShlKDY4NyksciksaShlKDM0NiksciksaShlKDQ3MCksciksaShlKDUyMSksciksaShlKDE1MCksciksaShlKDI5OCksciksaShlKDM4OSksciksaShlKDU4MiksciksaShlKDQzOSksciksaShlKDExOCksciksaShlKDI0MCksciksaShlKDc5OSkscil9LDkyODoodCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIubnVtYmVycz12b2lkIDAsci5udW1iZXJzPWZ1bmN0aW9uKHQscixlKXtmb3IodmFyIGE9cip0LGk9bmV3IEFycmF5KGEpLGQ9MDtkPGE7ZCsrKWlbZF09ZTtyZXR1cm57ZGF0YTppLHdpZHRoOnIsaGVpZ2h0OnR9fX0sMjA6KHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLm1vZD12b2lkIDAsci5tb2Q9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdC1yKk1hdGguZmxvb3IodC9yKX19LDE1MDoodCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIubm9ybXBkZj12b2lkIDAsci5ub3JtcGRmPWZ1bmN0aW9uKHQscixlKXt2YXIgYT10LmRhdGEsaT10LndpZHRoLGQ9dC5oZWlnaHQ7dm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09ZSYmKGU9MSk7Zm9yKHZhciBuPW5ldyBBcnJheShhLmxlbmd0aCksbz0wO288YS5sZW5ndGg7bysrKXt2YXIgaD0oYVtvXS1yKS9lO25bb109TWF0aC5leHAoLU1hdGgucG93KGgsMikvMikvKDIuNTA2NjI4Mjc0NjMxMDAwNyplKX1yZXR1cm57ZGF0YTpuLHdpZHRoOmksaGVpZ2h0OmR9fX0sMjk4Oih0LHIsZSk9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLm9uZXM9dm9pZCAwO3ZhciBhPWUoOTI4KTtyLm9uZXM9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9dCksYS5udW1iZXJzKHQsciwxKX19LDM4OToodCxyLGUpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5wYWRhcnJheT12b2lkIDA7dmFyIGE9ZSgyMCk7ci5wYWRhcnJheT1mdW5jdGlvbih0LHIsZSxpKXt2YXIgZD1yWzBdLG49clsxXTtyZXR1cm4gdC5oZWlnaHQ+PWQmJnQud2lkdGg+PW4/ZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9clswXSxhPXJbMV0saT10LndpZHRoKzIqYSxkPXQuaGVpZ2h0KzIqZSxuPW5ldyBBcnJheShpKmQpLG89LWU7bzwwO28rKyl7Zm9yKHZhciBoPS1hO2g8MDtoKyspblsobytlKSppK2grYV09dC5kYXRhWyhNYXRoLmFicyhvKS0xKSp0LndpZHRoK01hdGguYWJzKGgpLTFdO2ZvcihoPTA7aDx0LndpZHRoO2grKyluWyhvK2UpKmkraCthXT10LmRhdGFbKE1hdGguYWJzKG8pLTEpKnQud2lkdGgraF07Zm9yKGg9dC53aWR0aDtoPHQud2lkdGgrYTtoKyspblsobytlKSppK2grYV09dC5kYXRhWyhNYXRoLmFicyhvKS0xKSp0LndpZHRoKzIqdC53aWR0aC1oLTFdfWZvcihvPTA7bzx0LmhlaWdodDtvKyspe2ZvcihoPS1hO2g8MDtoKyspblsobytlKSppK2grYV09dC5kYXRhW28qdC53aWR0aCtNYXRoLmFicyhoKS0xXTtmb3IoaD0wO2g8dC53aWR0aDtoKyspblsobytlKSppK2grYV09dC5kYXRhW28qdC53aWR0aCtoXTtmb3IoaD10LndpZHRoO2g8dC53aWR0aCthO2grKyluWyhvK2UpKmkraCthXT10LmRhdGFbbyp0LndpZHRoKzIqdC53aWR0aC1oLTFdfWZvcihvPXQuaGVpZ2h0O288dC5oZWlnaHQrZTtvKyspe2ZvcihoPS1hO2g8MDtoKyspblsobytlKSppK2grYV09dC5kYXRhWygyKnQuaGVpZ2h0LW8tMSkqdC53aWR0aCtNYXRoLmFicyhoKS0xXTtmb3IoaD0wO2g8dC53aWR0aDtoKyspblsobytlKSppK2grYV09dC5kYXRhWygyKnQuaGVpZ2h0LW8tMSkqdC53aWR0aCtoXTtmb3IoaD10LndpZHRoO2g8dC53aWR0aCthO2grKyluWyhvK2UpKmkraCthXT10LmRhdGFbKDIqdC5oZWlnaHQtby0xKSp0LndpZHRoKzIqdC53aWR0aC1oLTFdfXJldHVybntkYXRhOm4sd2lkdGg6aSxoZWlnaHQ6ZH19KHQsW2Qsbl0pOmZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPWZ1bmN0aW9uKHQscil7cmV0dXJue2RhdGE6dC5kYXRhLmNvbmNhdChyLmRhdGEpLGhlaWdodDp0LmhlaWdodCtyLmhlaWdodCx3aWR0aDp0LndpZHRofX0odCxmdW5jdGlvbih0KXtmb3IodmFyIHI9dC5kYXRhLGU9dC53aWR0aCxhPXQuaGVpZ2h0LGk9bmV3IEFycmF5KHIubGVuZ3RoKSxkPTA7ZDxhO2QrKylmb3IodmFyIG49MDtuPGU7bisrKWlbZCplK25dPXJbKGEtMS1kKSplK25dO3JldHVybntkYXRhOmksd2lkdGg6ZSxoZWlnaHQ6YX19KHQpKSxpPXQuaGVpZ2h0KzIqcixkPW5ldyBBcnJheSh0LndpZHRoKmkpLG49LXI7bjx0LmhlaWdodCtyO24rKylmb3IodmFyIG89MDtvPHQud2lkdGg7bysrKWRbKG4rcikqdC53aWR0aCtvXT1lLmRhdGFbYS5tb2QobixlLmhlaWdodCkqdC53aWR0aCtvXTtyZXR1cm57ZGF0YTpkLHdpZHRoOnQud2lkdGgsaGVpZ2h0Oml9fShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10LndpZHRoKzIqcixpPW5ldyBBcnJheShlKnQuaGVpZ2h0KSxkPWZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXQud2lkdGgrci53aWR0aCxhPW5ldyBBcnJheSh0LmhlaWdodCplKSxpPTA7aTx0LmhlaWdodDtpKyspe2Zvcih2YXIgZD0wO2Q8dC53aWR0aDtkKyspYVtpKmUrZF09dC5kYXRhW2kqdC53aWR0aCtkXTtmb3IoZD0wO2Q8ci53aWR0aDtkKyspYVtpKmUrZCt0LndpZHRoXT1yLmRhdGFbaSpyLndpZHRoK2RdfXJldHVybntkYXRhOmEsd2lkdGg6ZSxoZWlnaHQ6dC5oZWlnaHR9fSh0LGZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10LmRhdGEsZT10LndpZHRoLGE9dC5oZWlnaHQsaT1uZXcgQXJyYXkoci5sZW5ndGgpLGQ9MDtkPGE7ZCsrKWZvcih2YXIgbj0wO248ZTtuKyspaVtkKmUrbl09cltkKmUrZS0xLW5dO3JldHVybntkYXRhOmksd2lkdGg6ZSxoZWlnaHQ6YX19KHQpKSxuPTA7bjx0LmhlaWdodDtuKyspZm9yKHZhciBvPS1yO288dC53aWR0aCtyO28rKylpW24qZStvK3JdPWQuZGF0YVtuKmQud2lkdGgrYS5tb2QobyxkLndpZHRoKV07cmV0dXJue2RhdGE6aSx3aWR0aDplLGhlaWdodDp0LmhlaWdodH19KHQsbiksZCl9fSw1ODI6KHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnJnYjJncmF5SW50ZWdlcj1yLnJnYjJncmF5PXZvaWQgMCxyLnJnYjJncmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj10LmRhdGEsZT10LndpZHRoLGE9dC5oZWlnaHQsaT1uZXcgVWludDhBcnJheShlKmEpLGQ9MDtkPHIubGVuZ3RoO2QrPTQpaVtkLzRdPS4yOTg5NCpyW2RdKy41ODcwNCpyW2QrMV0rLjExNDAyKnJbZCsyXSsuNTtyZXR1cm57ZGF0YTpBcnJheS5mcm9tKGkpLHdpZHRoOmUsaGVpZ2h0OmF9fSxyLnJnYjJncmF5SW50ZWdlcj1mdW5jdGlvbih0KXtmb3IodmFyIHI9dC5kYXRhLGU9dC53aWR0aCxhPXQuaGVpZ2h0LGk9bmV3IEFycmF5KGUqYSksZD0wO2Q8ci5sZW5ndGg7ZCs9NClpW2QvNF09NzcqcltkXSsxNTAqcltkKzFdKzI5KnJbZCsyXSsxMjg+Pjg7cmV0dXJue2RhdGE6aSx3aWR0aDplLGhlaWdodDphfX19LDQzOToodCxyKT0+e09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIuc2tpcDJkPXZvaWQgMCxyLnNraXAyZD1mdW5jdGlvbih0LHIsZSl7Zm9yKHZhciBhPXJbMF0saT1yWzFdLGQ9clsyXSxuPWVbMF0sbz1lWzFdLGg9ZVsyXSx1PU1hdGguY2VpbCgoaC1uKS9vKSxmPU1hdGguY2VpbCgoZC1hKS9pKSx2PW5ldyBBcnJheSh1KmYpLGw9MDtsPGY7bCsrKWZvcih2YXIgdz0wO3c8dTt3Kyspe3ZhciBzPWErbCppLGc9bit3Km87dltsKnUrd109dC5kYXRhW3MqdC53aWR0aCtnXX1yZXR1cm57ZGF0YTp2LHdpZHRoOnUsaGVpZ2h0OmZ9fX0sMTE4Oih0LHIpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5zdWI9dm9pZCAwLHIuc3ViPWZ1bmN0aW9uKHQscixlLGEsaSl7Zm9yKHZhciBkPXQuZGF0YSxuPXQud2lkdGgsbz1uZXcgQXJyYXkoaSplKSxoPTA7aDxlO2grKylmb3IodmFyIHU9MDt1PGk7dSsrKW9baCppK3VdPWRbKGEraCkqbityK3VdO3JldHVybntkYXRhOm8sd2lkdGg6aSxoZWlnaHQ6ZX19fSwyNDA6KHQscik9PntPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyLnRyYW5zcG9zZT12b2lkIDAsci50cmFuc3Bvc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciByPXQuZGF0YSxlPXQud2lkdGgsYT10LmhlaWdodCxpPW5ldyBBcnJheShlKmEpLGQ9MDtkPGE7ZCsrKWZvcih2YXIgbj0wO248ZTtuKyspaVtuKmErZF09cltkKmUrbl07cmV0dXJue2RhdGE6aSxoZWlnaHQ6ZSx3aWR0aDphfX19LDc5OToodCxyLGUpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci56ZXJvcz12b2lkIDA7dmFyIGE9ZSg5MjgpO3IuemVyb3M9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09ciYmKHI9dCksYS5udW1iZXJzKHQsciwwKX19LDU5NToodCxyLGUpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5vcmlnaW5hbFNzaW09dm9pZCAwO3ZhciBhPWUoNDkwKSxpPWUoOTcxKTtyLm9yaWdpbmFsU3NpbT1mdW5jdGlvbih0LHIsZSl7dmFyIGQ9aS5mc3BlY2lhbChcImdhdXNzaWFuXCIsZS53aW5kb3dTaXplLDEuNSksbj1NYXRoLnBvdygyLGUuYml0RGVwdGgpLTEsbz1NYXRoLnBvdyhlLmsxKm4sMiksaD1NYXRoLnBvdyhlLmsyKm4sMik7ZD1hLmRpdmlkZTJkKGQsYS5zdW0yZChkKSk7dmFyIHU9aS5maWx0ZXIyKGQsdCxcInZhbGlkXCIpLGY9aS5maWx0ZXIyKGQscixcInZhbGlkXCIpLHY9YS5zcXVhcmUyZCh1KSxsPWEuc3F1YXJlMmQoZiksdz1hLm11bHRpcGx5MmQodSxmKSxzPWEuc3F1YXJlMmQodCksZz1hLnNxdWFyZTJkKHIpLGM9YS5zdWJ0cmFjdDJkKGkuZmlsdGVyMihkLHMsXCJ2YWxpZFwiKSx2KSxwPWEuc3VidHJhY3QyZChpLmZpbHRlcjIoZCxnLFwidmFsaWRcIiksbCksbT1hLnN1YnRyYWN0MmQoaS5maWx0ZXIyKGQsYS5tdWx0aXBseTJkKHQsciksXCJ2YWxpZFwiKSx3KTtpZihvPjAmJmg+MCl7dmFyIHk9YS5hZGQyZChhLm11bHRpcGx5MmQodywyKSxvKSxiPWEuYWRkMmQoYS5tdWx0aXBseTJkKG0sMiksaCksTT1hLmFkZDJkKGEuYWRkMmQodixsKSxvKSxfPWEuYWRkMmQoYS5hZGQyZChjLHApLGgpO3JldHVybiBhLmRpdmlkZTJkKGEubXVsdGlwbHkyZCh5LGIpLGEubXVsdGlwbHkyZChNLF8pKX12YXIgTz1hLm11bHRpcGx5MmQodywyKSxqPWEubXVsdGlwbHkyZChtLDIpLEE9YS5hZGQyZCh2LGwpLGs9YS5hZGQyZChjLHApO3JldHVybiBhLmRpdmlkZTJkKGEubXVsdGlwbHkyZChPLGopLGEubXVsdGlwbHkyZChBLGspKX19LDc3MzoodCxyLGUpPT57T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksci5zc2ltPXZvaWQgMDt2YXIgYT1lKDQ5MCksaT1lKDk3MSk7ci5zc2ltPWZ1bmN0aW9uKHQscixlKXt2YXIgZD1pLm5vcm1wZGYoZnVuY3Rpb24odCl7Zm9yKHZhciByPU1hdGguZmxvb3IodC8yKSxlPW5ldyBBcnJheSgyKnIrMSksYT0tcjthPD1yO2ErKyllW2Ercl09TWF0aC5hYnMoYSk7cmV0dXJue2RhdGE6ZSx3aWR0aDplLmxlbmd0aCxoZWlnaHQ6MX19KGUud2luZG93U2l6ZSksMCwxLjUpLG49TWF0aC5wb3coMixlLmJpdERlcHRoKS0xLG89TWF0aC5wb3coZS5rMSpuLDIpLGg9TWF0aC5wb3coZS5rMipuLDIpO2Q9YS5kaXZpZGUyZChkLGEuc3VtMmQoZCkpO3ZhciB1PWkudHJhbnNwb3NlKGQpLGY9aS5jb252Mih0LGQsdSxcInZhbGlkXCIpLHY9aS5jb252MihyLGQsdSxcInZhbGlkXCIpLGw9YS5zcXVhcmUyZChmKSx3PWEuc3F1YXJlMmQodikscz1hLm11bHRpcGx5MmQoZix2KSxnPWEuc3F1YXJlMmQodCksYz1hLnNxdWFyZTJkKHIpLHA9YS5zdWJ0cmFjdDJkKGkuY29udjIoZyxkLHUsXCJ2YWxpZFwiKSxsKSxtPWEuc3VidHJhY3QyZChpLmNvbnYyKGMsZCx1LFwidmFsaWRcIiksdykseT1hLnN1YnRyYWN0MmQoaS5jb252MihhLm11bHRpcGx5MmQodCxyKSxkLHUsXCJ2YWxpZFwiKSxzKTtyZXR1cm4gbz4wJiZoPjA/ZnVuY3Rpb24odCxyLGUsaSxkLG4sbyxoKXt2YXIgdT1hLmFkZDJkKGEubXVsdGlwbHkyZCh0LDIpLG8pLGY9YS5hZGQyZChhLm11bHRpcGx5MmQociwyKSxoKSx2PWEuYWRkMmQoYS5hZGQyZChlLGkpLG8pLGw9YS5hZGQyZChhLmFkZDJkKGQsbiksaCk7cmV0dXJuIGEuZGl2aWRlMmQoYS5tdWx0aXBseTJkKHUsZiksYS5tdWx0aXBseTJkKHYsbCkpfShzLHksbCx3LHAsbSxvLGgpOmZ1bmN0aW9uKHQscixlLGksZCxuKXt2YXIgbz1hLm11bHRpcGx5MmQodCwyKSxoPWEubXVsdGlwbHkyZChyLDIpLHU9YS5hZGQyZChlLGkpLGY9YS5hZGQyZChkLG4pO3JldHVybiBhLmRpdmlkZTJkKGEubXVsdGlwbHkyZChvLGgpLGEubXVsdGlwbHkyZCh1LGYpKX0ocyx5LGwsdyxwLG0pfX0sNTM1OmZ1bmN0aW9uKHQscil7dmFyIGU9dGhpcyYmdGhpcy5fX2Fzc2lnbnx8ZnVuY3Rpb24oKXtyZXR1cm4oZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbih0KXtmb3IodmFyIHIsZT0xLGE9YXJndW1lbnRzLmxlbmd0aDtlPGE7ZSsrKWZvcih2YXIgaSBpbiByPWFyZ3VtZW50c1tlXSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixpKSYmKHRbaV09cltpXSk7cmV0dXJuIHR9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIGEodCxyLGUsYSl7cmV0dXJue3JpZ2h0RWRnZTplW3IqYSt0KzFdLGJvdHRvbUVkZ2U6ZVsocisxKSphK3RdLGJvdHRvbVJpZ2h0RWRnZTplWyhyKzEpKmErdCsxXX19ZnVuY3Rpb24gaSh0LHIpe2Zvcih2YXIgZT10LndpZHRoLGk9dC5oZWlnaHQsZD10LmRhdGEsbj1lKzEsbz1pKzEsaD1uZXcgSW50MzJBcnJheShuKm8pLHU9aS0xO3U+PTA7LS11KWZvcih2YXIgZj1lLTE7Zj49MDstLWYpe3ZhciB2PWEoZix1LGgsbiksbD12LnJpZ2h0RWRnZSx3PXYuYm90dG9tRWRnZSxzPXYuYm90dG9tUmlnaHRFZGdlO2hbdSpuK2ZdPXIoZFt1KmUrZl0sZix1KStsK3ctc31yZXR1cm57ZGF0YTpoLGhlaWdodDpvLHdpZHRoOm59fWZ1bmN0aW9uIGQodCxyLGUpe2Zvcih2YXIgaT10LndpZHRoLGQ9dC5oZWlnaHQsbj10LmRhdGEsbz1yLmRhdGEsaD1pKzEsdT1kKzEsZj1uZXcgSW50MzJBcnJheShoKnUpLHY9ZC0xO3Y+PTA7LS12KWZvcih2YXIgbD1pLTE7bD49MDstLWwpe3ZhciB3PWEobCx2LGYsaCkscz13LnJpZ2h0RWRnZSxnPXcuYm90dG9tRWRnZSxjPXcuYm90dG9tUmlnaHRFZGdlLHA9dippK2w7Zlt2KmgrbF09ZShuW3BdLG9bcF0sbCx2KStzK2ctY31yZXR1cm57ZGF0YTpmLGhlaWdodDp1LHdpZHRoOmh9fWZ1bmN0aW9uIG4odCxyLGUpe2Zvcih2YXIgYT10LndpZHRoLGk9dC5oZWlnaHQsZD10LmRhdGEsbj1hLTEsbz1pLTEsaD1uLXIrMSx1PW8tcisxLGY9bmV3IEludDMyQXJyYXkoaCp1KSx2PTA7djxvOysrdilmb3IodmFyIGw9MDtsPG47KytsKWlmKGw8aCYmdjx1KXt2YXIgdz1kW2EqditsXS1kW2EqditsK3JdLWRbYSoodityKStsXStkW2EqKHYrcikrbCtyXTtmW3YqaCtsXT13L2V9cmV0dXJue2hlaWdodDp1LHdpZHRoOmgsZGF0YTpmfX1mdW5jdGlvbiBvKHQscil7cmV0dXJuIG4oaSh0LChmdW5jdGlvbih0KXtyZXR1cm4gdH0pKSxyLDEpfWZ1bmN0aW9uIGgodCxyLGUpe2Zvcih2YXIgYT1lKmUsZD1uKGkodCwoZnVuY3Rpb24odCl7cmV0dXJuIHQqdH0pKSxlLDEpLG89MDtvPHIuZGF0YS5sZW5ndGg7KytvKXt2YXIgaD1yLmRhdGFbb10vYSx1PWQuZGF0YVtvXS9hLGY9aCpoO2QuZGF0YVtvXT0xMDI0Kih1LWYpfXJldHVybiBkfWZ1bmN0aW9uIHUodCxyLGUsYSxpKXtmb3IodmFyIG89aSppLGg9bihkKHQsciwoZnVuY3Rpb24odCxyKXtyZXR1cm4gdCpyfSkpLGksMSksdT0wO3U8ZS5kYXRhLmxlbmd0aDsrK3UpaC5kYXRhW3VdPTEwMjQqKGguZGF0YVt1XS9vLWUuZGF0YVt1XS9vKihhLmRhdGFbdV0vbykpO3JldHVybiBofU9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIud2ViZXJTc2ltPXIud2luZG93Q292YXJpYW5jZT1yLndpbmRvd1ZhcmlhbmNlPXIud2luZG93U3Vtcz1yLndpbmRvd01hdHJpeD1yLnBhcnRpYWxTdW1NYXRyaXgyPXIucGFydGlhbFN1bU1hdHJpeDE9dm9pZCAwLHIucGFydGlhbFN1bU1hdHJpeDE9aSxyLnBhcnRpYWxTdW1NYXRyaXgyPWQsci53aW5kb3dNYXRyaXg9bixyLndpbmRvd1N1bXM9byxyLndpbmRvd1ZhcmlhbmNlPWgsci53aW5kb3dDb3ZhcmlhbmNlPXUsci53ZWJlclNzaW09ZnVuY3Rpb24odCxyLGEpe2Zvcih2YXIgaT1hLmJpdERlcHRoLGQ9YS5rMSxuPWEuazIsZj1hLndpbmRvd1NpemUsdj1NYXRoLnBvdygyLGkpLTEsbD1kKnYqKGQqdiksdz1uKnYqKG4qdikscz1mKmYsZz1lKGUoe30sdCkse2RhdGE6SW50MzJBcnJheS5mcm9tKHQuZGF0YSwoZnVuY3Rpb24odCl7cmV0dXJuIHQrLjV9KSl9KSxjPWUoZSh7fSxyKSx7ZGF0YTpJbnQzMkFycmF5LmZyb20oci5kYXRhLChmdW5jdGlvbih0KXtyZXR1cm4gdCsuNX0pKX0pLHA9byhnLGYpLG09aChnLHAsZikseT1vKGMsZiksYj1oKGMseSxmKSxNPXUoZyxjLHAseSxmKSxfPXAuZGF0YS5sZW5ndGgsTz0wLGo9bmV3IEFycmF5KF8pLEE9MDtBPF87KytBKXt2YXIgaz1wLmRhdGFbQV0vcyxQPXkuZGF0YVtBXS9zLFM9bS5kYXRhW0FdLzEwMjQseD1iLmRhdGFbQV0vMTAyNCxFPSgyKmsqUCtsKSooTS5kYXRhW0FdLzEwMjQqMit3KS8oayprK1AqUCtsKS8oUyt4K3cpO2pbQV09RSwwPT1BP089RTpPKz0oRS1PKS8oQSsxKX1yZXR1cm57ZGF0YTpqLHdpZHRoOnAud2lkdGgsaGVpZ2h0OnAuaGVpZ2h0LG1zc2ltOk99fX19LHI9e307cmV0dXJuIGZ1bmN0aW9uIGUoYSl7aWYoclthXSlyZXR1cm4gclthXS5leHBvcnRzO3ZhciBpPXJbYV09e2V4cG9ydHM6e319O3JldHVybiB0W2FdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLGUpLGkuZXhwb3J0c30oNjA3KX0pKCl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zc2ltLndlYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ssim.js/dist/ssim.web.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fankeshgupta%2FDocuments%2Fimage_optimisation_new%2Fsrc%2Fpages%2Findex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);